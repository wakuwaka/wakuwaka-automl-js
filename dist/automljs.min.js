(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.aml=f()}})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){"use strict";module.exports=asPromise;function asPromise(fn,ctx){var params=new Array(arguments.length-1),offset=0,index=2,pending=true;while(index<arguments.length)params[offset++]=arguments[index++];return new Promise(function executor(resolve,reject){params[offset]=function callback(err){if(pending){pending=false;if(err)reject(err);else{var params=new Array(arguments.length-1),offset=0;while(offset<params.length)params[offset++]=arguments[offset];resolve.apply(null,params)}}};try{fn.apply(ctx||null,params)}catch(err){if(pending){pending=false;reject(err)}}})}},{}],2:[function(require,module,exports){"use strict";var base64=exports;base64.length=function length(string){var p=string.length;if(!p)return 0;var n=0;while(--p%4>1&&string.charAt(p)==="=")++n;return Math.ceil(string.length*3)/4-n};var b64=new Array(64);var s64=new Array(123);for(var i=0;i<64;)s64[b64[i]=i<26?i+65:i<52?i+71:i<62?i-4:i-59|43]=i++;base64.encode=function encode(buffer,start,end){var parts=null,chunk=[];var i=0,j=0,t;while(start<end){var b=buffer[start++];switch(j){case 0:chunk[i++]=b64[b>>2];t=(b&3)<<4;j=1;break;case 1:chunk[i++]=b64[t|b>>4];t=(b&15)<<2;j=2;break;case 2:chunk[i++]=b64[t|b>>6];chunk[i++]=b64[b&63];j=0;break}if(i>8191){(parts||(parts=[])).push(String.fromCharCode.apply(String,chunk));i=0}}if(j){chunk[i++]=b64[t];chunk[i++]=61;if(j===1)chunk[i++]=61}if(parts){if(i)parts.push(String.fromCharCode.apply(String,chunk.slice(0,i)));return parts.join("")}return String.fromCharCode.apply(String,chunk.slice(0,i))};var invalidEncoding="invalid encoding";base64.decode=function decode(string,buffer,offset){var start=offset;var j=0,t;for(var i=0;i<string.length;){var c=string.charCodeAt(i++);if(c===61&&j>1)break;if((c=s64[c])===undefined)throw Error(invalidEncoding);switch(j){case 0:t=c;j=1;break;case 1:buffer[offset++]=t<<2|(c&48)>>4;t=c;j=2;break;case 2:buffer[offset++]=(t&15)<<4|(c&60)>>2;t=c;j=3;break;case 3:buffer[offset++]=(t&3)<<6|c;j=0;break}}if(j===1)throw Error(invalidEncoding);return offset-start};base64.test=function test(string){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string)}},{}],3:[function(require,module,exports){"use strict";module.exports=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function on(evt,fn,ctx){(this._listeners[evt]||(this._listeners[evt]=[])).push({fn:fn,ctx:ctx||this});return this};EventEmitter.prototype.off=function off(evt,fn){if(evt===undefined)this._listeners={};else{if(fn===undefined)this._listeners[evt]=[];else{var listeners=this._listeners[evt];for(var i=0;i<listeners.length;)if(listeners[i].fn===fn)listeners.splice(i,1);else++i}}return this};EventEmitter.prototype.emit=function emit(evt){var listeners=this._listeners[evt];if(listeners){var args=[],i=1;for(;i<arguments.length;)args.push(arguments[i++]);for(i=0;i<listeners.length;)listeners[i].fn.apply(listeners[i++].ctx,args)}return this}},{}],4:[function(require,module,exports){"use strict";module.exports=factory(factory);function factory(exports){if(typeof Float32Array!=="undefined")(function(){var f32=new Float32Array([-0]),f8b=new Uint8Array(f32.buffer),le=f8b[3]===128;function writeFloat_f32_cpy(val,buf,pos){f32[0]=val;buf[pos]=f8b[0];buf[pos+1]=f8b[1];buf[pos+2]=f8b[2];buf[pos+3]=f8b[3]}function writeFloat_f32_rev(val,buf,pos){f32[0]=val;buf[pos]=f8b[3];buf[pos+1]=f8b[2];buf[pos+2]=f8b[1];buf[pos+3]=f8b[0]}exports.writeFloatLE=le?writeFloat_f32_cpy:writeFloat_f32_rev;exports.writeFloatBE=le?writeFloat_f32_rev:writeFloat_f32_cpy;function readFloat_f32_cpy(buf,pos){f8b[0]=buf[pos];f8b[1]=buf[pos+1];f8b[2]=buf[pos+2];f8b[3]=buf[pos+3];return f32[0]}function readFloat_f32_rev(buf,pos){f8b[3]=buf[pos];f8b[2]=buf[pos+1];f8b[1]=buf[pos+2];f8b[0]=buf[pos+3];return f32[0]}exports.readFloatLE=le?readFloat_f32_cpy:readFloat_f32_rev;exports.readFloatBE=le?readFloat_f32_rev:readFloat_f32_cpy})();else(function(){function writeFloat_ieee754(writeUint,val,buf,pos){var sign=val<0?1:0;if(sign)val=-val;if(val===0)writeUint(1/val>0?0:2147483648,buf,pos);else if(isNaN(val))writeUint(2143289344,buf,pos);else if(val>3.4028234663852886e38)writeUint((sign<<31|2139095040)>>>0,buf,pos);else if(val<1.1754943508222875e-38)writeUint((sign<<31|Math.round(val/1.401298464324817e-45))>>>0,buf,pos);else{var exponent=Math.floor(Math.log(val)/Math.LN2),mantissa=Math.round(val*Math.pow(2,-exponent)*8388608)&8388607;writeUint((sign<<31|exponent+127<<23|mantissa)>>>0,buf,pos)}}exports.writeFloatLE=writeFloat_ieee754.bind(null,writeUintLE);exports.writeFloatBE=writeFloat_ieee754.bind(null,writeUintBE);function readFloat_ieee754(readUint,buf,pos){var uint=readUint(buf,pos),sign=(uint>>31)*2+1,exponent=uint>>>23&255,mantissa=uint&8388607;return exponent===255?mantissa?NaN:sign*Infinity:exponent===0?sign*1.401298464324817e-45*mantissa:sign*Math.pow(2,exponent-150)*(mantissa+8388608)}exports.readFloatLE=readFloat_ieee754.bind(null,readUintLE);exports.readFloatBE=readFloat_ieee754.bind(null,readUintBE)})();if(typeof Float64Array!=="undefined")(function(){var f64=new Float64Array([-0]),f8b=new Uint8Array(f64.buffer),le=f8b[7]===128;function writeDouble_f64_cpy(val,buf,pos){f64[0]=val;buf[pos]=f8b[0];buf[pos+1]=f8b[1];buf[pos+2]=f8b[2];buf[pos+3]=f8b[3];buf[pos+4]=f8b[4];buf[pos+5]=f8b[5];buf[pos+6]=f8b[6];buf[pos+7]=f8b[7]}function writeDouble_f64_rev(val,buf,pos){f64[0]=val;buf[pos]=f8b[7];buf[pos+1]=f8b[6];buf[pos+2]=f8b[5];buf[pos+3]=f8b[4];buf[pos+4]=f8b[3];buf[pos+5]=f8b[2];buf[pos+6]=f8b[1];buf[pos+7]=f8b[0]}exports.writeDoubleLE=le?writeDouble_f64_cpy:writeDouble_f64_rev;exports.writeDoubleBE=le?writeDouble_f64_rev:writeDouble_f64_cpy;function readDouble_f64_cpy(buf,pos){f8b[0]=buf[pos];f8b[1]=buf[pos+1];f8b[2]=buf[pos+2];f8b[3]=buf[pos+3];f8b[4]=buf[pos+4];f8b[5]=buf[pos+5];f8b[6]=buf[pos+6];f8b[7]=buf[pos+7];return f64[0]}function readDouble_f64_rev(buf,pos){f8b[7]=buf[pos];f8b[6]=buf[pos+1];f8b[5]=buf[pos+2];f8b[4]=buf[pos+3];f8b[3]=buf[pos+4];f8b[2]=buf[pos+5];f8b[1]=buf[pos+6];f8b[0]=buf[pos+7];return f64[0]}exports.readDoubleLE=le?readDouble_f64_cpy:readDouble_f64_rev;exports.readDoubleBE=le?readDouble_f64_rev:readDouble_f64_cpy})();else(function(){function writeDouble_ieee754(writeUint,off0,off1,val,buf,pos){var sign=val<0?1:0;if(sign)val=-val;if(val===0){writeUint(0,buf,pos+off0);writeUint(1/val>0?0:2147483648,buf,pos+off1)}else if(isNaN(val)){writeUint(0,buf,pos+off0);writeUint(2146959360,buf,pos+off1)}else if(val>1.7976931348623157e308){writeUint(0,buf,pos+off0);writeUint((sign<<31|2146435072)>>>0,buf,pos+off1)}else{var mantissa;if(val<2.2250738585072014e-308){mantissa=val/5e-324;writeUint(mantissa>>>0,buf,pos+off0);writeUint((sign<<31|mantissa/4294967296)>>>0,buf,pos+off1)}else{var exponent=Math.floor(Math.log(val)/Math.LN2);if(exponent===1024)exponent=1023;mantissa=val*Math.pow(2,-exponent);writeUint(mantissa*4503599627370496>>>0,buf,pos+off0);writeUint((sign<<31|exponent+1023<<20|mantissa*1048576&1048575)>>>0,buf,pos+off1)}}}exports.writeDoubleLE=writeDouble_ieee754.bind(null,writeUintLE,0,4);exports.writeDoubleBE=writeDouble_ieee754.bind(null,writeUintBE,4,0);function readDouble_ieee754(readUint,off0,off1,buf,pos){var lo=readUint(buf,pos+off0),hi=readUint(buf,pos+off1);var sign=(hi>>31)*2+1,exponent=hi>>>20&2047,mantissa=4294967296*(hi&1048575)+lo;return exponent===2047?mantissa?NaN:sign*Infinity:exponent===0?sign*5e-324*mantissa:sign*Math.pow(2,exponent-1075)*(mantissa+4503599627370496)}exports.readDoubleLE=readDouble_ieee754.bind(null,readUintLE,0,4);exports.readDoubleBE=readDouble_ieee754.bind(null,readUintBE,4,0)})();return exports}function writeUintLE(val,buf,pos){buf[pos]=val&255;buf[pos+1]=val>>>8&255;buf[pos+2]=val>>>16&255;buf[pos+3]=val>>>24}function writeUintBE(val,buf,pos){buf[pos]=val>>>24;buf[pos+1]=val>>>16&255;buf[pos+2]=val>>>8&255;buf[pos+3]=val&255}function readUintLE(buf,pos){return(buf[pos]|buf[pos+1]<<8|buf[pos+2]<<16|buf[pos+3]<<24)>>>0}function readUintBE(buf,pos){return(buf[pos]<<24|buf[pos+1]<<16|buf[pos+2]<<8|buf[pos+3])>>>0}},{}],5:[function(require,module,exports){"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}},{}],6:[function(require,module,exports){"use strict";module.exports=pool;function pool(alloc,slice,size){var SIZE=size||8192;var MAX=SIZE>>>1;var slab=null;var offset=SIZE;return function pool_alloc(size){if(size<1||size>MAX)return alloc(size);if(offset+size>SIZE){slab=alloc(SIZE);offset=0}var buf=slice.call(slab,offset,offset+=size);if(offset&7)offset=(offset|7)+1;return buf}}},{}],7:[function(require,module,exports){"use strict";var utf8=exports;utf8.length=function utf8_length(string){var len=0,c=0;for(var i=0;i<string.length;++i){c=string.charCodeAt(i);if(c<128)len+=1;else if(c<2048)len+=2;else if((c&64512)===55296&&(string.charCodeAt(i+1)&64512)===56320){++i;len+=4}else len+=3}return len};utf8.read=function utf8_read(buffer,start,end){var len=end-start;if(len<1)return"";var parts=null,chunk=[],i=0,t;while(start<end){t=buffer[start++];if(t<128)chunk[i++]=t;else if(t>191&&t<224)chunk[i++]=(t&31)<<6|buffer[start++]&63;else if(t>239&&t<365){t=((t&7)<<18|(buffer[start++]&63)<<12|(buffer[start++]&63)<<6|buffer[start++]&63)-65536;chunk[i++]=55296+(t>>10);chunk[i++]=56320+(t&1023)}else chunk[i++]=(t&15)<<12|(buffer[start++]&63)<<6|buffer[start++]&63;if(i>8191){(parts||(parts=[])).push(String.fromCharCode.apply(String,chunk));i=0}}if(parts){if(i)parts.push(String.fromCharCode.apply(String,chunk.slice(0,i)));return parts.join("")}return String.fromCharCode.apply(String,chunk.slice(0,i))};utf8.write=function utf8_write(string,buffer,offset){var start=offset,c1,c2;for(var i=0;i<string.length;++i){c1=string.charCodeAt(i);if(c1<128){buffer[offset++]=c1}else if(c1<2048){buffer[offset++]=c1>>6|192;buffer[offset++]=c1&63|128}else if((c1&64512)===55296&&((c2=string.charCodeAt(i+1))&64512)===56320){c1=65536+((c1&1023)<<10)+(c2&1023);++i;buffer[offset++]=c1>>18|240;buffer[offset++]=c1>>12&63|128;buffer[offset++]=c1>>6&63|128;buffer[offset++]=c1&63|128}else{buffer[offset++]=c1>>12|224;buffer[offset++]=c1>>6&63|128;buffer[offset++]=c1&63|128}}return offset-start}},{}],8:[function(require,module,exports){"use strict";var $protobuf=require("protobufjs/minimal");var $Reader=$protobuf.Reader,$util=$protobuf.util;var $root=$protobuf.roots["default"]||($protobuf.roots["default"]={});$root.tensorflow=function(){var tensorflow={};tensorflow.Any=function(){function Any(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}Any.prototype.typeUrl="";Any.prototype.value=$util.newBuffer([]);Any.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.Any;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.typeUrl=r.string();break;case 2:m.value=r.bytes();break;default:r.skipType(t&7);break}}return m};return Any}();tensorflow.DataType=function(){var valuesById={},values=Object.create(valuesById);values[valuesById[0]="DT_INVALID"]=0;values[valuesById[1]="DT_FLOAT"]=1;values[valuesById[2]="DT_DOUBLE"]=2;values[valuesById[3]="DT_INT32"]=3;values[valuesById[4]="DT_UINT8"]=4;values[valuesById[5]="DT_INT16"]=5;values[valuesById[6]="DT_INT8"]=6;values[valuesById[7]="DT_STRING"]=7;values[valuesById[8]="DT_COMPLEX64"]=8;values[valuesById[9]="DT_INT64"]=9;values[valuesById[10]="DT_BOOL"]=10;values[valuesById[11]="DT_QINT8"]=11;values[valuesById[12]="DT_QUINT8"]=12;values[valuesById[13]="DT_QINT32"]=13;values[valuesById[14]="DT_BFLOAT16"]=14;values[valuesById[101]="DT_FLOAT_REF"]=101;values[valuesById[102]="DT_DOUBLE_REF"]=102;values[valuesById[103]="DT_INT32_REF"]=103;values[valuesById[104]="DT_UINT8_REF"]=104;values[valuesById[105]="DT_INT16_REF"]=105;values[valuesById[106]="DT_INT8_REF"]=106;values[valuesById[107]="DT_STRING_REF"]=107;values[valuesById[108]="DT_COMPLEX64_REF"]=108;values[valuesById[109]="DT_INT64_REF"]=109;values[valuesById[110]="DT_BOOL_REF"]=110;values[valuesById[111]="DT_QINT8_REF"]=111;values[valuesById[112]="DT_QUINT8_REF"]=112;values[valuesById[113]="DT_QINT32_REF"]=113;values[valuesById[114]="DT_BFLOAT16_REF"]=114;return values}();tensorflow.TensorShape=function(){function TensorShape(p){this.dim=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}TensorShape.prototype.dim=$util.emptyArray;TensorShape.prototype.unknownRank=false;TensorShape.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.TensorShape;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 2:if(!(m.dim&&m.dim.length))m.dim=[];m.dim.push($root.tensorflow.TensorShape.Dim.decode(r,r.uint32()));break;case 3:m.unknownRank=r.bool();break;default:r.skipType(t&7);break}}return m};TensorShape.Dim=function(){function Dim(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}Dim.prototype.size=$util.Long?$util.Long.fromBits(0,0,false):0;Dim.prototype.name="";Dim.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.TensorShape.Dim;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.size=r.int64();break;case 2:m.name=r.string();break;default:r.skipType(t&7);break}}return m};return Dim}();return TensorShape}();tensorflow.Tensor=function(){function Tensor(p){this.floatVal=[];this.doubleVal=[];this.intVal=[];this.stringVal=[];this.scomplexVal=[];this.int64Val=[];this.boolVal=[];this.uint32Val=[];this.uint64Val=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}Tensor.prototype.dtype=0;Tensor.prototype.tensorShape=null;Tensor.prototype.versionNumber=0;Tensor.prototype.tensorContent=$util.newBuffer([]);Tensor.prototype.floatVal=$util.emptyArray;Tensor.prototype.doubleVal=$util.emptyArray;Tensor.prototype.intVal=$util.emptyArray;Tensor.prototype.stringVal=$util.emptyArray;Tensor.prototype.scomplexVal=$util.emptyArray;Tensor.prototype.int64Val=$util.emptyArray;Tensor.prototype.boolVal=$util.emptyArray;Tensor.prototype.uint32Val=$util.emptyArray;Tensor.prototype.uint64Val=$util.emptyArray;Tensor.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.Tensor;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.dtype=r.int32();break;case 2:m.tensorShape=$root.tensorflow.TensorShape.decode(r,r.uint32());break;case 3:m.versionNumber=r.int32();break;case 4:m.tensorContent=r.bytes();break;case 5:if(!(m.floatVal&&m.floatVal.length))m.floatVal=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.floatVal.push(r.float())}else m.floatVal.push(r.float());break;case 6:if(!(m.doubleVal&&m.doubleVal.length))m.doubleVal=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.doubleVal.push(r.double())}else m.doubleVal.push(r.double());break;case 7:if(!(m.intVal&&m.intVal.length))m.intVal=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.intVal.push(r.int32())}else m.intVal.push(r.int32());break;case 8:if(!(m.stringVal&&m.stringVal.length))m.stringVal=[];m.stringVal.push(r.bytes());break;case 9:if(!(m.scomplexVal&&m.scomplexVal.length))m.scomplexVal=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.scomplexVal.push(r.float())}else m.scomplexVal.push(r.float());break;case 10:if(!(m.int64Val&&m.int64Val.length))m.int64Val=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.int64Val.push(r.int64())}else m.int64Val.push(r.int64());break;case 11:if(!(m.boolVal&&m.boolVal.length))m.boolVal=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.boolVal.push(r.bool())}else m.boolVal.push(r.bool());break;case 16:if(!(m.uint32Val&&m.uint32Val.length))m.uint32Val=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.uint32Val.push(r.uint32())}else m.uint32Val.push(r.uint32());break;case 17:if(!(m.uint64Val&&m.uint64Val.length))m.uint64Val=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.uint64Val.push(r.uint64())}else m.uint64Val.push(r.uint64());break;default:r.skipType(t&7);break}}return m};return Tensor}();tensorflow.AttrValue=function(){function AttrValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}AttrValue.prototype.list=null;AttrValue.prototype.s=$util.newBuffer([]);AttrValue.prototype.i=$util.Long?$util.Long.fromBits(0,0,false):0;AttrValue.prototype.f=0;AttrValue.prototype.b=false;AttrValue.prototype.type=0;AttrValue.prototype.shape=null;AttrValue.prototype.tensor=null;AttrValue.prototype.placeholder="";AttrValue.prototype.func=null;var $oneOfFields;Object.defineProperty(AttrValue.prototype,"value",{get:$util.oneOfGetter($oneOfFields=["list","s","i","f","b","type","shape","tensor","placeholder","func"]),set:$util.oneOfSetter($oneOfFields)});AttrValue.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.AttrValue;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.list=$root.tensorflow.AttrValue.ListValue.decode(r,r.uint32());break;case 2:m.s=r.bytes();break;case 3:m.i=r.int64();break;case 4:m.f=r.float();break;case 5:m.b=r.bool();break;case 6:m.type=r.int32();break;case 7:m.shape=$root.tensorflow.TensorShape.decode(r,r.uint32());break;case 8:m.tensor=$root.tensorflow.Tensor.decode(r,r.uint32());break;case 9:m.placeholder=r.string();break;case 10:m.func=$root.tensorflow.NameAttrList.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};AttrValue.ListValue=function(){function ListValue(p){this.s=[];this.i=[];this.f=[];this.b=[];this.type=[];this.shape=[];this.tensor=[];this.func=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}ListValue.prototype.s=$util.emptyArray;ListValue.prototype.i=$util.emptyArray;ListValue.prototype.f=$util.emptyArray;ListValue.prototype.b=$util.emptyArray;ListValue.prototype.type=$util.emptyArray;ListValue.prototype.shape=$util.emptyArray;ListValue.prototype.tensor=$util.emptyArray;ListValue.prototype.func=$util.emptyArray;ListValue.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.AttrValue.ListValue;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 2:if(!(m.s&&m.s.length))m.s=[];m.s.push(r.bytes());break;case 3:if(!(m.i&&m.i.length))m.i=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.i.push(r.int64())}else m.i.push(r.int64());break;case 4:if(!(m.f&&m.f.length))m.f=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.f.push(r.float())}else m.f.push(r.float());break;case 5:if(!(m.b&&m.b.length))m.b=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.b.push(r.bool())}else m.b.push(r.bool());break;case 6:if(!(m.type&&m.type.length))m.type=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.type.push(r.int32())}else m.type.push(r.int32());break;case 7:if(!(m.shape&&m.shape.length))m.shape=[];m.shape.push($root.tensorflow.TensorShape.decode(r,r.uint32()));break;case 8:if(!(m.tensor&&m.tensor.length))m.tensor=[];m.tensor.push($root.tensorflow.Tensor.decode(r,r.uint32()));break;case 9:if(!(m.func&&m.func.length))m.func=[];m.func.push($root.tensorflow.NameAttrList.decode(r,r.uint32()));break;default:r.skipType(t&7);break}}return m};return ListValue}();return AttrValue}();tensorflow.NameAttrList=function(){function NameAttrList(p){this.attr={};if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}NameAttrList.prototype.name="";NameAttrList.prototype.attr=$util.emptyObject;NameAttrList.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.NameAttrList,k;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.name=r.string();break;case 2:r.skip().pos++;if(m.attr===$util.emptyObject)m.attr={};k=r.string();r.pos++;m.attr[k]=$root.tensorflow.AttrValue.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};return NameAttrList}();tensorflow.NodeDef=function(){function NodeDef(p){this.input=[];this.attr={};if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}NodeDef.prototype.name="";NodeDef.prototype.op="";NodeDef.prototype.input=$util.emptyArray;NodeDef.prototype.device="";NodeDef.prototype.attr=$util.emptyObject;NodeDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.NodeDef,k;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.name=r.string();break;case 2:m.op=r.string();break;case 3:if(!(m.input&&m.input.length))m.input=[];m.input.push(r.string());break;case 4:m.device=r.string();break;case 5:r.skip().pos++;if(m.attr===$util.emptyObject)m.attr={};k=r.string();r.pos++;m.attr[k]=$root.tensorflow.AttrValue.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};return NodeDef}();tensorflow.VersionDef=function(){function VersionDef(p){this.badConsumers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}VersionDef.prototype.producer=0;VersionDef.prototype.minConsumer=0;VersionDef.prototype.badConsumers=$util.emptyArray;VersionDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.VersionDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.producer=r.int32();break;case 2:m.minConsumer=r.int32();break;case 3:if(!(m.badConsumers&&m.badConsumers.length))m.badConsumers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.badConsumers.push(r.int32())}else m.badConsumers.push(r.int32());break;default:r.skipType(t&7);break}}return m};return VersionDef}();tensorflow.GraphDef=function(){function GraphDef(p){this.node=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}GraphDef.prototype.node=$util.emptyArray;GraphDef.prototype.versions=null;GraphDef.prototype.library=null;GraphDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.GraphDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.node&&m.node.length))m.node=[];m.node.push($root.tensorflow.NodeDef.decode(r,r.uint32()));break;case 4:m.versions=$root.tensorflow.VersionDef.decode(r,r.uint32());break;case 2:m.library=$root.tensorflow.FunctionDefLibrary.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};return GraphDef}();tensorflow.CollectionDef=function(){function CollectionDef(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}CollectionDef.prototype.nodeList=null;CollectionDef.prototype.bytesList=null;CollectionDef.prototype.int64List=null;CollectionDef.prototype.floatList=null;CollectionDef.prototype.anyList=null;var $oneOfFields;Object.defineProperty(CollectionDef.prototype,"kind",{get:$util.oneOfGetter($oneOfFields=["nodeList","bytesList","int64List","floatList","anyList"]),set:$util.oneOfSetter($oneOfFields)});CollectionDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.CollectionDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.nodeList=$root.tensorflow.CollectionDef.NodeList.decode(r,r.uint32());break;case 2:m.bytesList=$root.tensorflow.CollectionDef.BytesList.decode(r,r.uint32());break;case 3:m.int64List=$root.tensorflow.CollectionDef.Int64List.decode(r,r.uint32());break;case 4:m.floatList=$root.tensorflow.CollectionDef.FloatList.decode(r,r.uint32());break;case 5:m.anyList=$root.tensorflow.CollectionDef.AnyList.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};CollectionDef.NodeList=function(){function NodeList(p){this.value=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}NodeList.prototype.value=$util.emptyArray;NodeList.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.CollectionDef.NodeList;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.value&&m.value.length))m.value=[];m.value.push(r.string());break;default:r.skipType(t&7);break}}return m};return NodeList}();CollectionDef.BytesList=function(){function BytesList(p){this.value=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}BytesList.prototype.value=$util.emptyArray;BytesList.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.CollectionDef.BytesList;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.value&&m.value.length))m.value=[];m.value.push(r.bytes());break;default:r.skipType(t&7);break}}return m};return BytesList}();CollectionDef.Int64List=function(){function Int64List(p){this.value=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}Int64List.prototype.value=$util.emptyArray;Int64List.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.CollectionDef.Int64List;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.value&&m.value.length))m.value=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.value.push(r.int64())}else m.value.push(r.int64());break;default:r.skipType(t&7);break}}return m};return Int64List}();CollectionDef.FloatList=function(){function FloatList(p){this.value=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}FloatList.prototype.value=$util.emptyArray;FloatList.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.CollectionDef.FloatList;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.value&&m.value.length))m.value=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.value.push(r.float())}else m.value.push(r.float());break;default:r.skipType(t&7);break}}return m};return FloatList}();CollectionDef.AnyList=function(){function AnyList(p){this.value=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}AnyList.prototype.value=$util.emptyArray;AnyList.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.CollectionDef.AnyList;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.value&&m.value.length))m.value=[];m.value.push($root.tensorflow.Any.decode(r,r.uint32()));break;default:r.skipType(t&7);break}}return m};return AnyList}();return CollectionDef}();tensorflow.SaverDef=function(){function SaverDef(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}SaverDef.prototype.filenameTensorName="";SaverDef.prototype.saveTensorName="";SaverDef.prototype.restoreOpName="";SaverDef.prototype.maxToKeep=0;SaverDef.prototype.sharded=false;SaverDef.prototype.keepCheckpointEveryNHours=0;SaverDef.prototype.version=0;SaverDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.SaverDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.filenameTensorName=r.string();break;case 2:m.saveTensorName=r.string();break;case 3:m.restoreOpName=r.string();break;case 4:m.maxToKeep=r.int32();break;case 5:m.sharded=r.bool();break;case 6:m.keepCheckpointEveryNHours=r.float();break;case 7:m.version=r.int32();break;default:r.skipType(t&7);break}}return m};SaverDef.CheckpointFormatVersion=function(){var valuesById={},values=Object.create(valuesById);values[valuesById[0]="LEGACY"]=0;values[valuesById[1]="V1"]=1;values[valuesById[2]="V2"]=2;return values}();return SaverDef}();tensorflow.TensorInfo=function(){function TensorInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}TensorInfo.prototype.name="";TensorInfo.prototype.cooSparse=null;TensorInfo.prototype.dtype=0;TensorInfo.prototype.tensorShape=null;var $oneOfFields;Object.defineProperty(TensorInfo.prototype,"encoding",{get:$util.oneOfGetter($oneOfFields=["name","cooSparse"]),set:$util.oneOfSetter($oneOfFields)});TensorInfo.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.TensorInfo;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.name=r.string();break;case 4:m.cooSparse=$root.tensorflow.TensorInfo.CooSparse.decode(r,r.uint32());break;case 2:m.dtype=r.int32();break;case 3:m.tensorShape=$root.tensorflow.TensorShape.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};TensorInfo.CooSparse=function(){function CooSparse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}CooSparse.prototype.valuesTensorName="";CooSparse.prototype.indicesTensorName="";CooSparse.prototype.denseShapeTensorName="";CooSparse.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.TensorInfo.CooSparse;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.valuesTensorName=r.string();break;case 2:m.indicesTensorName=r.string();break;case 3:m.denseShapeTensorName=r.string();break;default:r.skipType(t&7);break}}return m};return CooSparse}();return TensorInfo}();tensorflow.SignatureDef=function(){function SignatureDef(p){this.inputs={};this.outputs={};if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}SignatureDef.prototype.inputs=$util.emptyObject;SignatureDef.prototype.outputs=$util.emptyObject;SignatureDef.prototype.methodName="";SignatureDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.SignatureDef,k;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:r.skip().pos++;if(m.inputs===$util.emptyObject)m.inputs={};k=r.string();r.pos++;m.inputs[k]=$root.tensorflow.TensorInfo.decode(r,r.uint32());break;case 2:r.skip().pos++;if(m.outputs===$util.emptyObject)m.outputs={};k=r.string();r.pos++;m.outputs[k]=$root.tensorflow.TensorInfo.decode(r,r.uint32());break;case 3:m.methodName=r.string();break;default:r.skipType(t&7);break}}return m};return SignatureDef}();tensorflow.AssetFileDef=function(){function AssetFileDef(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}AssetFileDef.prototype.tensorInfo=null;AssetFileDef.prototype.filename="";AssetFileDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.AssetFileDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.tensorInfo=$root.tensorflow.TensorInfo.decode(r,r.uint32());break;case 2:m.filename=r.string();break;default:r.skipType(t&7);break}}return m};return AssetFileDef}();tensorflow.OpDef=function(){function OpDef(p){this.inputArg=[];this.outputArg=[];this.attr=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}OpDef.prototype.name="";OpDef.prototype.inputArg=$util.emptyArray;OpDef.prototype.outputArg=$util.emptyArray;OpDef.prototype.attr=$util.emptyArray;OpDef.prototype.deprecation=null;OpDef.prototype.summary="";OpDef.prototype.description="";OpDef.prototype.isCommutative=false;OpDef.prototype.isAggregate=false;OpDef.prototype.isStateful=false;OpDef.prototype.allowsUninitializedInput=false;OpDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.OpDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.name=r.string();break;case 2:if(!(m.inputArg&&m.inputArg.length))m.inputArg=[];m.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(r,r.uint32()));break;case 3:if(!(m.outputArg&&m.outputArg.length))m.outputArg=[];m.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(r,r.uint32()));break;case 4:if(!(m.attr&&m.attr.length))m.attr=[];m.attr.push($root.tensorflow.OpDef.AttrDef.decode(r,r.uint32()));break;case 8:m.deprecation=$root.tensorflow.OpDef.OpDeprecation.decode(r,r.uint32());break;case 5:m.summary=r.string();break;case 6:m.description=r.string();break;case 18:m.isCommutative=r.bool();break;case 16:m.isAggregate=r.bool();break;case 17:m.isStateful=r.bool();break;case 19:m.allowsUninitializedInput=r.bool();break;default:r.skipType(t&7);break}}return m};OpDef.ArgDef=function(){function ArgDef(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}ArgDef.prototype.name="";ArgDef.prototype.description="";ArgDef.prototype.type=0;ArgDef.prototype.typeAttr="";ArgDef.prototype.numberAttr="";ArgDef.prototype.typeListAttr="";ArgDef.prototype.isRef=false;ArgDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.OpDef.ArgDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.name=r.string();break;case 2:m.description=r.string();break;case 3:m.type=r.int32();break;case 4:m.typeAttr=r.string();break;case 5:m.numberAttr=r.string();break;case 6:m.typeListAttr=r.string();break;case 16:m.isRef=r.bool();break;default:r.skipType(t&7);break}}return m};return ArgDef}();OpDef.AttrDef=function(){function AttrDef(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}AttrDef.prototype.name="";AttrDef.prototype.type="";AttrDef.prototype.defaultValue=null;AttrDef.prototype.description="";AttrDef.prototype.hasMinimum=false;AttrDef.prototype.minimum=$util.Long?$util.Long.fromBits(0,0,false):0;AttrDef.prototype.allowedValues=null;AttrDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.OpDef.AttrDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.name=r.string();break;case 2:m.type=r.string();break;case 3:m.defaultValue=$root.tensorflow.AttrValue.decode(r,r.uint32());break;case 4:m.description=r.string();break;case 5:m.hasMinimum=r.bool();break;case 6:m.minimum=r.int64();break;case 7:m.allowedValues=$root.tensorflow.AttrValue.decode(r,r.uint32());break;default:r.skipType(t&7);break}}return m};return AttrDef}();OpDef.OpDeprecation=function(){function OpDeprecation(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}OpDeprecation.prototype.version=0;OpDeprecation.prototype.explanation="";OpDeprecation.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.OpDef.OpDeprecation;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.version=r.int32();break;case 2:m.explanation=r.string();break;default:r.skipType(t&7);break}}return m};return OpDeprecation}();return OpDef}();tensorflow.OpList=function(){function OpList(p){this.op=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}OpList.prototype.op=$util.emptyArray;OpList.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.OpList;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m.op&&m.op.length))m.op=[];m.op.push($root.tensorflow.OpDef.decode(r,r.uint32()));break;default:r.skipType(t&7);break}}return m};return OpList}();tensorflow.MetaGraphDef=function(){function MetaGraphDef(p){this.collectionDef={};this.signatureDef={};this.assetFileDef=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}MetaGraphDef.prototype.metaInfoDef=null;MetaGraphDef.prototype.graphDef=null;MetaGraphDef.prototype.saverDef=null;MetaGraphDef.prototype.collectionDef=$util.emptyObject;MetaGraphDef.prototype.signatureDef=$util.emptyObject;MetaGraphDef.prototype.assetFileDef=$util.emptyArray;MetaGraphDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.MetaGraphDef,k;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.metaInfoDef=$root.tensorflow.MetaGraphDef.MetaInfoDef.decode(r,r.uint32());break;case 2:m.graphDef=$root.tensorflow.GraphDef.decode(r,r.uint32());break;case 3:m.saverDef=$root.tensorflow.SaverDef.decode(r,r.uint32());break;case 4:r.skip().pos++;if(m.collectionDef===$util.emptyObject)m.collectionDef={};k=r.string();r.pos++;m.collectionDef[k]=$root.tensorflow.CollectionDef.decode(r,r.uint32());break;case 5:r.skip().pos++;if(m.signatureDef===$util.emptyObject)m.signatureDef={};k=r.string();r.pos++;m.signatureDef[k]=$root.tensorflow.SignatureDef.decode(r,r.uint32());break;case 6:if(!(m.assetFileDef&&m.assetFileDef.length))m.assetFileDef=[];m.assetFileDef.push($root.tensorflow.AssetFileDef.decode(r,r.uint32()));break;default:r.skipType(t&7);break}}return m};MetaGraphDef.MetaInfoDef=function(){function MetaInfoDef(p){this.tags=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}MetaInfoDef.prototype.metaGraphVersion="";MetaInfoDef.prototype.strippedOpList=null;MetaInfoDef.prototype.anyInfo=null;MetaInfoDef.prototype.tags=$util.emptyArray;MetaInfoDef.prototype.tensorflowVersion="";MetaInfoDef.prototype.tensorflowGitVersion="";MetaInfoDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.MetaGraphDef.MetaInfoDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.metaGraphVersion=r.string();break;case 2:m.strippedOpList=$root.tensorflow.OpList.decode(r,r.uint32());break;case 3:m.anyInfo=$root.tensorflow.Any.decode(r,r.uint32());break;case 4:if(!(m.tags&&m.tags.length))m.tags=[];m.tags.push(r.string());break;case 5:m.tensorflowVersion=r.string();break;case 6:m.tensorflowGitVersion=r.string();break;default:r.skipType(t&7);break}}return m};return MetaInfoDef}();return MetaGraphDef}();tensorflow.SavedModel=function(){function SavedModel(p){this.metaGraphs=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}SavedModel.prototype.savedModelSchemaVersion=$util.Long?$util.Long.fromBits(0,0,false):0;SavedModel.prototype.metaGraphs=$util.emptyArray;SavedModel.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.SavedModel;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.savedModelSchemaVersion=r.int64();break;case 2:if(!(m.metaGraphs&&m.metaGraphs.length))m.metaGraphs=[];m.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(r,r.uint32()));break;default:r.skipType(t&7);break}}return m};return SavedModel}();tensorflow.FunctionDefLibrary=function(){function FunctionDefLibrary(p){this["function"]=[];this.gradient=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}FunctionDefLibrary.prototype["function"]=$util.emptyArray;FunctionDefLibrary.prototype.gradient=$util.emptyArray;FunctionDefLibrary.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.FunctionDefLibrary;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:if(!(m["function"]&&m["function"].length))m["function"]=[];m["function"].push($root.tensorflow.FunctionDef.decode(r,r.uint32()));break;case 2:if(!(m.gradient&&m.gradient.length))m.gradient=[];m.gradient.push($root.tensorflow.GradientDef.decode(r,r.uint32()));break;default:r.skipType(t&7);break}}return m};return FunctionDefLibrary}();tensorflow.FunctionDef=function(){function FunctionDef(p){this.attr={};this.nodeDef=[];this.ret={};if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}FunctionDef.prototype.signature=null;FunctionDef.prototype.attr=$util.emptyObject;FunctionDef.prototype.nodeDef=$util.emptyArray;FunctionDef.prototype.ret=$util.emptyObject;FunctionDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.FunctionDef,k;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.signature=$root.tensorflow.OpDef.decode(r,r.uint32());break;case 5:r.skip().pos++;if(m.attr===$util.emptyObject)m.attr={};k=r.string();r.pos++;m.attr[k]=$root.tensorflow.AttrValue.decode(r,r.uint32());break;case 3:if(!(m.nodeDef&&m.nodeDef.length))m.nodeDef=[];m.nodeDef.push($root.tensorflow.NodeDef.decode(r,r.uint32()));break;case 4:r.skip().pos++;if(m.ret===$util.emptyObject)m.ret={};k=r.string();r.pos++;m.ret[k]=r.string();break;default:r.skipType(t&7);break}}return m};return FunctionDef}();tensorflow.GradientDef=function(){function GradientDef(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]]}GradientDef.prototype.functionName="";GradientDef.prototype.gradientFunc="";GradientDef.decode=function decode(r,l){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.tensorflow.GradientDef;while(r.pos<c){var t=r.uint32();switch(t>>>3){case 1:m.functionName=r.string();break;case 2:m.gradientFunc=r.string();break;default:r.skipType(t&7);break}}return m};return GradientDef}();return tensorflow}();module.exports=$root},{"protobufjs/minimal":245}],9:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ExecutionContext=function(){function ExecutionContext(weightMap,tensorArrayMap){this.weightMap=weightMap;this.tensorArrayMap=tensorArrayMap;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}ExecutionContext.prototype.newFrame=function(id,frameName){return{id:id,frameName:frameName,iterationId:0}};Object.defineProperty(ExecutionContext.prototype,"currentContext",{get:function(){return this.contexts},set:function(contexts){if(this.contexts!==contexts){this.contexts=contexts;this.generateCurrentContextIds()}},enumerable:true,configurable:true});Object.defineProperty(ExecutionContext.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:true,configurable:true});Object.defineProperty(ExecutionContext.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:true,configurable:true});ExecutionContext.prototype.generateCurrentContextIds=function(){var names=[];for(var i=0;i<this.contexts.length-1;i++){var contexts=this.contexts.slice(0,this.contexts.length-i);names.push(this.contextIdforContexts(contexts))}names.push("");this._currentContextIds=names};ExecutionContext.prototype.contextIdforContexts=function(contexts){return contexts?contexts.map(function(context){return context.id===0&&context.iterationId===0?"":context.frameName+"-"+context.iterationId}).join("/"):""};ExecutionContext.prototype.enterFrame=function(frameId){if(this.contexts){this.lastId++;this.contexts=this.contexts.slice();this.contexts.push(this.newFrame(this.lastId,frameId));this._currentContextIds.unshift(this.contextIdforContexts(this.contexts))}};ExecutionContext.prototype.exitFrame=function(){if(this.contexts&&this.contexts.length>1){this.contexts=this.contexts.slice();this.contexts.splice(-1);this.currentContextIds.shift()}else{throw new Error("Cannot exit frame, the context is empty")}};ExecutionContext.prototype.nextIteration=function(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice();this.lastId++;var context=Object.assign({},this.contexts[this.contexts.length-1]);context.iterationId+=1;context.id=this.lastId;this.contexts.splice(-1,1,context);this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else{throw new Error("Cannot increase frame iteration, the context is empty")}};ExecutionContext.prototype.getWeight=function(name){return this.weightMap[name]};ExecutionContext.prototype.addTensorArray=function(tensorArray){this.tensorArrayMap[tensorArray.id]=tensorArray};ExecutionContext.prototype.getTensorArray=function(id){return this.tensorArrayMap[id]};return ExecutionContext}();exports.ExecutionContext=ExecutionContext},{}],10:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var compiled_api_1=require("../data/compiled_api");var operation_mapper_1=require("../operations/operation_mapper");var graph_executor_1=require("./graph_executor");var FrozenModel=function(){function FrozenModel(modelUrl,weightManifestUrl,requestOption){this.modelUrl=modelUrl;this.weightManifestUrl=weightManifestUrl;this.requestOption=requestOption;this.version="n/a"}Object.defineProperty(FrozenModel.prototype,"modelVersion",{get:function(){return this.version},enumerable:true,configurable:true});Object.defineProperty(FrozenModel.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:true,configurable:true});Object.defineProperty(FrozenModel.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:true,configurable:true});Object.defineProperty(FrozenModel.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:true,configurable:true});Object.defineProperty(FrozenModel.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:true,configurable:true});Object.defineProperty(FrozenModel.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:true,configurable:true});FrozenModel.prototype.findIOHandler=function(){var path=[this.modelUrl,this.weightManifestUrl];if(this.requestOption){this.handler=tfc.io.browserHTTPRequest(path,this.requestOption)}else{var handlers=tfc.io.getLoadHandlers(path);if(handlers.length===0){handlers.push(tfc.io.browserHTTPRequest(path,this.requestOption))}else if(handlers.length>1){throw new Error("Found more than one ("+handlers.length+") load handlers for "+("URL '"+[path]+"'"))}this.handler=handlers[0]}};FrozenModel.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var artifacts,graph,weightMap;return __generator(this,function(_a){switch(_a.label){case 0:this.findIOHandler();if(this.handler.load==null){throw new Error("Cannot proceed with model loading because the IOHandler provided "+"does not have the `load` method implemented.")}return[4,this.handler.load()];case 1:artifacts=_a.sent();graph=compiled_api_1.tensorflow.GraphDef.decode(new Uint8Array(artifacts.modelTopology));this.version=graph.versions.producer+"."+graph.versions.minConsumer;weightMap=tfc.io.decodeWeights(artifacts.weightData,artifacts.weightSpecs);this.executor=new graph_executor_1.GraphExecutor(operation_mapper_1.OperationMapper.Instance.transformGraph(graph));this.executor.weightMap=this.convertTensorMapToTensorsMap(weightMap);return[2,true]}})})};FrozenModel.prototype.predict=function(inputs,config){return this.execute_(inputs,true,this.outputNodes)};FrozenModel.prototype.constructTensorMap=function(inputs){var inputArray=inputs instanceof tfc.Tensor?[inputs]:inputs;if(inputArray.length!==this.inputNodes.length){throw new Error("Input tensor count mismatch,"+("the frozen model has "+this.inputNodes.length+" placeholders, ")+("while there are "+inputArray.length+" input tensors."))}return this.inputNodes.reduce(function(map,inputName,i){map[inputName]=inputArray[i];return map},{})};FrozenModel.prototype.execute=function(inputs,outputs){return this.execute_(inputs,false,outputs)};FrozenModel.prototype.execute_=function(inputs,strictInputCheck,outputs){if(strictInputCheck===void 0){strictInputCheck=true}outputs=outputs||this.outputNodes;if(inputs instanceof tfc.Tensor||Array.isArray(inputs)){inputs=this.constructTensorMap(inputs)}if(this.executor.isControlFlowModel||this.executor.isDynamicShapeModel){throw new Error("The model contains control flow or dynamic shape ops, "+"please use executeAsync method")}var result=this.executor.execute(this.convertTensorMapToTensorsMap(inputs),strictInputCheck,outputs);var keys=Object.keys(result);return Array.isArray(outputs)&&outputs.length>1?outputs.map(function(node){return result[node]}):result[keys[0]]};FrozenModel.prototype.executeAsync=function(inputs,outputs){return __awaiter(this,void 0,void 0,function(){var result,keys;return __generator(this,function(_a){switch(_a.label){case 0:if(!(this.executor.isControlFlowModel||this.executor.isDynamicShapeModel)){throw new Error("The model does not contain control flow or dynamic shape ops, "+"please use execute method for better performance.")}outputs=outputs||this.outputNodes;if(inputs instanceof tfc.Tensor||Array.isArray(inputs)){inputs=this.constructTensorMap(inputs)}return[4,this.executor.executeAsync(this.convertTensorMapToTensorsMap(inputs),outputs)];case 1:result=_a.sent();keys=Object.keys(result);return[2,Array.isArray(outputs)&&outputs.length>1?outputs.map(function(node){return result[node]}):result[keys[0]]]}})})};FrozenModel.prototype.convertTensorMapToTensorsMap=function(map){return Object.keys(map).reduce(function(newMap,key){newMap[key]=[map[key]];return newMap},{})};FrozenModel.prototype.dispose=function(){this.executor.dispose()};return FrozenModel}();exports.FrozenModel=FrozenModel;function loadFrozenModel(modelUrl,weightsManifestUrl,requestOption){return __awaiter(this,void 0,void 0,function(){var model;return __generator(this,function(_a){switch(_a.label){case 0:model=new FrozenModel(modelUrl,weightsManifestUrl,requestOption);return[4,model.load()];case 1:_a.sent();return[2,model]}})})}exports.loadFrozenModel=loadFrozenModel},{"../data/compiled_api":8,"../operations/operation_mapper":46,"./graph_executor":11,"@tensorflow/tfjs-core":55}],11:[function(require,module,exports){"use strict";var __assign=this&&this.__assign||Object.assign||function(t){for(var s,i=1,n=arguments.length;i<n;i++){s=arguments[i];for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p))t[p]=s[p]}return t};var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var tfjs_core_1=require("@tensorflow/tfjs-core");var utils_1=require("../operations/executors/utils");var operation_executor_1=require("../operations/operation_executor");var execution_context_1=require("./execution_context");var GraphExecutor=function(){function GraphExecutor(graph){this.graph=graph;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this.placeholders=graph.placeholders;this._outputs=graph.outputs;this.compile()}Object.defineProperty(GraphExecutor.prototype,"weightMap",{get:function(){return this._weightMap},set:function(weightMap){var weightIds=Object.keys(weightMap).map(function(key){return weightMap[key].map(function(tensor){return tensor.id})});this.weightIds=[].concat.apply([],weightIds);this._weightMap=weightMap},enumerable:true,configurable:true});Object.defineProperty(GraphExecutor.prototype,"inputs",{get:function(){return this.placeholders.map(function(node){return{name:node.name,shape:node.params["shape"]?node.params["shape"].value:undefined,dtype:node.params["dtype"]?node.params["dtype"].value:undefined}})},enumerable:true,configurable:true});Object.defineProperty(GraphExecutor.prototype,"outputs",{get:function(){return this._outputs.map(function(node){return{name:node.name,shape:node.params["shape"]?node.params["shape"].value:undefined,dtype:node.params["dtype"]?node.params["dtype"].value:undefined}})},enumerable:true,configurable:true});Object.defineProperty(GraphExecutor.prototype,"inputNodes",{get:function(){return this.placeholders.map(function(node){return node.name})},enumerable:true,configurable:true});Object.defineProperty(GraphExecutor.prototype,"outputNodes",{get:function(){return this.outputs.map(function(node){return node.name})},enumerable:true,configurable:true});Object.defineProperty(GraphExecutor.prototype,"isControlFlowModel",{get:function(){return this.graph.withControlFlow},enumerable:true,configurable:true});Object.defineProperty(GraphExecutor.prototype,"isDynamicShapeModel",{get:function(){return this.graph.withDynamicShape},enumerable:true,configurable:true});GraphExecutor.prototype.compile=function(startNodes){if(this.graph.withControlFlow||this.graph.withDynamicShape){return}var compiledOrder=[];var inputs=startNodes||this.graph.placeholders;var sortedNodeNames=inputs.map(function(node){return node.name}).sort();var nameKey=sortedNodeNames.join(this.SEPERATOR);if(this.compiledMap.get(nameKey)){return}var stack=inputs.concat(this.graph.weights);var visited={};while(stack.length>0){var node=stack.pop();visited[node.name]=true;compiledOrder.push(node);node.children.forEach(function(childNode){if(!visited[childNode.name]&&childNode.inputNames.every(function(name){var nodeName=utils_1.getNodeNameAndIndex(name)[0];return visited[nodeName]})){stack.push(childNode)}})}this.compiledMap.set(nameKey,compiledOrder)};GraphExecutor.prototype.execute=function(inputs,strictInputCheck,outputs){var _this=this;if(strictInputCheck===void 0){strictInputCheck=true}var names=Object.keys(inputs).sort();this.checkInput(inputs,strictInputCheck);this.checkInputShapeAndType(inputs,strictInputCheck);this.compile(names.map(function(name){return _this.graph.nodes[name]}));var outputNames=this.calculateOutputs(outputs);this.checkOutput(this.compiledMap.get(names.join(this.SEPERATOR)),outputNames);var tensorArrayMap={};var result=tfjs_core_1.tidy(function(){var context=new execution_context_1.ExecutionContext(_this._weightMap,tensorArrayMap);var tensorMap=__assign({},_this.weightMap,inputs);var compiledNodes=_this.compiledMap.get(names.join(_this.SEPERATOR));for(var i=0;i<compiledNodes.length;i++){var node=compiledNodes[i];if(!tensorMap[node.name]){tensorMap[node.name]=operation_executor_1.executeOp(node,tensorMap,context)}if(outputNames.every(function(name){return!!tensorMap[name]})){break}}return _this.findOutputs(tensorMap,context,outputNames)});return result};GraphExecutor.prototype.executeAsync=function(inputs,outputs){return __awaiter(this,void 0,void 0,function(){var _this=this;var tensorArrayMap,context,tensors,results,outputIds,inputIdArray,inputIds;return __generator(this,function(_a){switch(_a.label){case 0:this.checkInput(inputs,false);this.checkInputShapeAndType(inputs,false);tensorArrayMap={};context=new execution_context_1.ExecutionContext(this._weightMap,tensorArrayMap);return[4,this.executeWithControlFlow(inputs,context)];case 1:tensors=_a.sent();results=this.findOutputs(tensors,context,outputs);outputIds=Object.keys(results).map(function(key){return results[key].id});inputIdArray=Object.keys(inputs).map(function(key){return inputs[key].map(function(input){return input.id})});inputIds=[].concat.apply([],inputIdArray);Object.keys(tensors).forEach(function(key){var tensorArray=tensors[key];tensorArray.forEach(function(tensor){if(tensor&&outputIds.indexOf(tensor.id)===-1&&inputIds.indexOf(tensor.id)===-1&&_this.weightIds.indexOf(tensor.id)===-1){tensor.dispose()}})});return[2,results]}})})};GraphExecutor.prototype.executeWithControlFlow=function(inputs,context){return __awaiter(this,void 0,void 0,function(){var _this=this;var names,inputNodes,stack,tensorMap,added,promises;return __generator(this,function(_a){switch(_a.label){case 0:names=Object.keys(inputs);inputNodes=names.map(function(name){return _this.graph.nodes[name]});stack=inputNodes.concat(this.graph.weights).map(function(node){return{node:node,contexts:context.currentContext}});tensorMap=__assign({},this.weightMap,inputs);added={};_a.label=1;case 1:if(!(stack.length>0))return[3,3];promises=this.processStack(inputNodes,stack,context,tensorMap,added);return[4,Promise.all(promises)];case 2:_a.sent();return[3,1];case 3:return[2,tensorMap]}})})};GraphExecutor.prototype.processStack=function(inputNodes,stack,context,tensorMap,added){var _this=this;var promises=[];var _loop_1=function(){var item=stack.pop();context.currentContext=item.contexts;var nodeName="";if(item.node.op==="enter"&&utils_1.getParamValue("isConstant",item.node,tensorMap,context)){nodeName=utils_1.getNodeNameAndIndex(item.node.name,context)[0]}if(inputNodes.indexOf(item.node)===-1){var tensors=operation_executor_1.executeOp(item.node,tensorMap,context);if(!nodeName){nodeName=utils_1.getNodeNameAndIndex(item.node.name,context)[0]}var currentContext_1=context.currentContext;if(tensors instanceof Promise){promises.push(tensors.then(function(t){tensorMap[nodeName]=t;context.currentContext=currentContext_1;_this.processChildNodes(item.node,stack,context,tensorMap,added);return t}))}else{tensorMap[nodeName]=tensors;this_1.processChildNodes(item.node,stack,context,tensorMap,added)}}else{this_1.processChildNodes(item.node,stack,context,tensorMap,added)}};var this_1=this;while(stack.length>0){_loop_1()}return promises};GraphExecutor.prototype.processChildNodes=function(node,stack,context,tensorMap,added){node.children.forEach(function(childNode){var nodeName=utils_1.getNodeNameAndIndex(childNode.name,context)[0];if(!added[nodeName]){if(childNode.op==="merge"){if(childNode.inputNames.some(function(name){return!!utils_1.getTensor(name,tensorMap,context)})){added[nodeName]=true;stack.push({contexts:context.currentContext,node:childNode})}}else if(childNode.inputNames.every(function(name){return!!utils_1.getTensor(name,tensorMap,context)})){added[nodeName]=true;stack.push({contexts:context.currentContext,node:childNode})}}})};GraphExecutor.prototype.calculateOutputs=function(outputs){if(outputs&&!(outputs instanceof Array)){outputs=[outputs]}return outputs||this.graph.outputs.map(function(node){return node.name})};GraphExecutor.prototype.findOutputs=function(tensorMap,context,outputs){var requestedOutputs=this.calculateOutputs(outputs);return requestedOutputs.reduce(function(map,name){map[name]=utils_1.getTensor(name,tensorMap,context);return map},{})};GraphExecutor.prototype.dispose=function(){var _this=this;Object.keys(this.weightMap).forEach(function(key){return _this.weightMap[key].forEach(function(tensor){return tensor.dispose()})})};GraphExecutor.prototype.checkInputShapeAndType=function(inputs,strictInputCheck){if(strictInputCheck===void 0){strictInputCheck=true}this.placeholders.forEach(function(node){var inputTensors=inputs[node.name];if(!strictInputCheck&&!inputTensors){return}var input=inputTensors[0];if(node.params["shape"]&&node.params["shape"].value){var shape_1=node.params["shape"].value;var match=shape_1.length===input.shape.length&&input.shape.every(function(dim,index){return shape_1[index]===-1||shape_1[index]===dim});tfjs_core_1.util.assert(match,"The shape of dict['"+node.name+"'] provided in model.execute(dict) must be ["+shape_1+"], but was ["+input.shape+"]")}if(node.params["dtype"]&&node.params["dtype"].value){tfjs_core_1.util.assert(input.dtype===node.params["dtype"].value,"The dtype of dict['"+node.name+"'] provided in model.execute(dict) must be "+node.params["dtype"].value+", but was "+input.dtype)}})};GraphExecutor.prototype.checkInput=function(inputs,strictInputCheck){var _this=this;if(strictInputCheck===void 0){strictInputCheck=true}var inputKeys=Object.keys(inputs);var missing=[];var extra=[];this.inputNodes.forEach(function(name){if(inputKeys.indexOf(name)===-1)missing.push(name)});inputKeys.forEach(function(name){if(_this.inputNodes.indexOf(name)===-1)extra.push(name)});var notInGraph=extra.filter(function(name){return!_this.graph.nodes[name]});if(missing.length>0&&strictInputCheck){throw new Error("The dict provided in model.execute(dict) has the keys "+("["+inputKeys+"], but is missing the required keys: ["+missing+"]."))}if(extra.length>0&&strictInputCheck){throw new Error("The dict provided in model.execute(dict) has "+("unused keys: ["+extra+"]. Please provide only the following keys: ")+("["+this.inputNodes+"]."))}if(notInGraph.length>0){throw new Error("The dict provided in model.execute(dict) has "+("keys: ["+notInGraph+"] not part of model graph."))}};GraphExecutor.prototype.checkOutput=function(compiledNodes,outputs){var compiledNodeNames=compiledNodes.map(function(node){return node.name});var extra=[];outputs.forEach(function(name){if(compiledNodeNames.indexOf(name)===-1)extra.push(name)});if(extra.length>0){throw new Error("The following outputs are not be generated by the execution: "+("["+extra+"]."))}};return GraphExecutor}();exports.GraphExecutor=GraphExecutor},{"../operations/executors/utils":29,"../operations/operation_executor":45,"./execution_context":9,"@tensorflow/tfjs-core":55}],12:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfjs_core_1=require("@tensorflow/tfjs-core");var TensorArray=function(){function TensorArray(name,dtype,maxSize,elementShape,identicalElementShapes,dynamicSize,clearAfterRead){this.name=name;this.dtype=dtype;this.maxSize=maxSize;this.elementShape=elementShape;this.identicalElementShapes=identicalElementShapes;this.dynamicSize=dynamicSize;this.clearAfterRead=clearAfterRead;this.tensors=[];this.closed_=false;this.id=TensorArray.nextId++}Object.defineProperty(TensorArray.prototype,"closed",{get:function(){return this.closed_},enumerable:true,configurable:true});TensorArray.prototype.clearAndClose=function(){this.tensors.forEach(function(tensor){return tensor.tensor.dispose()});this.tensors=[];this.closed_=true};TensorArray.prototype.size=function(){return this.tensors.length};TensorArray.prototype.read=function(index){if(this.closed_){throw new Error("TensorArray "+this.name+" has already been closed.")}if(index<0||index>=this.tensors.length){throw new Error("Tried to read from index "+index+", but array size is: "+this.tensors.length)}var tensorWithState=this.tensors[index];if(tensorWithState.cleared){throw new Error("TensorArray "+this.name+": Could not read index "+index+" twice because it was cleared after a previous read "+"(perhaps try setting clear_after_read = false?).")}if(this.clearAfterRead){tensorWithState.cleared=true}tensorWithState.read=true;return tensorWithState.tensor};TensorArray.prototype.readMany=function(indices){var _this=this;return indices.map(function(index){return _this.read(index)})};TensorArray.prototype.write=function(index,tensor){if(this.closed_){throw new Error("TensorArray "+this.name+" has already been closed.")}if(index<0||!this.dynamicSize&&index>=this.maxSize){throw new Error("Tried to write to index "+index+", but array is not resizeable and size is: "+this.maxSize)}var t=this.tensors[index]||{};if(tensor.dtype!==this.dtype){throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+index+",\n          because the value dtype is "+tensor.dtype+", but TensorArray dtype is "+this.dtype+".")}if(this.size()===0&&this.elementShape.length===0){this.elementShape=tensor.shape}this.assertShapesMatch(this.elementShape,tensor.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+index+".");if(t&&t.read){throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+index+", because it has already been read.")}if(t&&t.written){throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+index+", because it has already been written.")}t.tensor=tensor;t.written=true;this.tensors[index]=t};TensorArray.prototype.writeMany=function(indices,tensors){var _this=this;if(indices.length!==tensors.length){throw new Error("TensorArray "+this.name+": could not write multiple tensors,"+("because the index size: "+indices.length+" is not the same as tensors size: "+tensors.length+"."))}indices.forEach(function(i,index){return _this.write(i,tensors[index])})};TensorArray.prototype.gather=function(indices,dtype){if(!!dtype&&dtype!==this.dtype){throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+dtype)}if(!indices){indices=[];for(var i=0;i<this.size();i++){indices.push(i)}}if(indices.length===0){return tfjs_core_1.tensor([],[0].concat(this.elementShape))}var tensors=this.readMany(indices);this.assertShapesMatch(this.elementShape,tensors[0].shape,"TensorArray shape mismatch: ");return tfjs_core_1.stack(tensors,0)};TensorArray.prototype.concat=function(dtype){if(!!dtype&&dtype!==this.dtype){throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+dtype)}if(this.size()===0){return tfjs_core_1.tensor([],[0].concat(this.elementShape))}var indices=[];for(var i=0;i<this.size();i++){indices.push(i)}var tensors=this.readMany(indices);this.assertShapesMatch(this.elementShape,tensors[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+tensors[0].shape+")");return tfjs_core_1.concat(tensors,0)};TensorArray.prototype.scatter=function(indices,tensor){if(tensor.dtype!==this.dtype){throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+tensor.dtype)}if(indices.length!==tensor.shape[0]){throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+indices.length+" vs. "+tensor.shape[0])}var maxIndex=Math.max.apply(Math,indices);if(!this.dynamicSize&&maxIndex>=this.maxSize){throw new Error("Max index must be < array size ("+maxIndex+"  vs. "+this.maxSize+")")}this.writeMany(indices,tfjs_core_1.unstack(tensor,0))};TensorArray.prototype.split=function(length,tensor){var _this=this;if(tensor.dtype!==this.dtype){throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+tensor.dtype)}var totalLength=0;var cumulativeLengths=length.map(function(len){totalLength+=len;return totalLength});if(totalLength!==tensor.shape[0]){throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+totalLength+", and tensor's shape is: "+tensor.shape)}if(!this.dynamicSize&&length.length!==this.maxSize){throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+length.length+"), "+"and the TensorArray is not marked as dynamically resizeable")}var elementPerRow=totalLength===0?0:tensor.size/totalLength;var tensors=[];tfjs_core_1.tidy(function(){tensor=tensor.reshape([1,totalLength,elementPerRow]);for(var i=0;i<length.length;++i){var previousLength=i===0?0:cumulativeLengths[i-1];var indices_1=[0,previousLength,0];var sizes=[1,length[i],elementPerRow];tensors[i]=tfjs_core_1.slice(tensor,indices_1,sizes).reshape(_this.elementShape)}return tensors});var indices=[];for(var i=0;i<length.length;i++){indices[i]=i}this.writeMany(indices,tensors)};TensorArray.prototype.assertShapesMatch=function(shapeA,shapeB,errorMessagePrefix){if(errorMessagePrefix===void 0){errorMessagePrefix=""}tfjs_core_1.util.assert(this.arraysEqual(shapeA,shapeB),errorMessagePrefix+(" Shapes "+shapeA+" and "+shapeB+" must match"))};TensorArray.prototype.arraysEqual=function(n1,n2){if(n1.length!==n2.length){return false}for(var i=0;i<n1.length;i++){if(n1[i]!==-1&&n2[i]!==-1&&n1[i]!==n2[i]){return false}}return true};TensorArray.nextId=0;return TensorArray}();exports.TensorArray=TensorArray},{"@tensorflow/tfjs-core":55}],13:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var frozen_model_1=require("./executor/frozen_model");exports.FrozenModel=frozen_model_1.FrozenModel;exports.loadFrozenModel=frozen_model_1.loadFrozenModel;var version_1=require("./version");exports.version_converter=version_1.version},{"./executor/frozen_model":10,"./version":47}],14:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"add":{return[tfc.add(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"addN":{return[tfc.addN(utils_1.getParamValue("tensors",node,tensorMap,context))]}case"mod":return[tfc.mod(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))];case"mul":return[tfc.mul(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))];case"div":{return[tfc.div(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"floorDiv":{return[tfc.floorDiv(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"sub":{return[tfc.sub(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"minimum":{return[tfc.minimum(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"maximum":{return[tfc.maximum(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"pow":{return[tfc.pow(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"squaredDifference":{return[tfc.squaredDifference(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="arithmetic"},{"./utils":29,"@tensorflow/tfjs-core":55}],15:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"abs":return[tfc.abs(utils_1.getParamValue("x",node,tensorMap,context))];case"acos":return[tfc.acos(utils_1.getParamValue("x",node,tensorMap,context))];case"acosh":return[tfc.acosh(utils_1.getParamValue("x",node,tensorMap,context))];case"asin":return[tfc.asin(utils_1.getParamValue("x",node,tensorMap,context))];case"asinh":return[tfc.asinh(utils_1.getParamValue("x",node,tensorMap,context))];case"atan":return[tfc.atan(utils_1.getParamValue("x",node,tensorMap,context))];case"atanh":return[tfc.atanh(utils_1.getParamValue("x",node,tensorMap,context))];case"ceil":return[tfc.ceil(utils_1.getParamValue("x",node,tensorMap,context))];case"cos":return[tfc.cos(utils_1.getParamValue("x",node,tensorMap,context))];case"cosh":return[tfc.cosh(utils_1.getParamValue("x",node,tensorMap,context))];case"elu":return[tfc.elu(utils_1.getParamValue("x",node,tensorMap,context))];case"erf":return[tfc.erf(utils_1.getParamValue("x",node,tensorMap,context))];case"exp":return[tfc.exp(utils_1.getParamValue("x",node,tensorMap,context))];case"expm1":{return[tfc.expm1(utils_1.getParamValue("x",node,tensorMap,context))]}case"floor":return[tfc.floor(utils_1.getParamValue("x",node,tensorMap,context))];case"log":return[tfc.log(utils_1.getParamValue("x",node,tensorMap,context))];case"log1p":{return[tfc.log1p(utils_1.getParamValue("x",node,tensorMap,context))]}case"neg":return[tfc.neg(utils_1.getParamValue("x",node,tensorMap,context))];case"reciprocal":{return[tfc.reciprocal(utils_1.getParamValue("x",node,tensorMap,context))]}case"relu":return[tfc.relu(utils_1.getParamValue("x",node,tensorMap,context))];case"round":{return[tfc.round(utils_1.getParamValue("x",node,tensorMap,context))]}case"selu":return[tfc.selu(utils_1.getParamValue("x",node,tensorMap,context))];case"sigmoid":return[tfc.sigmoid(utils_1.getParamValue("x",node,tensorMap,context))];case"sin":return[tfc.sin(utils_1.getParamValue("x",node,tensorMap,context))];case"sign":{return[tfc.sign(utils_1.getParamValue("x",node,tensorMap,context))]}case"sinh":{return[tfc.sinh(utils_1.getParamValue("x",node,tensorMap,context))]}case"softplus":{return[tfc.softplus(utils_1.getParamValue("x",node,tensorMap,context))]}case"sqrt":{return[tfc.sqrt(utils_1.getParamValue("x",node,tensorMap,context))]}case"square":{return[tfc.square(utils_1.getParamValue("x",node,tensorMap,context))]}case"tanh":{return[tfc.tanh(utils_1.getParamValue("x",node,tensorMap,context))]}case"tan":return[tfc.tan(utils_1.getParamValue("x",node,tensorMap,context))];case"clipByValue":return[tfc.clipByValue(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("clipValueMin",node,tensorMap,context),utils_1.getParamValue("clipValueMax",node,tensorMap,context))];case"rsqrt":return[tfc.div(tfc.scalar(1,"float32"),tfc.sqrt(utils_1.getTensor(node.inputNames[0],tensorMap,context)))];default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="basic_math"},{"./utils":29,"@tensorflow/tfjs-core":55}],16:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var tfjs_core_1=require("@tensorflow/tfjs-core");var tensor_array_1=require("../../executor/tensor_array");var utils_1=require("./utils");function executeOp(node,tensorMap,context){return __awaiter(this,void 0,void 0,function(){var _a,pred,data_1,inputName,frameId,data,tensor,input,size,dtype,elementShape,dynamicSize,clearAfterRead,identicalElementShapes,name_1,tensorArray,id,index,writeTensor,writeTensorArray,readId,readIndex,readTensorArray,gatherId,gatherIndices,gatherDtype,gatherTensorArray,scatterId,scatterIndices,scatterTensor,scatterTensorArray,concatId,concatTensorArray,concatDtype,splitId,splitTensor,lengths,splitTensorArray,sizeId,sizeTensorArray,closeId,closeTensorArray;return __generator(this,function(_b){switch(_b.label){case 0:_a=node.op;switch(_a){case"loopCond":return[3,1];case"switch":return[3,2];case"merge":return[3,4];case"enter":return[3,5];case"exit":return[3,6];case"nextIteration":return[3,7];case"tensorArray":return[3,8];case"tensorArrayWrite":return[3,9];case"tensorArrayRead":return[3,10];case"tensorArrayGather":return[3,11];case"tensorArrayScatter":return[3,12];case"tensorArrayConcat":return[3,13];case"tensorArraySplit":return[3,14];case"tensorArraySize":return[3,15];case"tensorArrayClose":return[3,16]}return[3,17];case 1:return[2,[utils_1.getParamValue("pred",node,tensorMap,context)]];case 2:pred=utils_1.getParamValue("pred",node,tensorMap,context);data_1=utils_1.getParamValue("data",node,tensorMap,context);return[4,pred.data()];case 3:return[2,_b.sent()[0]?[undefined,data_1]:[data_1,undefined]];case 4:inputName=node.inputNames.find(function(name){return utils_1.getTensor(name,tensorMap,context)!==undefined});return[2,inputName?[utils_1.getTensor(inputName,tensorMap,context)]:undefined];case 5:frameId=utils_1.getParamValue("frameName",node,tensorMap,context);data=utils_1.getParamValue("tensor",node,tensorMap,context);context.enterFrame(frameId);return[2,[data]];case 6:tensor=utils_1.getParamValue("tensor",node,tensorMap,context);context.exitFrame();return[2,[tensor]];case 7:input=utils_1.getParamValue("tensor",node,tensorMap,context);context.nextIteration();return[2,[input]];case 8:size=utils_1.getParamValue("size",node,tensorMap,context);dtype=utils_1.getParamValue("dtype",node,tensorMap,context);elementShape=utils_1.getParamValue("elementShape",node,tensorMap,context);dynamicSize=utils_1.getParamValue("dynamicSize",node,tensorMap,context);clearAfterRead=utils_1.getParamValue("clearAfterRead",node,tensorMap,context);identicalElementShapes=utils_1.getParamValue("identicalElementShapes",node,tensorMap,context);name_1=utils_1.getParamValue("name",node,tensorMap,context);tensorArray=new tensor_array_1.TensorArray(name_1,dtype,size,elementShape,identicalElementShapes,dynamicSize,clearAfterRead);context.addTensorArray(tensorArray);return[2,[tfjs_core_1.scalar(tensorArray.id),tfjs_core_1.scalar(1)]];case 9:id=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);index=utils_1.getParamValue("index",node,tensorMap,context);writeTensor=utils_1.getParamValue("tensor",node,tensorMap,context);writeTensorArray=context.getTensorArray(id);writeTensorArray.write(index,writeTensor);return[2,[tfjs_core_1.scalar(1)]];case 10:readId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);readIndex=utils_1.getParamValue("index",node,tensorMap,context);readTensorArray=context.getTensorArray(readId);return[2,[readTensorArray.read(readIndex)]];case 11:gatherId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);gatherIndices=utils_1.getParamValue("indices",node,tensorMap,context);gatherDtype=utils_1.getParamValue("dtype",node,tensorMap,context);gatherTensorArray=context.getTensorArray(gatherId);return[2,[gatherTensorArray.gather(gatherIndices,gatherDtype)]];case 12:scatterId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);scatterIndices=utils_1.getParamValue("indices",node,tensorMap,context);scatterTensor=utils_1.getParamValue("tensor",node,tensorMap,context);scatterTensorArray=context.getTensorArray(scatterId);scatterTensorArray.scatter(scatterIndices,scatterTensor);return[2,[tfjs_core_1.scalar(1)]];case 13:concatId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);concatTensorArray=context.getTensorArray(concatId);concatDtype=utils_1.getParamValue("dtype",node,tensorMap,context);return[2,[concatTensorArray.concat(concatDtype)]];case 14:splitId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);splitTensor=utils_1.getParamValue("tensor",node,tensorMap,context);lengths=utils_1.getParamValue("lengths",node,tensorMap,context);splitTensorArray=context.getTensorArray(splitId);splitTensorArray.split(lengths,splitTensor);return[2,[tfjs_core_1.scalar(1)]];case 15:sizeId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);sizeTensorArray=context.getTensorArray(sizeId);return[2,[tfjs_core_1.scalar(sizeTensorArray.size(),"int32")]];case 16:closeId=utils_1.getParamValue("tensorArrayId",node,tensorMap,context);closeTensorArray=context.getTensorArray(closeId);closeTensorArray.clearAndClose();return[2,[]];case 17:throw TypeError("Node type "+node.op+" is not implemented")}})})}exports.executeOp=executeOp;exports.CATEGORY="control"},{"../../executor/tensor_array":12,"./utils":29,"@tensorflow/tfjs-core":55}],17:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"conv1d":{var stride=utils_1.getParamValue("stride",node,tensorMap,context);var pad=utils_1.getParamValue("pad",node,tensorMap,context);var dataFormat=utils_1.getParamValue("dataFormat",node,tensorMap,context).toUpperCase();var dilation=utils_1.getParamValue("dilation",node,tensorMap,context);return[tfc.conv1d(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("filter",node,tensorMap,context),stride,pad,dataFormat,dilation)]}case"conv2d":{var stride=utils_1.getParamValue("strides",node,tensorMap,context);var pad=utils_1.getParamValue("pad",node,tensorMap,context);var dataFormat=utils_1.getParamValue("dataFormat",node,tensorMap,context).toUpperCase();var dilations=utils_1.getParamValue("dilations",node,tensorMap,context);return[tfc.conv2d(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("filter",node,tensorMap,context),[stride[1],stride[2]],pad,dataFormat,[dilations[0],dilations[1]])]}case"conv2dTranspose":{var shape=utils_1.getParamValue("outputShape",node,tensorMap,context);var stride=utils_1.getParamValue("strides",node,tensorMap,context);var pad=utils_1.getParamValue("pad",node,tensorMap,context);return[tfc.conv2dTranspose(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("filter",node,tensorMap,context),shape,[stride[1],stride[2]],pad)]}case"depthwiseConv2d":{var stride=utils_1.getParamValue("strides",node,tensorMap,context);var pad=utils_1.getParamValue("pad",node,tensorMap,context);var dilations=utils_1.getParamValue("dilations",node,tensorMap,context);var dataFormat=utils_1.getParamValue("dataFormat",node,tensorMap,context).toUpperCase();return[tfc.depthwiseConv2d(utils_1.getParamValue("input",node,tensorMap,context),utils_1.getParamValue("filter",node,tensorMap,context),[stride[1],stride[2]],pad,dataFormat,[dilations[0],dilations[1]])]}case"avgPool":{var stride=utils_1.getParamValue("strides",node,tensorMap,context);var pad=utils_1.getParamValue("pad",node,tensorMap,context);var kernelSize=utils_1.getParamValue("kernelSize",node,tensorMap,context);return[tfc.avgPool(utils_1.getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2]],[stride[1],stride[2]],pad)]}case"maxPool":{var stride=utils_1.getParamValue("strides",node,tensorMap,context);var pad=utils_1.getParamValue("pad",node,tensorMap,context);var kernelSize=utils_1.getParamValue("kernelSize",node,tensorMap,context);return[tfc.maxPool(utils_1.getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2]],[stride[1],stride[2]],pad)]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="convolution"},{"./utils":29,"@tensorflow/tfjs-core":55}],18:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"fill":{var shape=utils_1.getParamValue("shape",node,tensorMap,context);var dtype=utils_1.getParamValue("dtype",node,tensorMap,context);var value=utils_1.getParamValue("value",node,tensorMap,context);return[tfc.fill(shape,value,dtype)]}case"linspace":{var start=utils_1.getParamValue("start",node,tensorMap,context);var stop_1=utils_1.getParamValue("stop",node,tensorMap,context);var num=utils_1.getParamValue("num",node,tensorMap,context);return[tfc.linspace(start,stop_1,num)]}case"oneHot":{var indices=utils_1.getParamValue("indices",node,tensorMap,context);var depth=utils_1.getParamValue("depth",node,tensorMap,context);var onValue=utils_1.getParamValue("onValue",node,tensorMap,context);var offValue=utils_1.getParamValue("offValue",node,tensorMap,context);return[tfc.oneHot(indices,depth,onValue,offValue)]}case"ones":{return[tfc.ones(utils_1.getParamValue("shape",node,tensorMap,context),utils_1.getParamValue("dtype",node,tensorMap,context))]}case"onesLike":{return[tfc.onesLike(utils_1.getParamValue("x",node,tensorMap,context))]}case"randomUniform":{return[tfc.randomUniform(utils_1.getParamValue("shape",node,tensorMap,context),utils_1.getParamValue("minval",node,tensorMap,context),utils_1.getParamValue("maxval",node,tensorMap,context),utils_1.getParamValue("dtype",node,tensorMap,context))]}case"range":{var start=utils_1.getParamValue("start",node,tensorMap,context);var stop_2=utils_1.getParamValue("stop",node,tensorMap,context);var step=utils_1.getParamValue("step",node,tensorMap,context);return[tfc.range(start,stop_2,step,utils_1.getParamValue("dtype",node,tensorMap,context))]}case"truncatedNormal":{var shape=utils_1.getParamValue("shape",node,tensorMap,context);var mean=utils_1.getParamValue("mean",node,tensorMap,context);var stdDev=utils_1.getParamValue("stdDev",node,tensorMap,context);var seed=utils_1.getParamValue("seed",node,tensorMap,context);return[tfc.truncatedNormal(shape,mean,stdDev,utils_1.getParamValue("dtype",node,tensorMap,context),seed)]}case"zeros":{return[tfc.zeros(utils_1.getParamValue("shape",node,tensorMap,context),utils_1.getParamValue("dtype",node,tensorMap,context))]}case"zerosLike":{return[tfc.zerosLike(utils_1.getParamValue("x",node,tensorMap,context))]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="creation"},{"./utils":29,"@tensorflow/tfjs-core":55}],19:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");function executeOp(node,tensorMap,context){return __awaiter(this,void 0,void 0,function(){var _a,boxes,scores,maxOutputSize,iouThreshold,scoreThreshold;return __generator(this,function(_b){switch(_b.label){case 0:_a=node.op;switch(_a){case"nonMaxSuppression":return[3,1];case"whereAsync":return[3,3]}return[3,5];case 1:boxes=utils_1.getParamValue("boxes",node,tensorMap,context);scores=utils_1.getParamValue("scores",node,tensorMap,context);maxOutputSize=utils_1.getParamValue("maxOutputSize",node,tensorMap,context);iouThreshold=utils_1.getParamValue("iouThreshold",node,tensorMap,context);scoreThreshold=utils_1.getParamValue("scoreThreshold",node,tensorMap,context);return[4,tfc.image.nonMaxSuppressionAsync(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold)];case 2:return[2,[_b.sent()]];case 3:return[4,tfc.whereAsync(utils_1.getParamValue("condition",node,tensorMap,context))];case 4:return[2,[_b.sent()]];case 5:throw TypeError("Node type "+node.op+" is not implemented")}})})}exports.executeOp=executeOp;exports.CATEGORY="dynamic"},{"./utils":29,"@tensorflow/tfjs-core":55}],20:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"topK":{var x=utils_1.getParamValue("x",node,tensorMap,context);var k=utils_1.getParamValue("k",node,tensorMap,context);var sorted=utils_1.getParamValue("sorted",node,tensorMap,context);var result=tfc.topk(x,k,sorted);return[result.values,result.indices]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="evaluation"},{"./utils":29,"@tensorflow/tfjs-core":55}],21:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"const":{return tensorMap[node.name]}case"placeholder":var def=utils_1.getParamValue("default",node,tensorMap,context);return[utils_1.getTensor(node.name,tensorMap,context)||def];case"identity":case"stopGradient":case"fakeQuantWithMinMaxVars":return[utils_1.getParamValue("x",node,tensorMap,context)];case"snapshot":var snapshot=utils_1.getParamValue("x",node,tensorMap,context);return[snapshot.clone()];case"shape":return[tfc.tensor1d(utils_1.getParamValue("x",node,tensorMap,context).shape,"int32")];case"shapeN":return utils_1.getParamValue("x",node,tensorMap,context).map(function(t){return tfc.tensor1d(t.shape)});case"size":return[tfc.scalar(utils_1.getParamValue("x",node,tensorMap,context).size,"int32")];case"rank":return[tfc.scalar(utils_1.getParamValue("x",node,tensorMap,context).rank,"int32")];case"noop":return[];case"print":var input=utils_1.getParamValue("x",node,tensorMap,context);var data=utils_1.getParamValue("data",node,tensorMap,context);var message=utils_1.getParamValue("message",node,tensorMap,context);var summarize=utils_1.getParamValue("summarize",node,tensorMap,context);console.warn("The graph has a tf.print() operation,"+"usually used for debugging, which slows down performance.");console.log(message);for(var i=0;i<data.length;i++){console.log(Array.prototype.slice.call(data[0].dataSync()).slice(0,summarize))}return[input];default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="graph"},{"./utils":29,"@tensorflow/tfjs-core":55}],22:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"resizeBilinear":{var images=utils_1.getParamValue("images",node,tensorMap,context);var size=utils_1.getParamValue("size",node,tensorMap,context);var alignCorners=utils_1.getParamValue("alignCorners",node,tensorMap,context);return[tfc.image.resizeBilinear(images,[size[0],size[1]],alignCorners)]}case"resizeNearestNeighbor":{var images=utils_1.getParamValue("images",node,tensorMap,context);var size=utils_1.getParamValue("size",node,tensorMap,context);var alignCorners=utils_1.getParamValue("alignCorners",node,tensorMap,context);return[tfc.image.resizeNearestNeighbor(images,[size[0],size[1]],alignCorners)]}case"cropAndResize":{var image=utils_1.getParamValue("image",node,tensorMap,context);var boxes=utils_1.getParamValue("boxes",node,tensorMap,context);var boxInd=utils_1.getParamValue("boxInd",node,tensorMap,context);var cropSize=utils_1.getParamValue("cropSize",node,tensorMap,context);var method=utils_1.getParamValue("method",node,tensorMap,context);var extrapolationValue=utils_1.getParamValue("extrapolationValue",node,tensorMap,context);return[tfc.image.cropAndResize(image,boxes,boxInd,cropSize,method,extrapolationValue)]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="image"},{"./utils":29,"@tensorflow/tfjs-core":55}],23:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"equal":{return[tfc.equal(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"notEqual":{return[tfc.notEqual(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"greater":{return[tfc.greater(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"greaterEqual":{return[tfc.greaterEqual(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"less":{return[tfc.less(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"lessEqual":{return[tfc.lessEqual(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"logicalAnd":{return[tfc.logicalAnd(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"logicalNot":{return[tfc.logicalNot(utils_1.getParamValue("a",node,tensorMap,context))]}case"logicalOr":{return[tfc.logicalOr(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}case"where":{return[tfc.where(utils_1.getParamValue("condition",node,tensorMap,context),utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context))]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="logical"},{"./utils":29,"@tensorflow/tfjs-core":55}],24:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"matMul":return[tfc.matMul(utils_1.getParamValue("a",node,tensorMap,context),utils_1.getParamValue("b",node,tensorMap,context),utils_1.getParamValue("transposeA",node,tensorMap,context),utils_1.getParamValue("transposeB",node,tensorMap,context))];case"transpose":return[tfc.transpose(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("perm",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="matrices"},{"./utils":29,"@tensorflow/tfjs-core":55}],25:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"batchNormalization":{return[tfc.batchNormalization(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("mean",node,tensorMap,context),utils_1.getParamValue("variance",node,tensorMap,context),utils_1.getParamValue("epsilon",node,tensorMap,context),utils_1.getParamValue("scale",node,tensorMap,context),utils_1.getParamValue("offset",node,tensorMap,context))]}case"localResponseNormalization":{return[tfc.localResponseNormalization(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("radius",node,tensorMap,context),utils_1.getParamValue("bias",node,tensorMap,context),utils_1.getParamValue("alpha",node,tensorMap,context),utils_1.getParamValue("beta",node,tensorMap,context))]}case"softmax":{return[tfc.softmax(utils_1.getParamValue("x",node,tensorMap,context))]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="normalization"},{"./utils":29,"@tensorflow/tfjs-core":55}],26:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"max":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var keepDims=utils_1.getParamValue("keepDims",node,tensorMap,context);return[tfc.max(utils_1.getParamValue("x",node,tensorMap,context),axis,keepDims)]}case"mean":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var keepDims=utils_1.getParamValue("keepDims",node,tensorMap,context);return[tfc.mean(utils_1.getParamValue("x",node,tensorMap,context),axis,keepDims)]}case"min":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var keepDims=utils_1.getParamValue("keepDims",node,tensorMap,context);return[tfc.min(utils_1.getParamValue("x",node,tensorMap,context),axis,keepDims)]}case"sum":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var keepDims=utils_1.getParamValue("keepDims",node,tensorMap,context);return[tfc.sum(utils_1.getParamValue("x",node,tensorMap,context),axis,keepDims)]}case"all":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var keepDims=utils_1.getParamValue("keepDims",node,tensorMap,context);return[tfc.all(utils_1.getParamValue("x",node,tensorMap,context),axis,keepDims)]}case"any":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var keepDims=utils_1.getParamValue("keepDims",node,tensorMap,context);return[tfc.any(utils_1.getParamValue("x",node,tensorMap,context),axis,keepDims)]}case"argMax":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);return[tfc.argMax(utils_1.getParamValue("x",node,tensorMap,context),axis)]}case"argMin":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);return[tfc.argMin(utils_1.getParamValue("x",node,tensorMap,context),axis)]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="reduction"},{"./utils":29,"@tensorflow/tfjs-core":55}],27:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"concat":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var inputs=utils_1.getParamValue("tensors",node,tensorMap,context);return[tfc.concat(inputs,axis)]}case"gather":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var input=utils_1.getParamValue("x",node,tensorMap,context);var indices=utils_1.getParamValue("indices",node,tensorMap,context);return[tfc.gather(input,indices,axis)]}case"reverse":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var input=utils_1.getParamValue("x",node,tensorMap,context);return[tfc.reverse(input,axis)]}case"slice":{var begin=utils_1.getParamValue("begin",node,tensorMap,context);var size=utils_1.getParamValue("size",node,tensorMap,context);return[tfc.slice(utils_1.getParamValue("x",node,tensorMap,context),begin,size)]}case"stridedSlice":{var begin=utils_1.getParamValue("begin",node,tensorMap,context);var end=utils_1.getParamValue("end",node,tensorMap,context);var strides=utils_1.getParamValue("strides",node,tensorMap,context);var beginMask=utils_1.getParamValue("beginMask",node,tensorMap,context);var endMask=utils_1.getParamValue("endMask",node,tensorMap,context);var ellipsisMask=utils_1.getParamValue("ellipsisMask",node,tensorMap,context);var newAxisMask=utils_1.getParamValue("newAxisMask",node,tensorMap,context);var shrinkAxisMask=utils_1.getParamValue("shrinkAxisMask",node,tensorMap,context);var tensor=utils_1.getParamValue("x",node,tensorMap,context);if(begin.length===1&&tensor.shape.length>1){for(var i=1;i<tensor.shape.length;i++){begin.push(0);end.push(tensor.shape[i]);strides.push(strides[0])}}return[tfc.stridedSlice(tensor,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask)]}case"stack":{return tfc.tidy(function(){var axis=utils_1.getParamValue("axis",node,tensorMap,context);var tensors=utils_1.getParamValue("tensors",node,tensorMap,context);var shape=tensors[0].shape;var squeezedShape=tensors[0].squeeze().shape;var mapped=tensors.map(function(tensor){var sameShape=tfc.util.arraysEqual(tensor.shape,shape);if(!sameShape&&!tfc.util.arraysEqual(tensor.squeeze().shape,squeezedShape)){throw new Error("the input tensors shape does not match")}return sameShape?tensor:tensor.reshape(shape)});return[tfc.stack(mapped,axis)]})}case"unstack":{return tfc.tidy(function(){var axis=utils_1.getParamValue("axis",node,tensorMap,context);var tensor=utils_1.getParamValue("tensor",node,tensorMap,context);return tfc.unstack(tensor,axis)})}case"tile":{var reps=utils_1.getParamValue("reps",node,tensorMap,context);return[tfc.tile(utils_1.getParamValue("x",node,tensorMap,context),reps)]}case"split":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);var numOrSizeSplits=utils_1.getParamValue("numOrSizeSplits",node,tensorMap,context);return tfc.split(utils_1.getParamValue("x",node,tensorMap,context),numOrSizeSplits,axis)}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="slice_join"},{"./utils":29,"@tensorflow/tfjs-core":55}],28:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tfc=require("@tensorflow/tfjs-core");var utils_1=require("./utils");exports.executeOp=function(node,tensorMap,context){switch(node.op){case"cast":{return[tfc.cast(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("dtype",node,tensorMap,context))]}case"expandDims":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);return[tfc.expandDims(utils_1.getParamValue("x",node,tensorMap,context),axis)]}case"squeeze":{var axis=utils_1.getParamValue("axis",node,tensorMap,context);return[tfc.squeeze(utils_1.getParamValue("x",node,tensorMap,context),axis)]}case"reshape":{return[tfc.reshape(utils_1.getParamValue("x",node,tensorMap,context),utils_1.getParamValue("shape",node,tensorMap,context))]}case"pad":{return[tfc.pad(utils_1.getParamValue("x",node,tensorMap,context),utils_1.split(utils_1.getParamValue("padding",node,tensorMap,context),2),utils_1.getParamValue("constantValue",node,tensorMap,context))]}case"spaceToBatchND":{var blockShape=utils_1.getParamValue("blockShape",node,tensorMap,context);var paddings=utils_1.split(utils_1.getParamValue("paddings",node,tensorMap,context),2);return[tfc.spaceToBatchND(utils_1.getParamValue("x",node,tensorMap,context),blockShape,paddings)]}case"batchToSpaceND":{var blockShape=utils_1.getParamValue("blockShape",node,tensorMap,context);var crops=utils_1.split(utils_1.getParamValue("crops",node,tensorMap,context),2);return[tfc.batchToSpaceND(utils_1.getParamValue("x",node,tensorMap,context),blockShape,crops)]}default:throw TypeError("Node type "+node.op+" is not implemented")}};exports.CATEGORY="transformation"},{"./utils":29,"@tensorflow/tfjs-core":55}],29:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function getParamValue(paramName,node,tensorMap,context){var param=node.params[paramName];if(param&&param.inputIndex!==undefined){if(param.type==="tensor"){return getTensor(node.inputNames[param.inputIndex],tensorMap,context)}if(param.type==="tensors"){var inputs=param.inputIndex===0?param.inputParamLength===0?node.inputNames:node.inputNames.slice(param.inputIndex,-param.inputParamLength):node.inputNames.splice(param.inputIndex);return inputs.map(function(name){return getTensor(name,tensorMap,context)})}var data=Array.prototype.slice.call(getTensor(node.inputNames.slice(param.inputIndex)[0],tensorMap,context).dataSync());return param.type==="number"?data[0]:data}return param&&param.value}exports.getParamValue=getParamValue;function getTensor(name,tensorsMap,context){var _a=parseNodeName(name),nodeName=_a[0],index=_a[1];var contextId=context.currentContextIds.find(function(contextId){return!!tensorsMap[getNodeNameWithContextId(nodeName,contextId)]});return contextId!==undefined?tensorsMap[getNodeNameWithContextId(nodeName,contextId)][index]:undefined}exports.getTensor=getTensor;function getNodeNameAndIndex(inputName,context){var _a=parseNodeName(inputName),nodeName=_a[0],index=_a[1];return[getNodeNameWithContextId(nodeName,context&&context.currentContextId),index]}exports.getNodeNameAndIndex=getNodeNameAndIndex;function getNodeNameWithContextId(name,contextId){return!!contextId?name+"-"+contextId:name}function parseNodeName(name){var index=name.lastIndexOf(":");if(index===-1)return[name,0];var nodeName=name.substring(0,index);return[nodeName,Number(name.substring(index+1))]}exports.parseNodeName=parseNodeName;function split(arr,size){var res=[];for(var i=0;i<arr.length;i+=size){res.push(arr.slice(i,i+size))}return res}exports.split=split},{}],30:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"Add",dlOpName:"add",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddN",dlOpName:"addN",category:"arithmetic",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",dlOpName:"add",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sub",dlOpName:"sub",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"RealDiv",dlOpName:"div",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Div",dlOpName:"div",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorDiv",dlOpName:"floorDiv",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mul",dlOpName:"mul",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Maximum",dlOpName:"maximum",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"}]},{tfOpName:"Minimum",dlOpName:"minimum",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"}]},{tfOpName:"Pow",dlOpName:"pow",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SquaredDifference",dlOpName:"squaredDifference",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mod",dlOpName:"mod",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorMod",dlOpName:"mod",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]}]},{}],31:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"Abs",dlOpName:"abs",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acos",dlOpName:"acos",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asin",dlOpName:"asin",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"atan",dlOpName:"atan",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ceil",dlOpName:"ceil",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ClipByValue",dlOpName:"clipByValue",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"clip_value_min",dlParamName:"clipValueMin",type:"number"},{tfParamName:"clip_value_max",dlParamName:"clipValueMax",type:"number"}]},{tfOpName:"Cos",dlOpName:"cos",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cosh",dlOpName:"cosh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Elu",dlOpName:"elu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Exp",dlOpName:"exp",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Floor",dlOpName:"floor",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log",dlOpName:"log",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Neg",dlOpName:"neg",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu",dlOpName:"relu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu6",dlOpName:"clipByValue",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true},{dlParamName:"clipValueMin",type:"number",defaultValue:0},{dlParamName:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",dlOpName:"selu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sigmoid",dlOpName:"sigmoid",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sin",dlOpName:"sin",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sinh",dlOpName:"sinh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sqrt",dlOpName:"sqrt",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Rsqrt",dlOpName:"rsqrt",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Square",dlOpName:"square",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tan",dlOpName:"tan",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tanh",dlOpName:"tanh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sign",dlOpName:"sign",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Round",dlOpName:"round",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Expm1",dlOpName:"expm1",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log1p",dlOpName:"log1p",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Reciprocal",dlOpName:"reciprocal",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Reciprocal",dlOpName:"reciprocal",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Softplus",dlOpName:"softplus",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asinh",dlOpName:"asinh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acosh",dlOpName:"acosh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atanh",dlOpName:"atanh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Erf",dlOpName:"erf",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]}]},{}],32:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"LoopCond",dlOpName:"loopCond",category:"control",params:[{tfInputIndex:0,dlParamName:"pred",type:"tensor"}]},{tfOpName:"Switch",dlOpName:"switch",category:"control",params:[{tfInputIndex:0,dlParamName:"data",type:"tensor"},{tfInputIndex:1,dlParamName:"pred",type:"tensor"}]},{tfOpName:"Merge",dlOpName:"merge",category:"control",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"}]},{tfOpName:"Enter",dlOpName:"enter",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true},{tfParamName:"frame_name",dlParamName:"frameName",type:"string"},{tfParamName:"is_constant",dlParamName:"isConstant",type:"bool"}]},{tfOpName:"Exit",dlOpName:"exit",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NextIteration",dlOpName:"nextIteration",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayV3",dlOpName:"tensorArray",category:"control",params:[{tfInputIndex:0,dlParamName:"size",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape",dlParamName:"elementShape",type:"shape"},{tfParamName:"dynamic_size",dlParamName:"dynamicSize",type:"bool"},{tfParamName:"clear_after_read",dlParamName:"clearAfterRead",type:"bool"},{tfParamName:"identical_element_shapes",dlParamName:"identicalElementShapes",type:"bool"},{tfParamName:"tensor_array_name",dlParamName:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",dlOpName:"tensorArrayWrite",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"index",type:"number"},{tfInputIndex:2,dlParamName:"tensor",type:"tensor"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayReadV3",dlOpName:"tensorArrayRead",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"index",type:"number"},{tfInputIndex:2,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayGatherV3",dlOpName:"tensorArrayGather",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"indices",type:"number[]"},{tfInputIndex:2,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape",dlParamName:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",dlOpName:"tensorArrayScatter",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"indices",type:"number[]"},{tfInputIndex:2,dlParamName:"tensor",type:"tensor"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",dlOpName:"tensorArrayConcat",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape_except0",dlParamName:"elementShapeExcept0",type:"shape",notSupported:true}]},{tfOpName:"TensorArraySplitV3",dlOpName:"tensorArraySplit",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"tensor",type:"tensor"},{tfInputIndex:2,dlParamName:"lengths",type:"number[]"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",dlOpName:"tensorArraySize",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",dlOpName:"tensorArrayClose",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"}]}]},{}],33:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"AvgPool",dlOpName:"avgPool",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:true},{tfParamName:"ksize",dlParamName:"kernelSize",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool",dlOpName:"maxPool",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:true},{tfParamName:"ksize",dlParamName:"kernelSize",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Conv1D",dlOpName:"conv1d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"stride",dlParamName:"stride",type:"number"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NWC"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true},{tfParamName:"dilation",dlParamName:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",dlOpName:"conv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"useCudnnOnGpu",dlParamName:"useCudnnOnGpu",type:"bool"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]},{tfOpName:"Conv2DBackpropInput",dlOpName:"conv2dTranspose",category:"convolution",params:[{tfInputIndex:2,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfInputIndex:0,dlParamName:"outputShape",type:"number[]"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"DepthwiseConv2d",dlOpName:"depthwiseConv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"input",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",dlOpName:"depthwiseConv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"input",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]}]},{}],34:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"Fill",dlOpName:"fill",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfInputIndex:1,dlParamName:"value",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",dlOpName:"linspace",category:"creation",params:[{tfInputIndex:0,dlParamName:"start",type:"number"},{tfInputIndex:1,dlParamName:"stop",type:"number"},{tfInputIndex:2,dlParamName:"num",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"OneHot",dlOpName:"oneHot",category:"creation",params:[{tfInputIndex:0,dlParamName:"indices",type:"tensor"},{tfInputIndex:1,dlParamName:"depth",type:"number"},{tfInputIndex:2,dlParamName:"onValue",type:"number",defaultValue:1},{tfInputIndex:3,dlParamName:"offValue",type:"number",defaultValue:0},{tfParamName:"axis",dlParamName:"axis",type:"number",notSupported:true},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ones",dlOpName:"ones",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",dlOpName:"onesLike",category:"creation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",dlOpName:"randomUniform",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"minval",dlParamName:"minval",type:"number",defaultValue:0},{tfParamName:"maxval",dlParamName:"maxval",type:"number",defaultValue:1},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"seed",dlParamName:"seed",type:"number",defaultValue:0},{tfParamName:"seed2",dlParamName:"seed2",type:"number",defaultValue:0,notSupported:true},{tfParamName:"T",dlParamName:"T",type:"number",notSupported:true}]},{tfOpName:"Range",dlOpName:"range",category:"creation",params:[{tfInputIndex:0,dlParamName:"start",type:"number"},{tfInputIndex:1,dlParamName:"stop",type:"number"},{tfInputIndex:2,dlParamName:"step",type:"number",defaultValue:0},{tfParamName:"Tidx",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"truncatedNormal",dlOpName:"truncatedNormal",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"means",dlParamName:"mean",type:"number",defaultValue:0},{tfParamName:"stddev",dlParamName:"stdDev",type:"number",defaultValue:1},{tfParamName:"seed",dlParamName:"seed",type:"number"},{tfParamName:"seed2",dlParamName:"seed2",type:"number",defaultValue:0,notSupported:true},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"T",dlParamName:"T",type:"number",notSupported:true}]},{tfOpName:"Zeros",dlOpName:"zeros",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",dlOpName:"zerosLike",category:"creation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]}]},{}],35:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"NonMaxSuppressionV2",dlOpName:"nonMaxSuppression",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"boxes",type:"tensor"},{tfInputIndex:1,dlParamName:"scores",type:"tensor"},{tfInputIndex:2,dlParamName:"maxOutputSize",type:"number"},{tfInputIndex:3,dlParamName:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",dlOpName:"nonMaxSuppression",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"boxes",type:"tensor"},{tfInputIndex:1,dlParamName:"scores",type:"tensor"},{tfInputIndex:2,dlParamName:"maxOutputSize",type:"number"},{tfInputIndex:3,dlParamName:"iouThreshold",type:"number"},{tfInputIndex:4,dlParamName:"scoreThreshold",type:"number"}]},{tfOpName:"Where",dlOpName:"whereAsync",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"condition",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]}]},{}],36:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"TopKV2",dlOpName:"topK",category:"evaluation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"k",type:"number"},{tfParamName:"sorted",dlParamName:"sorted",type:"bool"}]}]},{}],37:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"PlaceholderWithDefault",dlOpName:"placeholder",category:"graph",params:[{tfInputIndex:0,dlParamName:"default",type:"tensor"},{tfParamName:"shape",dlParamName:"shape",type:"shape"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",dlOpName:"placeholder",category:"graph",params:[{tfParamName:"shape",dlParamName:"shape",type:"shape"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"Const",dlOpName:"const",category:"graph"},{tfOpName:"Identity",dlOpName:"identity",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Snapshot",dlOpName:"snapshot",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Rank",dlOpName:"rank",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Size",dlOpName:"size",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Shape",dlOpName:"shape",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"ShapeN",dlOpName:"shapeN",category:"graph",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"x",type:"tensors"}]},{tfOpName:"Print",dlOpName:"print",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,tfInputParamLength:1,dlParamName:"data",type:"tensors"},{tfParamName:"message",dlParamName:"message",type:"string"},{tfParamName:"first_n",dlParamName:"firstN",type:"number",notSupprted:true},{tfParamName:"summarize",dlParamName:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",dlOpName:"noop",category:"graph",params:[]},{tfOpName:"StopGradient",dlOpName:"stopGradient",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",dlOpName:"fakeQuantWithMinMaxVars",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"min",dlParamName:"min",type:"number"},{tfParamName:"max",dlParamName:"max",type:"number"}]}]},{}],38:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"ResizeBilinear",dlOpName:"resizeBilinear",category:"image",params:[{tfInputIndex:0,dlParamName:"images",type:"tensor"},{tfInputIndex:1,dlParamName:"size",type:"number[]"},{tfParamName:"align_corners",dlParamName:"alignCorners",type:"bool"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ResizeNearestNeighbor",dlOpName:"resizeNearestNeighbor",category:"image",params:[{tfInputIndex:0,dlParamName:"images",type:"tensor"},{tfInputIndex:1,dlParamName:"size",type:"number[]"},{tfParamName:"align_corners",dlParamName:"alignCorners",type:"bool"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"CropAndResize",dlOpName:"cropAndResize",category:"image",params:[{tfInputIndex:0,dlParamName:"image",type:"tensor"},{tfInputIndex:1,dlParamName:"boxes",type:"tensor"},{tfInputIndex:2,dlParamName:"boxInd",type:"tensor"},{tfInputIndex:3,dlParamName:"cropSize",type:"number[]"},{tfParamName:"method",dlParamName:"method",type:"string"},{tfParamName:"extrapolation_value",dlParamName:"extrapolationValue",type:"number"}]}]},{}],39:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"Equal",dlOpName:"equal",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NotEqual",dlOpName:"notEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Greater",dlOpName:"greater",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"GreaterEqual",dlOpName:"greaterEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Less",dlOpName:"less",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LessEqual",dlOpName:"lessEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalAnd",dlOpName:"logicalAnd",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalNot",dlOpName:"logicalNot",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalOr",dlOpName:"logicalOr",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Select",dlOpName:"where",category:"logical",params:[{tfInputIndex:0,dlParamName:"condition",type:"tensor"},{tfInputIndex:1,dlParamName:"a",type:"tensor"},{tfInputIndex:2,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]}]},{}],40:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"MatMul",dlOpName:"matMul",category:"matrices",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"transpose_a",dlParamName:"transposeA",type:"bool",defaultValue:false},{tfParamName:"transpose_b",dlParamName:"transposeB",type:"bool",defaultValue:false},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMul",dlOpName:"matMul",category:"matrices",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"adj_x",dlParamName:"transposeA",type:"bool",defaultValue:false},{tfParamName:"adj_y",dlParamName:"transposeB",type:"bool",defaultValue:false},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Transpose",dlOpName:"transpose",category:"matrices",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"perm",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:true}]}]},{}],41:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"FusedBatchNorm",dlOpName:"batchNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"scale",type:"tensor"},{tfInputIndex:2,dlParamName:"offset",type:"tensor"},{tfInputIndex:3,dlParamName:"mean",type:"tensor"},{tfInputIndex:4,dlParamName:"variance",type:"tensor"},{tfParamName:"epsilon",dlParamName:"epsilon",type:"number",defaultValue:.001},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV2",dlOpName:"batchNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"scale",type:"tensor"},{tfInputIndex:2,dlParamName:"offset",type:"tensor"},{tfInputIndex:3,dlParamName:"mean",type:"tensor"},{tfInputIndex:4,dlParamName:"variance",type:"tensor"},{tfParamName:"epsilon",dlParamName:"epsilon",type:"number",defaultValue:.001},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"LRN",dlOpName:"localResponseNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"depth_radius",dlParamName:"radius",type:"number",defaultValue:5},{tfParamName:"bias",dlParamName:"bias",type:"number",defaultValue:1},{tfParamName:"alpha",dlParamName:"alpha",type:"number",defaultValue:1},{tfParamName:"beta",dlParamName:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",dlOpName:"softmax",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]}]},{}],42:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"Max",dlOpName:"max",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Mean",dlOpName:"mean",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Min",dlOpName:"min",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Sum",dlOpName:"sum",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"All",dlOpName:"all",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Any",dlOpName:"any",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",dlOpName:"argMax",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"ArgMin",dlOpName:"argMin",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]}]},{}],43:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"ConcatV2",dlOpName:"concat",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:1,dlParamName:"tensors",type:"tensors"},{tfInputIndex:-1,dlParamName:"axis",type:"number"}]},{tfOpName:"Concat",dlOpName:"concat",category:"slice_join",params:[{tfInputIndex:1,tfInputParamLength:1,dlParamName:"tensors",type:"tensors"},{tfInputIndex:0,dlParamName:"axis",type:"number"}]},{tfOpName:"GatherV2",dlOpName:"gather",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",dlOpName:"gather",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",notSupported:true}]},{tfOpName:"Reverse",dlOpName:"reverse",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"ReverseV2",dlOpName:"reverse",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"Slice",dlOpName:"slice",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"begin",type:"number[]"},{tfInputIndex:2,dlParamName:"size",type:"number[]"}]},{tfOpName:"StridedSlice",dlOpName:"stridedSlice",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"begin",type:"number[]"},{tfInputIndex:2,dlParamName:"end",type:"number[]"},{tfInputIndex:3,dlParamName:"strides",type:"number[]"},{tfParamName:"begin_mask",dlParamName:"beginMask",type:"number",defaultValue:0},{tfParamName:"end_mask",dlParamName:"endMask",type:"number",defaultValue:0},{tfParamName:"new_axis_mask",dlParamName:"newAxisMask",type:"number",defaultValue:0},{tfParamName:"ellipsis_mask",dlParamName:"ellipsisMask",type:"number",defaultValue:0},{tfParamName:"shrink_axis_mask",dlParamName:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",dlOpName:"stack",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",dlOpName:"unstack",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0},{tfParamName:"num",dlParamName:"num",type:"number",defaultValue:0,notSupported:true}]},{tfOpName:"Tile",dlOpName:"tile",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"reps",type:"number[]"}]},{tfOpName:"Split",dlOpName:"split",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"axis",type:"number",defaultValue:0},{tfInputIndex:1,dlParamName:"x",type:"tensor"},{tfParamName:"num_split",dlParamName:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",dlOpName:"split",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"numOrSizeSplits",type:"number[]"},{tfInputIndex:2,dlParamName:"axis",type:"number",defaultValue:0}]}]},{}],44:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.json=[{tfOpName:"Cast",dlOpName:"cast",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"SrcT",dlParamName:"sdtype",type:"dtype",notSupported:true},{tfParamName:"DstT",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",dlOpName:"expandDims",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,tfParamNameDeprecated:"dim",dlParamName:"axis",type:"number"}]},{tfOpName:"Pad",dlOpName:"pad",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"padding",type:"number[]"},{tfParamName:"constant_value",dlParamName:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",dlOpName:"pad",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"padding",type:"number[]"},{tfInputIndex:2,dlParamName:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",dlOpName:"reshape",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"shape",type:"number[]"}]},{tfOpName:"Squeeze",dlOpName:"squeeze",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"axis",tfParamNameDeprecated:"squeeze_dims",dlParamName:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",dlOpName:"spaceToBatchND",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"blockShape",type:"number[]"},{tfInputIndex:2,dlParamName:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",dlOpName:"batchToSpaceND",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"blockShape",type:"number[]"},{tfInputIndex:2,dlParamName:"crops",type:"number[]"}]}]},{}],45:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var arithmetic=require("./executors/arithmetic_executor");var basicMath=require("./executors/basic_math_executor");var control=require("./executors/control_executor");var convolution=require("./executors/convolution_executor");var creation=require("./executors/creation_executor");var dynamic=require("./executors/dynamic_executor");var evaluation=require("./executors/evaluation_executor");var graph=require("./executors/graph_executor");var image=require("./executors/image_executor");var logical=require("./executors/logical_executor");var matrices=require("./executors/matrices_executor");var normalization=require("./executors/normalization_executor");var reduction=require("./executors/reduction_executor");var sliceJoin=require("./executors/slice_join_executor");var transformation=require("./executors/transformation_executor");function executeOp(node,tensorMap,context){switch(node.category){case"arithmetic":return arithmetic.executeOp(node,tensorMap,context);case"basic_math":return basicMath.executeOp(node,tensorMap,context);case"control":return control.executeOp(node,tensorMap,context);case"convolution":return convolution.executeOp(node,tensorMap,context);case"creation":return creation.executeOp(node,tensorMap,context);case"dynamic":return dynamic.executeOp(node,tensorMap,context);case"evaluation":return evaluation.executeOp(node,tensorMap,context);case"image":return image.executeOp(node,tensorMap,context);case"graph":return graph.executeOp(node,tensorMap,context);case"logical":return logical.executeOp(node,tensorMap,context);case"matrices":return matrices.executeOp(node,tensorMap,context);case"normalization":return normalization.executeOp(node,tensorMap,context);case"reduction":return reduction.executeOp(node,tensorMap,context);case"slice_join":return sliceJoin.executeOp(node,tensorMap,context);case"transformation":return transformation.executeOp(node,tensorMap,context);default:throw TypeError("Node type "+node.op+" is not implemented")}}exports.executeOp=executeOp},{"./executors/arithmetic_executor":14,"./executors/basic_math_executor":15,"./executors/control_executor":16,"./executors/convolution_executor":17,"./executors/creation_executor":18,"./executors/dynamic_executor":19,"./executors/evaluation_executor":20,"./executors/graph_executor":21,"./executors/image_executor":22,"./executors/logical_executor":23,"./executors/matrices_executor":24,"./executors/normalization_executor":25,"./executors/reduction_executor":26,"./executors/slice_join_executor":27,"./executors/transformation_executor":28}],46:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var compiled_api_1=require("../data/compiled_api");var utils_1=require("./executors/utils");var arithmetic=require("./op_list/arithmetic");var basicMath=require("./op_list/basic_math");var control=require("./op_list/control");var convolution=require("./op_list/convolution");var creation=require("./op_list/creation");var dynamic=require("./op_list/dynamic");var evaluation=require("./op_list/evaluation");var graph=require("./op_list/graph");var image=require("./op_list/image");var logical=require("./op_list/logical");var matrices=require("./op_list/matrices");var normalization=require("./op_list/normalization");var reduction=require("./op_list/reduction");var sliceJoin=require("./op_list/slice_join");var transformation=require("./op_list/transformation");var CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"];var DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","Where"];var OperationMapper=function(){function OperationMapper(){var ops=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image,graph,matrices,normalization,reduction,sliceJoin,transformation];var mappersJson=[].concat.apply([],ops.map(function(op){return op.json}));this.opMappers=mappersJson.reduce(function(map,mapper){map[mapper.tfOpName]=mapper;return map},{})}Object.defineProperty(OperationMapper,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:true,configurable:true});OperationMapper.prototype.isControlFlow=function(node){return CONTROL_FLOW_OPS.some(function(op){return op===node.op})};OperationMapper.prototype.isDynamicShape=function(node){return DYNAMIC_SHAPE_OPS.some(function(op){return op===node.op})};OperationMapper.prototype.transformGraph=function(graph){var _this=this;var tfNodes=graph.node;var withControlFlow=false;var withDynamicShape=false;var placeholders=[];var weights=[];var nodes=tfNodes.reduce(function(map,node){map[node.name]=_this.mapNode(node);if(_this.isControlFlow(node))withControlFlow=true;if(_this.isDynamicShape(node))withDynamicShape=true;if(node.op==="Placeholder")placeholders.push(map[node.name]);if(node.op==="Const")weights.push(map[node.name]);return map},{});var inputs=[];var outputs=[];Object.keys(nodes).forEach(function(key){var node=nodes[key];node.inputNames.forEach(function(name){var nodeName=utils_1.getNodeNameAndIndex(name)[0];node.inputs.push(nodes[nodeName]);nodes[nodeName].children.push(node)});if(node.inputs.length===0)inputs.push(node)});Object.keys(nodes).forEach(function(key){var node=nodes[key];if(node.children.length===0)outputs.push(node)});return{nodes:nodes,inputs:inputs,outputs:outputs,weights:weights,placeholders:placeholders,withControlFlow:withControlFlow,withDynamicShape:withDynamicShape}};OperationMapper.prototype.mapNode=function(node){var _this=this;var mapper=this.opMappers[node.op];if(mapper===undefined){throw new Error("Tensorflow Op is not supported: "+node.op)}var newNode={name:node.name,op:mapper.dlOpName,category:mapper.category,inputNames:(node.input||[]).map(function(input){return input.startsWith("^")?input.substr(1):input}),inputs:[],children:[],params:{}};if(!!mapper.params){newNode.params=mapper.params.reduce(function(map,param){var inputIndex=param.tfInputIndex;var inputParamLength=param.tfInputParamLength;var type=param.type;var value=undefined;if(inputIndex===undefined){switch(param.type){case"string":value=_this.getStringParam(node.attr,param.tfParamName,param.defaultValue);if(value===undefined&&!!param.tfParamNameDeprecated){value=_this.getStringParam(node.attr,param.tfParamNameDeprecated,param.defaultValue)}break;case"number":value=_this.getNumberParam(node.attr,param.tfParamName,param.defaultValue);if(value===undefined&&!!param.tfParamNameDeprecated){value=_this.getNumberParam(node.attr,param.tfParamNameDeprecated,param.defaultValue)}break;case"number[]":value=_this.getNumericArrayParam(node.attr,param.tfParamName,param.defaultValue);if(value===undefined&&!!param.tfParamNameDeprecated){value=_this.getNumericArrayParam(node.attr,param.tfParamNameDeprecated,param.defaultValue)}break;case"bool":value=_this.getBoolParam(node.attr,param.tfParamName,param.defaultValue);if(value===undefined&&!!param.tfParamNameDeprecated){value=_this.getBoolParam(node.attr,param.tfParamNameDeprecated,param.defaultValue)}break;case"shape":value=_this.getTensorShapeParam(node.attr,param.tfParamName,param.defaultValue);if(value===undefined&&!!param.tfParamNameDeprecated){value=_this.getTensorShapeParam(node.attr,param.tfParamNameDeprecated,param.defaultValue)}break;case"dtype":value=_this.getDtypeParam(node.attr,param.tfParamName,param.defaultValue);if(value===undefined&&!!param.tfParamNameDeprecated){value=_this.getDtypeParam(node.attr,param.tfParamNameDeprecated,param.defaultValue)}break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+param.type+" for op: "+node.op)}}map[param.dlParamName]={value:value,inputIndex:inputIndex,type:type,inputParamLength:inputParamLength};return map},{})}return newNode};OperationMapper.prototype.getStringParam=function(attrs,name,def,keepCase){if(keepCase===void 0){keepCase=false}var param=attrs[name];if(param!==undefined){var value=String.fromCharCode.apply(null,param.s);return keepCase?value:value.toLowerCase()}return def};OperationMapper.prototype.getBoolParam=function(attrs,name,def){var param=attrs[name];return param?param.b:def};OperationMapper.prototype.getNumberParam=function(attrs,name,def){var param=attrs[name];var value=param?param[param.value]:def;return typeof value==="number"?value:value["toInt"]()};OperationMapper.prototype.getDtypeParam=function(attrs,name,def){var param=attrs[name];if(param&&param.type){switch(param.type){case compiled_api_1.tensorflow.DataType.DT_FLOAT:return"float32";case compiled_api_1.tensorflow.DataType.DT_INT32:return"int32";case compiled_api_1.tensorflow.DataType.DT_BOOL:return"bool";default:return def}}return def};OperationMapper.prototype.getTensorShapeParam=function(attrs,name,def){var param=attrs[name];if(param&&param.shape){return param.shape.dim.map(function(dim){return typeof dim.size==="number"?dim.size:dim.size["toInt"]()})}return def};OperationMapper.prototype.getNumericArrayParam=function(attrs,name,def){var param=attrs[name];if(param){return(param.list.f&&param.list.f.length?param.list.f:param.list.i).map(function(v){return typeof v==="number"?v:v["toInt"]()})}return def};return OperationMapper}();exports.OperationMapper=OperationMapper},{"../data/compiled_api":8,"./executors/utils":29,"./op_list/arithmetic":30,"./op_list/basic_math":31,"./op_list/control":32,"./op_list/convolution":33,"./op_list/creation":34,"./op_list/dynamic":35,"./op_list/evaluation":36,"./op_list/graph":37,"./op_list/image":38,"./op_list/logical":39,"./op_list/matrices":40,"./op_list/normalization":41,"./op_list/reduction":42,"./op_list/slice_join":43,"./op_list/transformation":44}],47:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var version="0.6.1";exports.version=version},{}],48:[function(require,module,exports){(function(setImmediate){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var delayCallback=typeof requestAnimationFrame!=="undefined"?requestAnimationFrame:setImmediate;function nextFrame(){return new Promise(function(resolve){return delayCallback(function(){return resolve()})})}exports.nextFrame=nextFrame}).call(this,require("timers").setImmediate)},{timers:264}],49:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function isMobile(){var a=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}exports.isMobile=isMobile},{}],50:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var profiler_1=require("./profiler");var tape_1=require("./tape");var tensor_1=require("./tensor");var tensor_util_1=require("./tensor_util");var util=require("./util");var util_1=require("./util");var Engine=function(){function Engine(backend,safeMode,debugMode){this.backend=backend;this.safeMode=safeMode;this.debugMode=debugMode;this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numDataBuffers=0;this.profiling=false;this.gradientScopeCount=0;this.customGradientDepth=0;this.keepTensors=new Set;this.tensorInfo=new WeakMap;this.activeScope={track:[],name:"default scope"};this.scopeStack=[this.activeScope];this.profiler=new profiler_1.Profiler(backend);this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}Engine.prototype.moveData=function(dataId){this.write(dataId,this.readSync(dataId))};Engine.prototype.tidy=function(nameOrFn,fn,gradMode){var _this=this;if(gradMode===void 0){gradMode=false}var name=null;if(fn==null){if(typeof nameOrFn!=="function"){throw new Error("Please provide a function to tidy()")}fn=nameOrFn}else{if(typeof nameOrFn!=="string"&&!(nameOrFn instanceof String)){throw new Error("When calling with two arguments, the first argument "+"to tidy() must be a string")}if(typeof fn!=="function"){throw new Error("When calling with two arguments, the 2nd argument "+"to tidy() must be a function")}name=nameOrFn}var result;return this.scopedRun(function(){return _this.startScope(name,gradMode)},function(){return _this.endScope(result,gradMode)},function(){result=fn();if(result instanceof Promise){console.error("Cannot return a Promise inside of tidy.")}return result})};Engine.prototype.scopedRun=function(start,end,f){start();try{var res=f();end();return res}catch(ex){end();throw ex}};Engine.prototype.runKernel=function(forwardFunc,inputs,backwardsFunc){var _this=this;var result;var saved=[];var saveFunc=function(x){saved.push(x);return x};var scopeName=this.activeScope.name;var startingBytecount=this.numBytes;var startingNumTensors=this.numTensors;this.scopedRun(function(){return _this.customGradientDepth++},function(){return _this.customGradientDepth--},function(){if(!_this.debugMode()){result=forwardFunc(_this.backend,saveFunc)}else{result=_this.profiler.profileKernel(scopeName,function(){return forwardFunc(_this.backend,saveFunc)})}});if(this.shouldRecord()){var tapeNode={id:this.nextTapeNodeId++,name:scopeName,inputs:inputs,outputs:Array.isArray(result)?result:[result]};if(backwardsFunc!=null){tapeNode.gradient=function(dy){return backwardsFunc(dy,saved)}}this.activeTape.push(tapeNode)}if(this.profiling){this.activeProfile.kernels.push({name:scopeName,bytesAdded:this.numBytes-startingBytecount,totalBytesSnapshot:this.numBytes,tensorsAdded:this.numTensors-startingNumTensors,totalTensorsSnapshot:this.numTensors,inputShapes:Object.keys(inputs).map(function(key){return inputs[key].shape}),outputShape:Array.isArray(result)?result.map(function(item){return item.shape}):result.shape})}return result};Engine.prototype.registerTensor=function(a){var refCount=this.tensorInfo.has(a.dataId)?this.tensorInfo.get(a.dataId).refCount:0;this.numTensors++;if(refCount===0){this.numDataBuffers++;if(a.dtype!=="complex64"){this.numBytes+=util.sizeFromShape(a.shape)*util.bytesPerElement(a.dtype)}this.tensorInfo.set(a.dataId,{backend:this.backend,dtype:a.dtype,shape:a.shape,refCount:0});this.backend.register(a.dataId,a.shape,a.dtype)}this.tensorInfo.get(a.dataId).refCount++;if(!(a instanceof tensor_1.Variable)){this.track(a)}};Engine.prototype.registerVariable=function(v){if(this.registeredVariables[v.name]!=null){throw new Error("Variable with name "+v.name+" was already registered")}this.registeredVariables[v.name]=v};Engine.prototype.disposeTensor=function(a){if(!this.tensorInfo.has(a.dataId)){return}if(this.keepTensors.has(a.id)){this.keepTensors.delete(a.id)}this.numTensors--;var refCount=this.tensorInfo.get(a.dataId).refCount;if(refCount<=1){var info=this.tensorInfo.get(a.dataId);info.backend.disposeData(a.dataId);this.numDataBuffers--;if(a.dtype!=="complex64"){this.numBytes-=util.sizeFromShape(a.shape)*util.bytesPerElement(a.dtype)}this.tensorInfo.delete(a.dataId)}else{this.tensorInfo.get(a.dataId).refCount--}};Engine.prototype.disposeVariables=function(){for(var varName in this.registeredVariables){var v=this.registeredVariables[varName];this.disposeTensor(v);delete this.registeredVariables[varName]}};Engine.prototype.memory=function(){var info=this.backend.memory();info.numTensors=this.numTensors;info.numDataBuffers=this.numDataBuffers;info.numBytes=this.numBytes;return info};Engine.prototype.profile=function(query){return __awaiter(this,void 0,void 0,function(){var startBytes,startNumTensors;return __generator(this,function(_a){this.profiling=true;startBytes=this.numBytes;startNumTensors=this.numTensors;this.activeProfile.kernels=[];this.activeProfile.result=query();this.profiling=false;this.activeProfile.peakBytes=Math.max.apply(Math,this.activeProfile.kernels.map(function(d){return d.totalBytesSnapshot}));this.activeProfile.newBytes=this.numBytes-startBytes;this.activeProfile.newTensors=this.numTensors-startNumTensors;return[2,this.activeProfile]})})};Engine.prototype.shouldRecord=function(){return this.activeTape!=null&&this.customGradientDepth===0};Engine.prototype.addTapeNode=function(inputs,result,gradientsFunc){var inputsMap={};inputs.forEach(function(input,idx){inputsMap[idx]=input});var gradient=function(dy){var res=gradientsFunc(dy);var resMap={};res.forEach(function(r,idx){resMap[idx]=function(){return r}});return resMap};var tapeNode={id:this.nextTapeNodeId++,name:this.activeScope.name,inputs:inputsMap,outputs:[result],gradient:gradient};this.activeTape.push(tapeNode)};Engine.prototype.keep=function(result){if(this.scopeStack.length===1&&this.safeMode){throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): "+"tf.tidy(() => {...}) to avoid memory leaks.")}this.keepTensors.add(result.id);return result};Engine.prototype.startScope=function(name,gradientsMode){if(gradientsMode===void 0){gradientsMode=false}if(gradientsMode&&this.gradientScopeCount===0){this.activeTape=[]}if(gradientsMode){this.gradientScopeCount++}var scopeInfo={track:[],name:"unnamed scope"};if(name){scopeInfo.name=name}this.scopeStack.push(scopeInfo);this.activeScope=scopeInfo};Engine.prototype.endScope=function(result,gradientsMode){var _this=this;if(gradientsMode===void 0){gradientsMode=false}if(gradientsMode){this.gradientScopeCount--;if(this.gradientScopeCount===0){this.activeTape=null}}var tensorsToKeep=new Set(this.keepTensors);var tensorsToTrackInParent=tensor_util_1.getTensorsInContainer(result);tensorsToTrackInParent.forEach(function(tensor){return tensorsToKeep.add(tensor.id)});for(var i=0;i<this.activeScope.track.length;i++){var tensor=this.activeScope.track[i];if(tensorsToKeep.has(tensor.id)){continue}if(this.activeTape!=null){tensorsToTrackInParent.push(tensor)}else{tensor.dispose()}}var oldScope=this.scopeStack.pop();this.activeScope=this.scopeStack.length===0?{track:[],name:"default scope"}:this.scopeStack[this.scopeStack.length-1];tensorsToTrackInParent.forEach(function(tensor){if(!_this.keepTensors.has(tensor.id)&&tensor_util_1.isTensorInList(tensor,oldScope.track)){_this.track(tensor)}})};Engine.prototype.gradients=function(f,xs,dy,allowNoGradients){var _this=this;if(allowNoGradients===void 0){allowNoGradients=false}util.assert(xs.length>0,"gradients() received an empty list of xs.");return this.tidy("gradients",function(){var y=f();util.assert(y instanceof tensor_1.Tensor,"The result y returned by f() must be a tensor.");var filteredTape=tape_1.getFilteredNodesXToY(_this.activeTape,xs,y);if(!allowNoGradients&&filteredTape.length===0&&xs.length>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure "+"that the f you passed encloses all operations that lead from x "+"to y.")}var accumulatedGradientMap={};accumulatedGradientMap[y.id]=dy==null?ones(y.shape):dy;tape_1.backpropagateGradients(accumulatedGradientMap,filteredTape);var grads=xs.map(function(x){return accumulatedGradientMap[x.id]});return{value:y,grads:grads}},true)};Engine.prototype.customGrad=function(f){var _this=this;util.assert(util.isFunction(f),"The f passed in customGrad(f) must be a function.");return function(){var inputs=[];for(var _i=0;_i<arguments.length;_i++){inputs[_i]=arguments[_i]}util.assert(inputs.every(function(t){return t instanceof tensor_1.Tensor}),"The args passed in customGrad(f)(x1, x2,...) must all be tensors");var gradientsFunc;var result;_this.scopedRun(function(){return _this.customGradientDepth++},function(){return _this.customGradientDepth--},function(){var gradientsMode=true;result=_this.tidy(f.name,function(){var _a=f.apply(void 0,inputs),value=_a.value,gradFunc=_a.gradFunc;util.assert(value instanceof tensor_1.Tensor,"The function f passed in customGrad(f) must return an "+"object where `obj.value` is a tensor");util.assert(util.isFunction(gradFunc),"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function.");gradientsFunc=gradFunc;return value},gradientsMode)});if(_this.shouldRecord()){var gradFunc=function(dy){var res=gradientsFunc(dy);var grads=Array.isArray(res)?res:[res];util.assert(grads.length===inputs.length,"The function f passed in customGrad(f) must return an object "+"where `obj.gradFunc` is a function that returns the same "+"number of tensors as inputs passed to f(...).");util.assert(grads.every(function(t){return t instanceof tensor_1.Tensor}),"The function f passed in customGrad(f) must return an object "+"where `obj.gradFunc` is a function that returns a list of "+"only tensors.");return grads};_this.addTapeNode(inputs,result,gradFunc)}return result}};Engine.prototype.write=function(dataId,values){var info=this.tensorInfo.get(dataId);if(this.backend!==info.backend){info.backend.disposeData(dataId);info.backend=this.backend;this.backend.register(dataId,info.shape,info.dtype)}this.backend.write(dataId,values)};Engine.prototype.readSync=function(dataId){var info=this.tensorInfo.get(dataId);return info.backend.readSync(dataId)};Engine.prototype.read=function(dataId){var info=this.tensorInfo.get(dataId);return info.backend.read(dataId)};Engine.prototype.fromPixels=function(pixels,numChannels){return this.backend.fromPixels(pixels,numChannels)};Engine.prototype.time=function(query){return __awaiter(this,void 0,void 0,function(){var start,timingInfo;return __generator(this,function(_a){switch(_a.label){case 0:start=util_1.now();return[4,this.backend.time(query)];case 1:timingInfo=_a.sent();timingInfo.wallMs=util_1.now()-start;return[2,timingInfo]}})})};Engine.prototype.track=function(result){if(this.scopeStack.length===1&&this.safeMode){throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): "+"tf.tidy(() => {op();...}); to avoid memory leaks.")}this.activeScope.track.push(result);return result};return Engine}();exports.Engine=Engine;function ones(shape){var values=util_1.makeOnesTypedArray(util_1.sizeFromShape(shape),"float32");return tensor_1.Tensor.make(shape,{values:values})}},{"./profiler":175,"./tape":177,"./tensor":178,"./tensor_util":180,"./util":185}],51:[function(require,module,exports){(function(process){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var device_util=require("./device_util");var engine_1=require("./engine");var environment_util_1=require("./environment_util");var tensor_1=require("./tensor");var tensor_util_1=require("./tensor_util");var EPSILON_FLOAT16=.001;var TEST_EPSILON_FLOAT16=.1;var EPSILON_FLOAT32=1e-7;var TEST_EPSILON_FLOAT32=.001;var Environment=function(){function Environment(features){this.features={};this.registry={};if(features!=null){this.features=features}if(this.get("DEBUG")){console.warn("Debugging mode is ON. The output of every math call will "+"be downloaded to CPU and checked for NaNs. "+"This significantly impacts performance.")}}Environment.setBackend=function(backendName,safeMode){if(safeMode===void 0){safeMode=false}if(!(backendName in exports.ENV.registry)){throw new Error("Backend name '"+backendName+"' not found in registry")}exports.ENV.engine.backend=exports.ENV.findBackend(backendName);exports.ENV.backendName=backendName};Environment.getBackend=function(){exports.ENV.initEngine();return exports.ENV.backendName};Environment.disposeVariables=function(){exports.ENV.engine.disposeVariables()};Environment.memory=function(){return exports.ENV.engine.memory()};Environment.profile=function(f){return exports.ENV.engine.profile(f)};Environment.tidy=function(nameOrFn,fn,gradMode){if(gradMode===void 0){gradMode=false}return exports.ENV.engine.tidy(nameOrFn,fn,gradMode)};Environment.dispose=function(container){var tensors=tensor_util_1.getTensorsInContainer(container);tensors.forEach(function(tensor){return tensor.dispose()})};Environment.keep=function(result){return exports.ENV.engine.keep(result)};Environment.time=function(f){return exports.ENV.engine.time(f)};Environment.prototype.get=function(feature){if(feature in this.features){return this.features[feature]}this.features[feature]=this.evaluateFeature(feature);return this.features[feature]};Environment.prototype.getFeatures=function(){return this.features};Environment.prototype.set=function(feature,value){this.features[feature]=value};Environment.prototype.getBestBackendName=function(){var _this=this;if(Object.keys(this.registry).length===0){throw new Error("No backend found in registry.")}var sortedBackends=Object.keys(this.registry).map(function(name){return{name:name,entry:_this.registry[name]}}).sort(function(a,b){return b.entry.priority-a.entry.priority});return sortedBackends[0].name};Environment.prototype.evaluateFeature=function(feature){if(feature==="DEBUG"){return false}else if(feature==="IS_BROWSER"){return typeof window!=="undefined"}else if(feature==="IS_NODE"){return typeof process!=="undefined"&&typeof process.versions.node!=="undefined"}else if(feature==="IS_CHROME"){return environment_util_1.isChrome()}else if(feature==="WEBGL_PAGING_ENABLED"){return this.get("IS_BROWSER")}else if(feature==="IS_TEST"){return false}else if(feature==="BACKEND"){return this.getBestBackendName()}else if(feature==="WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"){var webGLVersion=this.get("WEBGL_VERSION");if(webGLVersion===0){return 0}return environment_util_1.getWebGLDisjointQueryTimerVersion(webGLVersion,this.get("IS_BROWSER"))}else if(feature==="WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"){return this.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!device_util.isMobile()}else if(feature==="HAS_WEBGL"){return this.get("WEBGL_VERSION")>0}else if(feature==="WEBGL_VERSION"){if(environment_util_1.isWebGLVersionEnabled(2,this.get("IS_BROWSER"))){return 2}else if(environment_util_1.isWebGLVersionEnabled(1,this.get("IS_BROWSER"))){return 1}return 0}else if(feature==="WEBGL_RENDER_FLOAT32_ENABLED"){return environment_util_1.isRenderToFloatTextureEnabled(this.get("WEBGL_VERSION"),this.get("IS_BROWSER"))}else if(feature==="WEBGL_DOWNLOAD_FLOAT_ENABLED"){return environment_util_1.isDownloadFloatTextureEnabled(this.get("WEBGL_VERSION"),this.get("IS_BROWSER"))}else if(feature==="WEBGL_FENCE_API_ENABLED"){return environment_util_1.isWebGLFenceEnabled(this.get("WEBGL_VERSION"),this.get("IS_BROWSER"))}else if(feature==="TEST_EPSILON"){return this.backend.floatPrecision()===32?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16}else if(feature==="EPSILON"){return this.backend.floatPrecision()===32?EPSILON_FLOAT32:EPSILON_FLOAT16}throw new Error("Unknown feature "+feature+".")};Environment.prototype.setFeatures=function(features){this.features=Object.assign({},features)};Environment.prototype.reset=function(){this.features=environment_util_1.getFeaturesFromURL();if(this.globalEngine!=null){this.globalEngine=null}};Object.defineProperty(Environment.prototype,"backend",{get:function(){return this.engine.backend},enumerable:true,configurable:true});Environment.prototype.findBackend=function(name){if(!(name in this.registry)){return null}return this.registry[name].backend};Environment.prototype.registerBackend=function(name,factory,priority,setTensorTrackerFn){var _this=this;if(priority===void 0){priority=1}if(name in this.registry){console.warn(name+" backend was already registered. Reusing existing backend");if(setTensorTrackerFn!=null){setTensorTrackerFn(function(){return _this.engine})}return false}try{var backend=factory();backend.setDataMover({moveData:function(dataId){return _this.engine.moveData(dataId)}});this.registry[name]={backend:backend,priority:priority};return true}catch(err){console.warn("Registration of backend "+name+" failed");console.warn(err.stack||err.message);return false}};Environment.prototype.removeBackend=function(name){if(!(name in this.registry)){throw new Error(name+" backend not found in registry")}this.registry[name].backend.dispose();delete this.registry[name]};Object.defineProperty(Environment.prototype,"engine",{get:function(){this.initEngine();return this.globalEngine},enumerable:true,configurable:true});Environment.prototype.initEngine=function(){var _this=this;if(this.globalEngine==null){this.backendName=this.get("BACKEND");var backend=this.findBackend(this.backendName);this.globalEngine=new engine_1.Engine(backend,false,function(){return _this.get("DEBUG")})}};return Environment}();exports.Environment=Environment;function getGlobalNamespace(){var ns;if(typeof window!=="undefined"){ns=window}else if(typeof process!=="undefined"){ns=process}else{throw new Error("Could not find a global object")}return ns}function getOrMakeEnvironment(){var ns=getGlobalNamespace();if(ns.ENV==null){ns.ENV=new Environment(environment_util_1.getFeaturesFromURL());tensor_1.setTensorTracker(function(){return ns.ENV.engine})}return ns.ENV}exports.ENV=getOrMakeEnvironment()}).call(this,require("_process"))},{"./device_util":49,"./engine":50,"./environment_util":52,"./tensor":178,"./tensor_util":180,_process:244}],52:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Type;(function(Type){Type[Type["NUMBER"]=0]="NUMBER";Type[Type["BOOLEAN"]=1]="BOOLEAN";Type[Type["STRING"]=2]="STRING"})(Type=exports.Type||(exports.Type={}));exports.URL_PROPERTIES=[{name:"DEBUG",type:Type.BOOLEAN},{name:"IS_BROWSER",type:Type.BOOLEAN},{name:"WEBGL_PAGING_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",type:Type.NUMBER},{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",type:Type.BOOLEAN},{name:"WEBGL_VERSION",type:Type.NUMBER},{name:"WEBGL_RENDER_FLOAT32_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_DOWNLOAD_FLOAT_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_FENCE_API_ENABLED",type:Type.BOOLEAN},{name:"BACKEND",type:Type.STRING},{name:"EPSILON",type:Type.NUMBER}];function isWebGLVersionEnabled(webGLVersion,isBrowser){var gl;try{gl=getWebGLRenderingContext(webGLVersion,isBrowser)}catch(e){return false}if(gl!=null){loseContext(gl);return true}return false}exports.isWebGLVersionEnabled=isWebGLVersionEnabled;function getWebGLDisjointQueryTimerVersion(webGLVersion,isBrowser){if(webGLVersion===0){return 0}var queryTimerVersion;var gl=getWebGLRenderingContext(webGLVersion,isBrowser);if(hasExtension(gl,"EXT_disjoint_timer_query_webgl2")&&webGLVersion===2){queryTimerVersion=2}else if(hasExtension(gl,"EXT_disjoint_timer_query")){queryTimerVersion=1}else{queryTimerVersion=0}if(gl!=null){loseContext(gl)}return queryTimerVersion}exports.getWebGLDisjointQueryTimerVersion=getWebGLDisjointQueryTimerVersion;function isRenderToFloatTextureEnabled(webGLVersion,isBrowser){if(webGLVersion===0){return false}var gl=getWebGLRenderingContext(webGLVersion,isBrowser);if(webGLVersion===1){if(!hasExtension(gl,"OES_texture_float")){return false}}else{if(!hasExtension(gl,"EXT_color_buffer_float")){return false}}var isFrameBufferComplete=createFloatTextureAndBindToFramebuffer(gl,webGLVersion);loseContext(gl);return isFrameBufferComplete}exports.isRenderToFloatTextureEnabled=isRenderToFloatTextureEnabled;function isDownloadFloatTextureEnabled(webGLVersion,isBrowser){if(webGLVersion===0){return false}var gl=getWebGLRenderingContext(webGLVersion,isBrowser);if(webGLVersion===1){if(!hasExtension(gl,"OES_texture_float")){return false}if(!hasExtension(gl,"WEBGL_color_buffer_float")){return false}}else{if(!hasExtension(gl,"EXT_color_buffer_float")){return false}}var isFrameBufferComplete=createFloatTextureAndBindToFramebuffer(gl,webGLVersion);loseContext(gl);return isFrameBufferComplete}exports.isDownloadFloatTextureEnabled=isDownloadFloatTextureEnabled;function isWebGLFenceEnabled(webGLVersion,isBrowser){if(webGLVersion!==2){return false}var gl=getWebGLRenderingContext(webGLVersion,isBrowser);var isEnabled=gl.fenceSync!=null;loseContext(gl);return isEnabled}exports.isWebGLFenceEnabled=isWebGLFenceEnabled;function isChrome(){return typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}exports.isChrome=isChrome;var TENSORFLOWJS_FLAGS_PREFIX="tfjsflags";function getFeaturesFromURL(){var features={};if(typeof window==="undefined"||typeof window.location==="undefined"){return features}var urlParams=getQueryParams(window.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in urlParams){var urlFlags_1={};var keyValues=urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");keyValues.forEach(function(keyValue){var _a=keyValue.split(":"),key=_a[0],value=_a[1];urlFlags_1[key]=value});exports.URL_PROPERTIES.forEach(function(urlProperty){if(urlProperty.name in urlFlags_1){console.log("Setting feature override from URL "+urlProperty.name+": "+(""+urlFlags_1[urlProperty.name]));if(urlProperty.type===Type.NUMBER){features[urlProperty.name]=+urlFlags_1[urlProperty.name]}else if(urlProperty.type===Type.BOOLEAN){features[urlProperty.name]=urlFlags_1[urlProperty.name]==="true"}else if(urlProperty.type===Type.STRING){features[urlProperty.name]=urlFlags_1[urlProperty.name]}else{console.warn("Unknown URL param: "+urlProperty.name+".")}}})}return features}exports.getFeaturesFromURL=getFeaturesFromURL;function hasExtension(gl,extensionName){var ext=gl.getExtension(extensionName);return ext!=null}function getWebGLRenderingContext(webGLVersion,isBrowser){if(webGLVersion===0||!isBrowser){throw new Error("Cannot get WebGL rendering context, WebGL is disabled.")}var tempCanvas=document.createElement("canvas");if(webGLVersion===1){return tempCanvas.getContext("webgl")||tempCanvas.getContext("experimental-webgl")}return tempCanvas.getContext("webgl2")}function loseContext(gl){if(gl!=null){var loseContextExtension=gl.getExtension("WEBGL_lose_context");if(loseContextExtension==null){throw new Error("Extension WEBGL_lose_context not supported on this browser.")}loseContextExtension.loseContext()}}function createFloatTextureAndBindToFramebuffer(gl,webGLVersion){var frameBuffer=gl.createFramebuffer();var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);var internalFormat=webGLVersion===2?gl.RGBA32F:gl.RGBA;gl.texImage2D(gl.TEXTURE_2D,0,internalFormat,1,1,0,gl.RGBA,gl.FLOAT,null);gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);var isFrameBufferComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;gl.bindTexture(gl.TEXTURE_2D,null);gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.deleteTexture(texture);gl.deleteFramebuffer(frameBuffer);return isFrameBufferComplete}function getQueryParams(queryString){var params={};queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(s){var t=[];for(var _i=1;_i<arguments.length;_i++){t[_i-1]=arguments[_i]}decodeParam(params,t[0],t[1]);return t.join("=")});return params}exports.getQueryParams=getQueryParams;function decodeParam(params,name,value){params[decodeURIComponent(name)]=decodeURIComponent(value||"")}},{}],53:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("./environment");var gradients_1=require("./gradients");exports.customGrad=gradients_1.customGrad;exports.grad=gradients_1.grad;exports.grads=gradients_1.grads;exports.valueAndGrad=gradients_1.valueAndGrad;exports.valueAndGrads=gradients_1.valueAndGrads;exports.variableGrads=gradients_1.variableGrads;exports.tidy=environment_1.Environment.tidy;exports.keep=environment_1.Environment.keep;exports.dispose=environment_1.Environment.dispose;exports.time=environment_1.Environment.time;exports.profile=environment_1.Environment.profile},{"./environment":51,"./gradients":54}],54:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("./environment");var tensor_1=require("./tensor");var util=require("./util");function gradScope(nameOrScopeFn,scopeFn){return environment_1.ENV.engine.tidy(nameOrScopeFn,scopeFn,true)}exports.gradScope=gradScope;function grad(f){util.assert(util.isFunction(f),"The f passed in grad(f) must be a function");return function(x,dy){util.assert(x instanceof tensor_1.Tensor,"The x passed in grad(f)(x) must be a tensor");util.assert(dy==null||dy instanceof tensor_1.Tensor,"The dy passed in grad(f)(x, dy) must be a tensor");return environment_1.ENV.engine.tidy(function(){var _a=environment_1.ENV.engine.gradients(function(){return f(x)},[x],dy),value=_a.value,grads=_a.grads;if(dy!=null){util.assertShapesMatch(value.shape,dy.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape "+"returned by f(x)")}checkGrads(grads);return grads[0]})}}exports.grad=grad;function grads(f){util.assert(util.isFunction(f),"The f passed in grads(f) must be a function");return function(args,dy){util.assert(Array.isArray(args)&&args.every(function(arg){return arg instanceof tensor_1.Tensor}),"The args passed in grads(f)(args) must be an array of tensors");util.assert(dy==null||dy instanceof tensor_1.Tensor,"The dy passed in grads(f)(args, dy) must be a tensor");return environment_1.ENV.engine.tidy(function(){var _a=environment_1.ENV.engine.gradients(function(){return f.apply(void 0,args)},args,dy),value=_a.value,grads=_a.grads;if(dy!=null){util.assertShapesMatch(value.shape,dy.shape,"The shape of dy passed in grads(f)([x1,...], dy) must "+"match the shape returned by f([x1,...])")}checkGrads(grads);return grads})}}exports.grads=grads;function valueAndGrad(f){util.assert(util.isFunction(f),"The f passed in valueAndGrad(f) must be a function");return function(x,dy){util.assert(x instanceof tensor_1.Tensor,"The x passed in valueAndGrad(f)(x) must be a tensor");util.assert(dy==null||dy instanceof tensor_1.Tensor,"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");var _a=environment_1.ENV.engine.gradients(function(){return f(x)},[x],dy),grads=_a.grads,value=_a.value;checkGrads(grads);return{grad:grads[0],value:value}}}exports.valueAndGrad=valueAndGrad;function valueAndGrads(f){util.assert(util.isFunction(f),"The f passed in valueAndGrads(f) must be a function");return function(args,dy){util.assert(Array.isArray(args)&&args.every(function(arg){return arg instanceof tensor_1.Tensor}),"The args passed in valueAndGrads(f)(args) must be array of tensors");util.assert(dy==null||dy instanceof tensor_1.Tensor,"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");var res=environment_1.ENV.engine.gradients(function(){return f.apply(void 0,args)},args,dy);if(dy!=null){util.assertShapesMatch(res.value.shape,dy.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must "+"match the shape returned by f([x1,...])")}checkGrads(res.grads);return res}}exports.valueAndGrads=valueAndGrads;function variableGrads(f,varList){util.assert(util.isFunction(f),"The f passed in variableGrads(f) must be a function");util.assert(varList==null||Array.isArray(varList)&&varList.every(function(v){return v instanceof tensor_1.Variable}),"The varList passed in variableGrads(f, varList) must be an array "+"of variables");if(varList==null){varList=[];for(var varName in environment_1.ENV.engine.registeredVariables){varList.push(environment_1.ENV.engine.registeredVariables[varName])}}var originalVarCount=varList.length;varList=varList.filter(function(variable){return variable.trainable});util.assert(varList.length>0,"variableGrads() expects at least one of the input variables to be "+("trainable, but none of the "+originalVarCount+" variables is ")+"trainable.");var allowNoGradients=true;var _a=environment_1.ENV.engine.gradients(f,varList,null,allowNoGradients),value=_a.value,grads=_a.grads;util.assert(grads.some(function(g){return g!=null}),"Cannot find a connection between any variable and the result of the "+"loss function y=f(x). Please make sure the operations that use "+"variables are inside the function f passed to minimize().");util.assert(value.rank===0,"The f passed in variableGrads(f) must return a scalar, but it "+("returned a rank-"+value.rank+" tensor"));var namedGrads={};varList.forEach(function(v,i){if(grads[i]!=null){namedGrads[v.name]=grads[i]}});return{value:value,grads:namedGrads}}exports.variableGrads=variableGrads;function customGrad(f){return environment_1.ENV.engine.customGrad(f)}exports.customGrad=customGrad;function checkGrads(grads){var numNullGradients=grads.filter(function(g){return g==null}).length;if(numNullGradients>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}}},{"./environment":51,"./tensor":178,"./util":185}],55:[function(require,module,exports){"use strict";function __export(m){for(var p in m)if(!exports.hasOwnProperty(p))exports[p]=m[p]}Object.defineProperty(exports,"__esModule",{value:true});require("./kernels/backend_webgl");require("./kernels/backend_cpu");var browser_util_1=require("./browser_util");exports.nextFrame=browser_util_1.nextFrame;var environment=require("./environment");exports.environment=environment;var environment_1=require("./environment");var io=require("./io/io");exports.io=io;var serialization=require("./serialization");exports.serialization=serialization;var tensor_1=require("./tensor");var test_util=require("./test_util");exports.test_util=test_util;var util=require("./util");exports.util=util;var version_1=require("./version");exports.version_core=version_1.version;var webgl=require("./webgl");exports.webgl=webgl;var adadelta_optimizer_1=require("./optimizers/adadelta_optimizer");exports.AdadeltaOptimizer=adadelta_optimizer_1.AdadeltaOptimizer;var adagrad_optimizer_1=require("./optimizers/adagrad_optimizer");exports.AdagradOptimizer=adagrad_optimizer_1.AdagradOptimizer;var adam_optimizer_1=require("./optimizers/adam_optimizer");exports.AdamOptimizer=adam_optimizer_1.AdamOptimizer;var adamax_optimizer_1=require("./optimizers/adamax_optimizer");exports.AdamaxOptimizer=adamax_optimizer_1.AdamaxOptimizer;var momentum_optimizer_1=require("./optimizers/momentum_optimizer");exports.MomentumOptimizer=momentum_optimizer_1.MomentumOptimizer;var optimizer_1=require("./optimizers/optimizer");exports.Optimizer=optimizer_1.Optimizer;var rmsprop_optimizer_1=require("./optimizers/rmsprop_optimizer");exports.RMSPropOptimizer=rmsprop_optimizer_1.RMSPropOptimizer;var sgd_optimizer_1=require("./optimizers/sgd_optimizer");exports.SGDOptimizer=sgd_optimizer_1.SGDOptimizer;var tensor_2=require("./tensor");exports.Tensor=tensor_2.Tensor;exports.TensorBuffer=tensor_2.TensorBuffer;exports.variable=tensor_2.variable;exports.Variable=tensor_2.Variable;var types_1=require("./types");exports.Rank=types_1.Rank;__export(require("./ops/ops"));var loss_ops_1=require("./ops/loss_ops");exports.Reduction=loss_ops_1.Reduction;__export(require("./train"));__export(require("./globals"));var environment_2=require("./environment");exports.ENV=environment_2.ENV;exports.Environment=environment_2.Environment;exports.setBackend=environment_1.Environment.setBackend;exports.getBackend=environment_1.Environment.getBackend;exports.disposeVariables=environment_1.Environment.disposeVariables;exports.memory=environment_1.Environment.memory;var backend_1=require("./kernels/backend");exports.DataStorage=backend_1.DataStorage;var ops=require("./ops/ops");tensor_1.setOpHandler(ops)},{"./browser_util":48,"./environment":51,"./globals":53,"./io/io":59,"./kernels/backend":67,"./kernels/backend_cpu":68,"./kernels/backend_webgl":70,"./ops/loss_ops":141,"./ops/ops":148,"./optimizers/adadelta_optimizer":166,"./optimizers/adagrad_optimizer":167,"./optimizers/adam_optimizer":168,"./optimizers/adamax_optimizer":169,"./optimizers/momentum_optimizer":170,"./optimizers/optimizer":171,"./optimizers/rmsprop_optimizer":173,"./optimizers/sgd_optimizer":174,"./serialization":176,"./tensor":178,"./test_util":182,"./train":183,"./types":184,"./util":185,"./version":186,"./webgl":187}],56:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var io_utils_1=require("./io_utils");var router_registry_1=require("./router_registry");var DEFAULT_FILE_NAME_PREFIX="model";var DEFAULT_JSON_EXTENSION_NAME=".json";var DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";var BrowserDownloads=function(){function BrowserDownloads(fileNamePrefix){if(!environment_1.ENV.get("IS_BROWSER")){throw new Error("triggerDownloads() cannot proceed because the current environment "+"is not a browser.")}if(fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)){fileNamePrefix=fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length)}if(fileNamePrefix==null||fileNamePrefix.length===0){fileNamePrefix=DEFAULT_FILE_NAME_PREFIX}this.modelTopologyFileName=fileNamePrefix+DEFAULT_JSON_EXTENSION_NAME;this.weightDataFileName=fileNamePrefix+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}BrowserDownloads.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){var weightsURL,weightsManifest,modelTopologyAndWeightManifest,modelTopologyAndWeightManifestURL,jsonAnchor,weightDataAnchor;return __generator(this,function(_a){weightsURL=window.URL.createObjectURL(new Blob([modelArtifacts.weightData],{type:"application/octet-stream"}));if(modelArtifacts.modelTopology instanceof ArrayBuffer){throw new Error("DownloadTrigger.save() does not support saving model topology "+"in binary formats yet.")}else{weightsManifest=[{paths:["./"+this.weightDataFileName],weights:modelArtifacts.weightSpecs}];modelTopologyAndWeightManifest={modelTopology:modelArtifacts.modelTopology,weightsManifest:weightsManifest};modelTopologyAndWeightManifestURL=window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)],{type:"application/json"}));jsonAnchor=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;jsonAnchor.download=this.modelTopologyFileName;jsonAnchor.href=modelTopologyAndWeightManifestURL;jsonAnchor.click();if(modelArtifacts.weightData!=null){weightDataAnchor=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;weightDataAnchor.download=this.weightDataFileName;weightDataAnchor.href=weightsURL;weightDataAnchor.click()}return[2,{modelArtifactsInfo:io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts)}]}return[2]})})};BrowserDownloads.URL_SCHEME="downloads://";return BrowserDownloads}();exports.BrowserDownloads=BrowserDownloads;var BrowserFiles=function(){function BrowserFiles(files){if(files==null||files.length<1){throw new Error("When calling browserFiles, at least 1 file is required, "+("but received "+files))}this.files=files}BrowserFiles.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var jsonFile,weightFiles;var _this=this;return __generator(this,function(_a){jsonFile=this.files[0];weightFiles=this.files.slice(1);return[2,new Promise(function(resolve,reject){var jsonReader=new FileReader;jsonReader.onload=function(event){var modelJSON=JSON.parse(event.target.result);var modelTopology=modelJSON.modelTopology;if(modelTopology==null){reject(new Error("modelTopology field is missing from file "+jsonFile.name));return}if(weightFiles.length===0){resolve({modelTopology:modelTopology})}var weightsManifest=modelJSON.weightsManifest;if(weightsManifest==null){reject(new Error("weightManifest field is missing from file "+jsonFile.name));return}var pathToFile;try{pathToFile=_this.checkManifestAndWeightFiles(weightsManifest,weightFiles)}catch(err){reject(err);return}var weightSpecs=[];var paths=[];var perFileBuffers=[];weightsManifest.forEach(function(weightsGroup){weightsGroup.paths.forEach(function(path){paths.push(path);perFileBuffers.push(null)});weightSpecs.push.apply(weightSpecs,weightsGroup.weights)});weightsManifest.forEach(function(weightsGroup){weightsGroup.paths.forEach(function(path){var weightFileReader=new FileReader;weightFileReader.onload=function(event){var weightData=event.target.result;var index=paths.indexOf(path);perFileBuffers[index]=weightData;if(perFileBuffers.indexOf(null)===-1){resolve({modelTopology:modelTopology,weightSpecs:weightSpecs,weightData:io_utils_1.concatenateArrayBuffers(perFileBuffers)})}};weightFileReader.onerror=function(error){reject("Failed to weights data from file of path '"+path+"'.");return};weightFileReader.readAsArrayBuffer(pathToFile[path])})})};jsonReader.onerror=function(error){reject("Failed to read model topology and weights manifest JSON "+("from file '"+jsonFile.name+"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only.");return};jsonReader.readAsText(jsonFile)})]})})};BrowserFiles.prototype.checkManifestAndWeightFiles=function(manifest,files){var basenames=[];var fileNames=files.map(function(file){return io_utils_1.basename(file.name)});var pathToFile={};for(var _i=0,manifest_1=manifest;_i<manifest_1.length;_i++){var group=manifest_1[_i];group.paths.forEach(function(path){var pathBasename=io_utils_1.basename(path);if(basenames.indexOf(pathBasename)!==-1){throw new Error("Duplicate file basename found in weights manifest: "+("'"+pathBasename+"'"))}basenames.push(pathBasename);if(fileNames.indexOf(pathBasename)===-1){throw new Error("Weight file with basename '"+pathBasename+"' is not provided.")}else{pathToFile[path]=files[fileNames.indexOf(pathBasename)]}})}if(basenames.length!==files.length){throw new Error("Mismatch in the number of files in weights manifest "+("("+basenames.length+") and the number of weight files provided ")+("("+files.length+")."))}return pathToFile};return BrowserFiles}();exports.browserDownloadsRouter=function(url){if(!environment_1.ENV.get("IS_BROWSER")){return null}else{if(!Array.isArray(url)&&url.startsWith(BrowserDownloads.URL_SCHEME)){return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length))}else{return null}}};router_registry_1.IORouterRegistry.registerSaveRouter(exports.browserDownloadsRouter);function browserDownloads(fileNamePrefix){if(fileNamePrefix===void 0){fileNamePrefix="model"}return new BrowserDownloads(fileNamePrefix)}exports.browserDownloads=browserDownloads;function browserFiles(files){return new BrowserFiles(files)}exports.browserFiles=browserFiles},{"../environment":51,"./io_utils":60,"./router_registry":64}],57:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var util_1=require("../util");var io_utils_1=require("./io_utils");var router_registry_1=require("./router_registry");var weights_loader_1=require("./weights_loader");var BrowserHTTPRequest=function(){function BrowserHTTPRequest(path,requestInit){this.DEFAULT_METHOD="POST";if(typeof fetch==="undefined"){throw new Error("browserHTTPRequest is not supported outside the web browser without a fetch polyfill.")}util_1.assert(path!=null&&path.length>0,"URL path for browserHTTPRequest must not be null, undefined or "+"empty.");if(Array.isArray(path)){util_1.assert(path.length===2,"URL paths for browserHTTPRequest must have a length of 2, "+("(actual length is "+path.length+")."))}this.path=path;if(requestInit!=null&&requestInit.body!=null){throw new Error("requestInit is expected to have no pre-existing body, but has one.")}this.requestInit=requestInit||{}}BrowserHTTPRequest.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){var init,weightsManifest,modelTopologyAndWeightManifest,response;return __generator(this,function(_a){switch(_a.label){case 0:if(modelArtifacts.modelTopology instanceof ArrayBuffer){throw new Error("BrowserHTTPRequest.save() does not support saving model topology "+"in binary formats yet.")}init=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);init.body=new FormData;weightsManifest=[{paths:["./model.weights.bin"],weights:modelArtifacts.weightSpecs}];modelTopologyAndWeightManifest={modelTopology:modelArtifacts.modelTopology,weightsManifest:weightsManifest};init.body.append("model.json",new Blob([JSON.stringify(modelTopologyAndWeightManifest)],{type:"application/json"}),"model.json");if(modelArtifacts.weightData!=null){init.body.append("model.weights.bin",new Blob([modelArtifacts.weightData],{type:"application/octet-stream"}),"model.weights.bin")}return[4,fetch(this.path,init)];case 1:response=_a.sent();if(response.status===200){return[2,{modelArtifactsInfo:io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts),responses:[response]}]}else{throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+(response.status+"."))}return[2]}})})};BrowserHTTPRequest.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,Array.isArray(this.path)?this.loadBinaryModel():this.loadJSONModel()]})})};BrowserHTTPRequest.prototype.loadBinaryTopology=function(){return __awaiter(this,void 0,void 0,function(){var response,error_1;return __generator(this,function(_a){switch(_a.label){case 0:_a.trys.push([0,3,,4]);return[4,fetch(this.path[0],this.requestInit)];case 1:response=_a.sent();return[4,response.arrayBuffer()];case 2:return[2,_a.sent()];case 3:error_1=_a.sent();throw new Error(this.path[0]+" not found. "+error_1);case 4:return[2]}})})};BrowserHTTPRequest.prototype.loadBinaryModel=function(){return __awaiter(this,void 0,void 0,function(){var graphPromise,manifestPromise,results,modelTopology,weightsManifestResponse,weightsManifest,weightSpecs,weightData,results_1;return __generator(this,function(_a){switch(_a.label){case 0:graphPromise=this.loadBinaryTopology();return[4,fetch(this.path[1],this.requestInit)];case 1:manifestPromise=_a.sent();return[4,Promise.all([graphPromise,manifestPromise])];case 2:results=_a.sent();modelTopology=results[0],weightsManifestResponse=results[1];return[4,weightsManifestResponse.json()];case 3:weightsManifest=_a.sent();if(!(weightsManifest!=null))return[3,5];return[4,this.loadWeights(weightsManifest)];case 4:results_1=_a.sent();weightSpecs=results_1[0],weightData=results_1[1];_a.label=5;case 5:return[2,{modelTopology:modelTopology,weightSpecs:weightSpecs,weightData:weightData}]}})})};BrowserHTTPRequest.prototype.loadJSONModel=function(){return __awaiter(this,void 0,void 0,function(){var modelConfigRequest,modelConfig,modelTopology,weightsManifest,weightSpecs,weightData,weightsManifest_1,results;return __generator(this,function(_a){switch(_a.label){case 0:return[4,fetch(this.path,this.requestInit)];case 1:modelConfigRequest=_a.sent();return[4,modelConfigRequest.json()];case 2:modelConfig=_a.sent();modelTopology=modelConfig["modelTopology"];weightsManifest=modelConfig["weightsManifest"];if(modelTopology==null&&weightsManifest==null){throw new Error("The JSON from HTTP path "+this.path+" contains neither model "+"topology or manifest for weights.")}if(!(weightsManifest!=null))return[3,4];weightsManifest_1=modelConfig["weightsManifest"];return[4,this.loadWeights(weightsManifest_1)];case 3:results=_a.sent();weightSpecs=results[0],weightData=results[1];_a.label=4;case 4:return[2,{modelTopology:modelTopology,weightSpecs:weightSpecs,weightData:weightData}]}})})};BrowserHTTPRequest.prototype.loadWeights=function(weightsManifest){return __awaiter(this,void 0,void 0,function(){var weightPath,weightSpecs,_i,weightsManifest_2,entry,pathPrefix,fetchURLs,_a,_b;return __generator(this,function(_c){switch(_c.label){case 0:weightPath=Array.isArray(this.path)?this.path[1]:this.path;weightSpecs=[];for(_i=0,weightsManifest_2=weightsManifest;_i<weightsManifest_2.length;_i++){entry=weightsManifest_2[_i];weightSpecs.push.apply(weightSpecs,entry.weights)}pathPrefix=weightPath.substring(0,weightPath.lastIndexOf("/"));if(!pathPrefix.endsWith("/")){pathPrefix=pathPrefix+"/"}fetchURLs=[];weightsManifest.forEach(function(weightsGroup){weightsGroup.paths.forEach(function(path){fetchURLs.push(pathPrefix+path)})});_a=[weightSpecs];_b=io_utils_1.concatenateArrayBuffers;return[4,weights_loader_1.loadWeightsAsArrayBuffer(fetchURLs,this.requestInit)];case 1:return[2,_a.concat([_b.apply(void 0,[_c.sent()])])]}})})};BrowserHTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//;return BrowserHTTPRequest}();exports.BrowserHTTPRequest=BrowserHTTPRequest;function isHTTPScheme(url){return url.match(BrowserHTTPRequest.URL_SCHEME_REGEX)!=null}exports.httpRequestRouter=function(url){if(typeof fetch==="undefined"){return null}else{var isHTTP=true;if(Array.isArray(url)){isHTTP=url.every(function(urlItem){return isHTTPScheme(urlItem)})}else{isHTTP=isHTTPScheme(url)}if(isHTTP){return browserHTTPRequest(url)}}return null};router_registry_1.IORouterRegistry.registerSaveRouter(exports.httpRequestRouter);router_registry_1.IORouterRegistry.registerLoadRouter(exports.httpRequestRouter);function browserHTTPRequest(path,requestInit){return new BrowserHTTPRequest(path,requestInit)}exports.browserHTTPRequest=browserHTTPRequest},{"../util":185,"./io_utils":60,"./router_registry":64,"./weights_loader":66}],58:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var io_utils_1=require("./io_utils");var model_management_1=require("./model_management");var router_registry_1=require("./router_registry");var DATABASE_NAME="tensorflowjs";var DATABASE_VERSION=1;var MODEL_STORE_NAME="models_store";var INFO_STORE_NAME="model_info_store";function deleteDatabase(){return __awaiter(this,void 0,void 0,function(){var idbFactory;return __generator(this,function(_a){idbFactory=getIndexedDBFactory();return[2,new Promise(function(resolve,reject){var deleteRequest=idbFactory.deleteDatabase(DATABASE_NAME);deleteRequest.onsuccess=function(){return resolve()};deleteRequest.onerror=function(error){return reject(error)}})]})})}exports.deleteDatabase=deleteDatabase;function getIndexedDBFactory(){if(!environment_1.ENV.get("IS_BROWSER")){throw new Error("Failed to obtain IndexedDB factory because the current environment"+"is not a web browser.")}var theWindow=window;var factory=theWindow.indexedDB||theWindow.mozIndexedDB||theWindow.webkitIndexedDB||theWindow.msIndexedDB||theWindow.shimIndexedDB;if(factory==null){throw new Error("The current browser does not appear to support IndexedDB.")}return factory}function setUpDatabase(openRequest){var db=openRequest.result;db.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"});db.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}var BrowserIndexedDB=function(){function BrowserIndexedDB(modelPath){this.indexedDB=getIndexedDBFactory();if(modelPath==null||!modelPath){throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")}this.modelPath=modelPath}BrowserIndexedDB.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){if(modelArtifacts.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}return[2,this.databaseAction(this.modelPath,modelArtifacts)]})})};BrowserIndexedDB.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.databaseAction(this.modelPath)]})})};BrowserIndexedDB.prototype.databaseAction=function(modelPath,modelArtifacts){var _this=this;return new Promise(function(resolve,reject){var openRequest=_this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);openRequest.onupgradeneeded=function(){return setUpDatabase(openRequest)};openRequest.onsuccess=function(){var db=openRequest.result;if(modelArtifacts==null){var modelTx=db.transaction(MODEL_STORE_NAME,"readonly");var modelStore=modelTx.objectStore(MODEL_STORE_NAME);var getRequest_1=modelStore.get(_this.modelPath);getRequest_1.onsuccess=function(){if(getRequest_1.result==null){db.close();return reject(new Error("Cannot find model with path '"+_this.modelPath+"' "+"in IndexedDB."))}else{resolve(getRequest_1.result.modelArtifacts)}};getRequest_1.onerror=function(error){db.close();return reject(getRequest_1.error)};modelTx.oncomplete=function(){return db.close()}}else{var modelArtifactsInfo_1=io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);var infoTx_1=db.transaction(INFO_STORE_NAME,"readwrite");var infoStore_1=infoTx_1.objectStore(INFO_STORE_NAME);var putInfoRequest_1=infoStore_1.put({modelPath:_this.modelPath,modelArtifactsInfo:modelArtifactsInfo_1});var modelTx_1;putInfoRequest_1.onsuccess=function(){modelTx_1=db.transaction(MODEL_STORE_NAME,"readwrite");var modelStore=modelTx_1.objectStore(MODEL_STORE_NAME);var putModelRequest=modelStore.put({modelPath:_this.modelPath,modelArtifacts:modelArtifacts,modelArtifactsInfo:modelArtifactsInfo_1});putModelRequest.onsuccess=function(){return resolve({modelArtifactsInfo:modelArtifactsInfo_1})};putModelRequest.onerror=function(error){infoStore_1=infoTx_1.objectStore(INFO_STORE_NAME);var deleteInfoRequest=infoStore_1.delete(_this.modelPath);deleteInfoRequest.onsuccess=function(){db.close();return reject(putModelRequest.error)};deleteInfoRequest.onerror=function(error){db.close();return reject(putModelRequest.error)}}};putInfoRequest_1.onerror=function(error){db.close();return reject(putInfoRequest_1.error)};infoTx_1.oncomplete=function(){if(modelTx_1==null){db.close()}else{modelTx_1.oncomplete=function(){return db.close()}}}}};openRequest.onerror=function(error){return reject(openRequest.error)}})};BrowserIndexedDB.URL_SCHEME="indexeddb://";return BrowserIndexedDB}();exports.BrowserIndexedDB=BrowserIndexedDB;exports.indexedDBRouter=function(url){if(!environment_1.ENV.get("IS_BROWSER")){return null}else{if(!Array.isArray(url)&&url.startsWith(BrowserIndexedDB.URL_SCHEME)){return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length))}else{return null}}};router_registry_1.IORouterRegistry.registerSaveRouter(exports.indexedDBRouter);router_registry_1.IORouterRegistry.registerLoadRouter(exports.indexedDBRouter);function browserIndexedDB(modelPath){return new BrowserIndexedDB(modelPath)}exports.browserIndexedDB=browserIndexedDB;function maybeStripScheme(key){return key.startsWith(BrowserIndexedDB.URL_SCHEME)?key.slice(BrowserIndexedDB.URL_SCHEME.length):key}var BrowserIndexedDBManager=function(){function BrowserIndexedDBManager(){this.indexedDB=getIndexedDBFactory()}BrowserIndexedDBManager.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){return[2,new Promise(function(resolve,reject){var openRequest=_this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);openRequest.onupgradeneeded=function(){return setUpDatabase(openRequest)};openRequest.onsuccess=function(){var db=openRequest.result;var tx=db.transaction(INFO_STORE_NAME,"readonly");var store=tx.objectStore(INFO_STORE_NAME);var getAllInfoRequest=store.getAll();getAllInfoRequest.onsuccess=function(){var out={};for(var _i=0,_a=getAllInfoRequest.result;_i<_a.length;_i++){var item=_a[_i];out[item.modelPath]=item.modelArtifactsInfo}resolve(out)};getAllInfoRequest.onerror=function(error){db.close();return reject(getAllInfoRequest.error)};tx.oncomplete=function(){return db.close()}};openRequest.onerror=function(error){return reject(openRequest.error)}})]})})};BrowserIndexedDBManager.prototype.removeModel=function(path){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){path=maybeStripScheme(path);return[2,new Promise(function(resolve,reject){var openRequest=_this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);openRequest.onupgradeneeded=function(){return setUpDatabase(openRequest)};openRequest.onsuccess=function(){var db=openRequest.result;var infoTx=db.transaction(INFO_STORE_NAME,"readwrite");var infoStore=infoTx.objectStore(INFO_STORE_NAME);var getInfoRequest=infoStore.get(path);var modelTx;getInfoRequest.onsuccess=function(){if(getInfoRequest.result==null){db.close();return reject(new Error("Cannot find model with path '"+path+"' "+"in IndexedDB."))}else{var deleteInfoRequest=infoStore.delete(path);var deleteModelData_1=function(){modelTx=db.transaction(MODEL_STORE_NAME,"readwrite");var modelStore=modelTx.objectStore(MODEL_STORE_NAME);var deleteModelRequest=modelStore.delete(path);deleteModelRequest.onsuccess=function(){return resolve(getInfoRequest.result.modelArtifactsInfo)};deleteModelRequest.onerror=function(error){return reject(getInfoRequest.error)}};deleteInfoRequest.onsuccess=deleteModelData_1;deleteInfoRequest.onerror=function(error){deleteModelData_1();db.close();return reject(getInfoRequest.error)}}};getInfoRequest.onerror=function(error){db.close();return reject(getInfoRequest.error)};infoTx.oncomplete=function(){if(modelTx==null){db.close()}else{modelTx.oncomplete=function(){return db.close()}}}};openRequest.onerror=function(error){return reject(openRequest.error)}})]})})};return BrowserIndexedDBManager}();exports.BrowserIndexedDBManager=BrowserIndexedDBManager;if(environment_1.ENV.get("IS_BROWSER")){try{model_management_1.ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(err){}}},{"../environment":51,"./io_utils":60,"./model_management":62,"./router_registry":64}],59:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});require("./indexed_db");require("./local_storage");var browser_files_1=require("./browser_files");exports.browserFiles=browser_files_1.browserFiles;var browser_http_1=require("./browser_http");exports.browserHTTPRequest=browser_http_1.browserHTTPRequest;var io_utils_1=require("./io_utils");exports.concatenateArrayBuffers=io_utils_1.concatenateArrayBuffers;exports.decodeWeights=io_utils_1.decodeWeights;exports.encodeWeights=io_utils_1.encodeWeights;exports.getModelArtifactsInfoForJSON=io_utils_1.getModelArtifactsInfoForJSON;var passthrough_1=require("./passthrough");exports.fromMemory=passthrough_1.fromMemory;exports.withSaveHandler=passthrough_1.withSaveHandler;var router_registry_1=require("./router_registry");var weights_loader_1=require("./weights_loader");exports.loadWeights=weights_loader_1.loadWeights;var registerSaveRouter=router_registry_1.IORouterRegistry.registerSaveRouter;exports.registerSaveRouter=registerSaveRouter;var registerLoadRouter=router_registry_1.IORouterRegistry.registerLoadRouter;exports.registerLoadRouter=registerLoadRouter;var getSaveHandlers=router_registry_1.IORouterRegistry.getSaveHandlers;exports.getSaveHandlers=getSaveHandlers;var getLoadHandlers=router_registry_1.IORouterRegistry.getLoadHandlers;exports.getLoadHandlers=getLoadHandlers;var model_management_1=require("./model_management");exports.copyModel=model_management_1.copyModel;exports.listModels=model_management_1.listModels;exports.moveModel=model_management_1.moveModel;exports.removeModel=model_management_1.removeModel},{"./browser_files":56,"./browser_http":57,"./indexed_db":58,"./io_utils":60,"./local_storage":61,"./model_management":62,"./passthrough":63,"./router_registry":64,"./weights_loader":66}],60:[function(require,module,exports){(function(Buffer){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var tensor_ops_1=require("../ops/tensor_ops");var util_1=require("../util");var types_1=require("./types");function encodeWeights(tensors){return __awaiter(this,void 0,void 0,function(){var specs,dataPromises,name_1,t,tensorValues;return __generator(this,function(_a){switch(_a.label){case 0:specs=[];dataPromises=[];for(name_1 in tensors){t=tensors[name_1];if(t.dtype!=="float32"&&t.dtype!=="int32"&&t.dtype!=="bool"){throw new Error("Unsupported dtype in weight '"+name_1+"': "+t.dtype)}specs.push({name:name_1,shape:t.shape,dtype:t.dtype});dataPromises.push(t.data())}return[4,Promise.all(dataPromises)];case 1:tensorValues=_a.sent();return[2,{data:concatenateTypedArrays(tensorValues),specs:specs}]}})})}exports.encodeWeights=encodeWeights;function decodeWeights(buffer,specs){var out={};var offset=0;var _loop_1=function(spec){var name_2=spec.name;var dtype=spec.dtype;var shape=spec.shape;var size=util_1.sizeFromShape(shape);var typedArray=void 0;if("quantization"in spec){var quantization_1=spec.quantization;if(quantization_1.dtype!=="uint8"&&quantization_1.dtype!=="uint16"){throw new Error("Weight "+spec.name+" has unknown "+("quantization dtype "+quantization_1.dtype+". ")+"Supported quantization dtypes are: 'uint8' and 'uint16'.")}var quantizationSizeFactor=types_1.DTYPE_VALUE_SIZE_MAP[quantization_1.dtype];var byteBuffer=buffer.slice(offset,offset+size*quantizationSizeFactor);var quantizedArray=quantization_1.dtype==="uint8"?new Uint8Array(byteBuffer):new Uint16Array(byteBuffer);if(dtype==="float32"){typedArray=Float32Array.from(quantizedArray,function(v){return v*quantization_1.scale+quantization_1.min})}else if(dtype==="int32"){typedArray=Int32Array.from(quantizedArray,function(v){return Math.round(v*quantization_1.scale+quantization_1.min)})}else{throw new Error("Unsupported dtype in weight '"+name_2+"': "+dtype)}offset+=size*quantizationSizeFactor}else{var dtypeFactor=types_1.DTYPE_VALUE_SIZE_MAP[dtype];var byteBuffer=buffer.slice(offset,offset+size*dtypeFactor);if(dtype==="float32"){typedArray=new Float32Array(byteBuffer)}else if(dtype==="int32"){typedArray=new Int32Array(byteBuffer)}else if(dtype==="bool"){typedArray=new Uint8Array(byteBuffer)}else{throw new Error("Unsupported dtype in weight '"+name_2+"': "+dtype)}offset+=size*dtypeFactor}var value=void 0;if(dtype==="float32"){value=tensor_ops_1.tensor(typedArray,shape,"float32")}else if(dtype==="int32"){value=tensor_ops_1.tensor(typedArray,shape,"int32")}else if(dtype==="bool"){value=tensor_ops_1.tensor(typedArray,shape,"bool")}else{throw new Error("Unsupported dtype in weight '"+name_2+"': "+dtype)}out[name_2]=value};for(var _i=0,specs_1=specs;_i<specs_1.length;_i++){var spec=specs_1[_i];_loop_1(spec)}return out}exports.decodeWeights=decodeWeights;function concatenateTypedArrays(xs){if(xs===null){throw new Error("Invalid input value: "+JSON.stringify(xs))}var totalByteLength=0;var normalizedXs=[];xs.forEach(function(x){totalByteLength+=x.byteLength;normalizedXs.push(x.byteLength===x.buffer.byteLength?x:new x.constructor(x));if(!(x instanceof Float32Array||x instanceof Int32Array||x instanceof Uint8Array)){throw new Error("Unsupported TypedArray subtype: "+x.constructor.name)}});var y=new Uint8Array(totalByteLength);var offset=0;normalizedXs.forEach(function(x){y.set(new Uint8Array(x.buffer),offset);offset+=x.byteLength});return y.buffer}exports.concatenateTypedArrays=concatenateTypedArrays;var useNodeBuffer=typeof Buffer!=="undefined"&&(typeof Blob==="undefined"||typeof atob==="undefined"||typeof btoa==="undefined");function stringByteLength(str){if(useNodeBuffer){return Buffer.byteLength(str)}return new Blob([str]).size}exports.stringByteLength=stringByteLength;function arrayBufferToBase64String(buffer){if(useNodeBuffer){return Buffer.from(buffer).toString("base64")}return btoa(String.fromCharCode.apply(null,new Uint8Array(buffer)))}exports.arrayBufferToBase64String=arrayBufferToBase64String;function base64StringToArrayBuffer(str){if(useNodeBuffer){var buf=Buffer.from(str,"base64");return buf.buffer.slice(buf.byteOffset,buf.byteOffset+buf.byteLength)}var s=atob(str);var buffer=new Uint8Array(s.length);for(var i=0;i<s.length;++i){buffer.set([s.charCodeAt(i)],i)}return buffer.buffer}exports.base64StringToArrayBuffer=base64StringToArrayBuffer;function concatenateArrayBuffers(buffers){var totalByteLength=0;buffers.forEach(function(buffer){totalByteLength+=buffer.byteLength});var temp=new Uint8Array(totalByteLength);var offset=0;buffers.forEach(function(buffer){temp.set(new Uint8Array(buffer),offset);offset+=buffer.byteLength});return temp.buffer}exports.concatenateArrayBuffers=concatenateArrayBuffers;function basename(path){var SEPARATOR="/";path=path.trim();while(path.endsWith(SEPARATOR)){path=path.slice(0,path.length-1)}var items=path.split(SEPARATOR);return items[items.length-1]}exports.basename=basename;function getModelArtifactsInfoForJSON(modelArtifacts){if(modelArtifacts.modelTopology instanceof ArrayBuffer){throw new Error("Expected JSON model topology, received ArrayBuffer.")}return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:modelArtifacts.modelTopology==null?0:stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),weightSpecsBytes:modelArtifacts.weightSpecs==null?0:stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),weightDataBytes:modelArtifacts.weightData==null?0:modelArtifacts.weightData.byteLength}}exports.getModelArtifactsInfoForJSON=getModelArtifactsInfoForJSON}).call(this,require("buffer").Buffer)},{"../ops/tensor_ops":162,"../util":185,"./types":65,buffer:241}],61:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var util_1=require("../util");var io_utils_1=require("./io_utils");var model_management_1=require("./model_management");var router_registry_1=require("./router_registry");var PATH_SEPARATOR="/";var PATH_PREFIX="tensorflowjs_models";var INFO_SUFFIX="info";var MODEL_TOPOLOGY_SUFFIX="model_topology";var WEIGHT_SPECS_SUFFIX="weight_specs";var WEIGHT_DATA_SUFFIX="weight_data";function purgeLocalStorageArtifacts(){if(!environment_1.ENV.get("IS_BROWSER")||typeof window.localStorage==="undefined"){throw new Error("purgeLocalStorageModels() cannot proceed because local storage is "+"unavailable in the current environment.")}var LS=window.localStorage;var purgedModelPaths=[];for(var i=0;i<LS.length;++i){var key=LS.key(i);var prefix=PATH_PREFIX+PATH_SEPARATOR;if(key.startsWith(prefix)&&key.length>prefix.length){LS.removeItem(key);var modelName=getModelPathFromKey(key);if(purgedModelPaths.indexOf(modelName)===-1){purgedModelPaths.push(modelName)}}}return purgedModelPaths}exports.purgeLocalStorageArtifacts=purgeLocalStorageArtifacts;function getModelKeys(path){return{info:[PATH_PREFIX,path,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,path,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,path,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,path,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)}}function getModelPathFromKey(key){var items=key.split(PATH_SEPARATOR);if(items.length<3){throw new Error("Invalid key format: "+key)}return items.slice(1,items.length-1).join(PATH_SEPARATOR)}function maybeStripScheme(key){return key.startsWith(BrowserLocalStorage.URL_SCHEME)?key.slice(BrowserLocalStorage.URL_SCHEME.length):key}var BrowserLocalStorage=function(){function BrowserLocalStorage(modelPath){if(!environment_1.ENV.get("IS_BROWSER")||typeof window.localStorage==="undefined"){throw new Error("The current environment does not support local storage.")}this.LS=window.localStorage;if(modelPath==null||!modelPath){throw new Error("For local storage, modelPath must not be null, undefined or empty.")}this.modelPath=modelPath;this.keys=getModelKeys(this.modelPath)}BrowserLocalStorage.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){var topology,weightSpecs,modelArtifactsInfo,key;return __generator(this,function(_a){if(modelArtifacts.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}else{topology=JSON.stringify(modelArtifacts.modelTopology);weightSpecs=JSON.stringify(modelArtifacts.weightSpecs);modelArtifactsInfo=io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);try{this.LS.setItem(this.keys.info,JSON.stringify(modelArtifactsInfo));this.LS.setItem(this.keys.topology,topology);this.LS.setItem(this.keys.weightSpecs,weightSpecs);this.LS.setItem(this.keys.weightData,io_utils_1.arrayBufferToBase64String(modelArtifacts.weightData));return[2,{modelArtifactsInfo:modelArtifactsInfo}]}catch(err){for(key in this.keys){this.LS.removeItem(this.keys[key])}throw new Error("Failed to save model '"+this.modelPath+"' to local storage: "+"size quota being exceeded is a possible cause of this failure: "+("modelTopologyBytes="+modelArtifactsInfo.modelTopologyBytes+", ")+("weightSpecsBytes="+modelArtifactsInfo.weightSpecsBytes+", ")+("weightDataBytes="+modelArtifactsInfo.weightDataBytes+"."))}}return[2]})})};BrowserLocalStorage.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var info,out,topology,weightSpecs,weightDataBase64;return __generator(this,function(_a){info=JSON.parse(this.LS.getItem(this.keys.info));if(info==null){throw new Error("In local storage, there is no model with name '"+this.modelPath+"'")}if(info.modelTopologyType!=="JSON"){throw new Error("BrowserLocalStorage does not support loading non-JSON model "+"topology yet.")}out={};topology=JSON.parse(this.LS.getItem(this.keys.topology));if(topology==null){throw new Error("In local storage, the topology of model '"+this.modelPath+"' "+"is missing.")}out.modelTopology=topology;weightSpecs=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(weightSpecs==null){throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' "+"are missing.")}out.weightSpecs=weightSpecs;weightDataBase64=this.LS.getItem(this.keys.weightData);if(weightDataBase64==null){throw new Error("In local storage, the binary weight values of model "+("'"+this.modelPath+"' are missing."))}out.weightData=io_utils_1.base64StringToArrayBuffer(weightDataBase64);return[2,out]})})};BrowserLocalStorage.URL_SCHEME="localstorage://";return BrowserLocalStorage}();exports.BrowserLocalStorage=BrowserLocalStorage;exports.localStorageRouter=function(url){if(!environment_1.ENV.get("IS_BROWSER")){return null}else{if(!Array.isArray(url)&&url.startsWith(BrowserLocalStorage.URL_SCHEME)){return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length))}else{return null}}};router_registry_1.IORouterRegistry.registerSaveRouter(exports.localStorageRouter);router_registry_1.IORouterRegistry.registerLoadRouter(exports.localStorageRouter);function browserLocalStorage(modelPath){return new BrowserLocalStorage(modelPath)}exports.browserLocalStorage=browserLocalStorage;var BrowserLocalStorageManager=function(){function BrowserLocalStorageManager(){util_1.assert(environment_1.ENV.get("IS_BROWSER"),"Current environment is not a web browser");util_1.assert(typeof window.localStorage!=="undefined","Current browser does not appear to support localStorage");this.LS=window.localStorage}BrowserLocalStorageManager.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var out,prefix,suffix,i,key,modelPath;return __generator(this,function(_a){out={};prefix=PATH_PREFIX+PATH_SEPARATOR;suffix=PATH_SEPARATOR+INFO_SUFFIX;for(i=0;i<this.LS.length;++i){key=this.LS.key(i);if(key.startsWith(prefix)&&key.endsWith(suffix)){modelPath=getModelPathFromKey(key);out[modelPath]=JSON.parse(this.LS.getItem(key))}}return[2,out]})})};BrowserLocalStorageManager.prototype.removeModel=function(path){return __awaiter(this,void 0,void 0,function(){var keys,info;return __generator(this,function(_a){path=maybeStripScheme(path);keys=getModelKeys(path);if(this.LS.getItem(keys.info)==null){throw new Error("Cannot find model at path '"+path+"'")}info=JSON.parse(this.LS.getItem(keys.info));this.LS.removeItem(keys.info);this.LS.removeItem(keys.topology);this.LS.removeItem(keys.weightSpecs);this.LS.removeItem(keys.weightData);return[2,info]})})};return BrowserLocalStorageManager}();exports.BrowserLocalStorageManager=BrowserLocalStorageManager;if(environment_1.ENV.get("IS_BROWSER")){try{model_management_1.ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(err){}}},{"../environment":51,"../util":185,"./io_utils":60,"./model_management":62,"./router_registry":64}],62:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var util_1=require("../util");var router_registry_1=require("./router_registry");var URL_SCHEME_SUFFIX="://";var ModelStoreManagerRegistry=function(){function ModelStoreManagerRegistry(){this.managers={}}ModelStoreManagerRegistry.getInstance=function(){if(ModelStoreManagerRegistry.instance==null){ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry}return ModelStoreManagerRegistry.instance};ModelStoreManagerRegistry.registerManager=function(scheme,manager){util_1.assert(scheme!=null,"scheme must not be undefined or null.");if(scheme.endsWith(URL_SCHEME_SUFFIX)){scheme=scheme.slice(0,scheme.indexOf(URL_SCHEME_SUFFIX))}util_1.assert(scheme.length>0,"scheme must not be an empty string.");var registry=ModelStoreManagerRegistry.getInstance();util_1.assert(registry.managers[scheme]==null,"A model store manager is already registered for scheme '"+scheme+"'.");registry.managers[scheme]=manager};ModelStoreManagerRegistry.getManager=function(scheme){var manager=this.getInstance().managers[scheme];if(manager==null){throw new Error("Cannot find model manager for scheme '"+scheme+"'")}return manager};ModelStoreManagerRegistry.getSchemes=function(){return Object.keys(this.getInstance().managers)};return ModelStoreManagerRegistry}();exports.ModelStoreManagerRegistry=ModelStoreManagerRegistry;function parseURL(url){if(url.indexOf(URL_SCHEME_SUFFIX)===-1){throw new Error("The url string provided does not contain a scheme. "+"Supported schemes are: "+(""+ModelStoreManagerRegistry.getSchemes().join(",")))}return{scheme:url.split(URL_SCHEME_SUFFIX)[0],path:url.split(URL_SCHEME_SUFFIX)[1]}}function cloneModelInternal(sourceURL,destURL,deleteSource){if(deleteSource===void 0){deleteSource=false}return __awaiter(this,void 0,void 0,function(){var loadHandlers,loadHandler,saveHandlers,saveHandler,sourceScheme,sourcePath,sameMedium,modelArtifacts,saveResult;return __generator(this,function(_a){switch(_a.label){case 0:util_1.assert(sourceURL!==destURL,"Old path and new path are the same: '"+sourceURL+"'");loadHandlers=router_registry_1.IORouterRegistry.getLoadHandlers(sourceURL);util_1.assert(loadHandlers.length>0,"Copying failed because no load handler is found for source URL "+sourceURL+".");util_1.assert(loadHandlers.length<2,"Copying failed because more than one ("+loadHandlers.length+") "+("load handlers for source URL "+sourceURL+"."));loadHandler=loadHandlers[0];saveHandlers=router_registry_1.IORouterRegistry.getSaveHandlers(destURL);util_1.assert(saveHandlers.length>0,"Copying failed because no save handler is found for destination URL "+(destURL+"."));util_1.assert(saveHandlers.length<2,"Copying failed because more than one ("+loadHandlers.length+") "+("save handlers for destination URL "+destURL+"."));saveHandler=saveHandlers[0];sourceScheme=parseURL(sourceURL).scheme;sourcePath=parseURL(sourceURL).path;sameMedium=sourceScheme===parseURL(sourceURL).scheme;return[4,loadHandler.load()];case 1:modelArtifacts=_a.sent();if(!(deleteSource&&sameMedium))return[3,3];return[4,ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath)];case 2:_a.sent();_a.label=3;case 3:return[4,saveHandler.save(modelArtifacts)];case 4:saveResult=_a.sent();if(!(deleteSource&&!sameMedium))return[3,6];return[4,ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath)];case 5:_a.sent();_a.label=6;case 6:return[2,saveResult.modelArtifactsInfo]}})})}function listModels(){return __awaiter(this,void 0,void 0,function(){var schemes,out,_i,schemes_1,scheme,schemeOut,path,url;return __generator(this,function(_a){switch(_a.label){case 0:schemes=ModelStoreManagerRegistry.getSchemes();out={};_i=0,schemes_1=schemes;_a.label=1;case 1:if(!(_i<schemes_1.length))return[3,4];scheme=schemes_1[_i];return[4,ModelStoreManagerRegistry.getManager(scheme).listModels()];case 2:schemeOut=_a.sent();for(path in schemeOut){url=scheme+URL_SCHEME_SUFFIX+path;out[url]=schemeOut[path]}_a.label=3;case 3:_i++;return[3,1];case 4:return[2,out]}})})}exports.listModels=listModels;function removeModel(url){return __awaiter(this,void 0,void 0,function(){var schemeAndPath,manager;return __generator(this,function(_a){switch(_a.label){case 0:schemeAndPath=parseURL(url);manager=ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);return[4,manager.removeModel(schemeAndPath.path)];case 1:return[2,_a.sent()]}})})}exports.removeModel=removeModel;function copyModel(sourceURL,destURL){return __awaiter(this,void 0,void 0,function(){var deleteSource;return __generator(this,function(_a){switch(_a.label){case 0:deleteSource=false;return[4,cloneModelInternal(sourceURL,destURL,deleteSource)];case 1:return[2,_a.sent()]}})})}exports.copyModel=copyModel;function moveModel(sourceURL,destURL){return __awaiter(this,void 0,void 0,function(){var deleteSource;return __generator(this,function(_a){switch(_a.label){case 0:deleteSource=true;return[4,cloneModelInternal(sourceURL,destURL,deleteSource)];case 1:return[2,_a.sent()]}})})}exports.moveModel=moveModel},{"../util":185,"./router_registry":64}],63:[function(require,module,exports){"use strict";var __assign=this&&this.__assign||Object.assign||function(t){for(var s,i=1,n=arguments.length;i<n;i++){s=arguments[i];for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p))t[p]=s[p]}return t};var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var PassthroughLoader=function(){function PassthroughLoader(modelTopology,weightSpecs,weightData){this.modelTopology=modelTopology;this.weightSpecs=weightSpecs;this.weightData=weightData}PassthroughLoader.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var result;return __generator(this,function(_a){result={};if(this.modelTopology!=null){result=__assign({modelTopology:this.modelTopology},result)}if(this.weightSpecs!=null&&this.weightSpecs.length>0){result=__assign({weightSpecs:this.weightSpecs},result)}if(this.weightData!=null&&this.weightData.byteLength>0){result=__assign({weightData:this.weightData},result)}return[2,result]})})};return PassthroughLoader}();var PassthroughSaver=function(){function PassthroughSaver(saveHandler){this.saveHandler=saveHandler}PassthroughSaver.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.saveHandler(modelArtifacts)]})})};return PassthroughSaver}();function fromMemory(modelTopology,weightSpecs,weightData){return new PassthroughLoader(modelTopology,weightSpecs,weightData)}exports.fromMemory=fromMemory;function withSaveHandler(saveHandler){return new PassthroughSaver(saveHandler)}exports.withSaveHandler=withSaveHandler},{}],64:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var IORouterRegistry=function(){function IORouterRegistry(){this.saveRouters=[];this.loadRouters=[]}IORouterRegistry.getInstance=function(){if(IORouterRegistry.instance==null){IORouterRegistry.instance=new IORouterRegistry}return IORouterRegistry.instance};IORouterRegistry.registerSaveRouter=function(saveRouter){IORouterRegistry.getInstance().saveRouters.push(saveRouter)};IORouterRegistry.registerLoadRouter=function(loadRouter){IORouterRegistry.getInstance().loadRouters.push(loadRouter)};IORouterRegistry.getSaveHandlers=function(url){return IORouterRegistry.getHandlers(url,"save")};IORouterRegistry.getLoadHandlers=function(url){return IORouterRegistry.getHandlers(url,"load")};IORouterRegistry.getHandlers=function(url,handlerType){var validHandlers=[];var routers=handlerType==="load"?this.getInstance().loadRouters:this.getInstance().saveRouters;routers.forEach(function(router){var handler=router(url);if(handler!==null){validHandlers.push(handler)}});return validHandlers};return IORouterRegistry}();exports.IORouterRegistry=IORouterRegistry},{}],65:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.DTYPE_VALUE_SIZE_MAP={float32:4,int32:4,uint16:2,uint8:1,bool:1}},{}],66:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");var io_utils_1=require("./io_utils");var types_1=require("./types");function loadWeightsAsArrayBuffer(fetchURLs,requestOptions){return __awaiter(this,void 0,void 0,function(){var requests,responses,buffers;return __generator(this,function(_a){switch(_a.label){case 0:requests=fetchURLs.map(function(fetchURL){return fetch(fetchURL,requestOptions)});return[4,Promise.all(requests)];case 1:responses=_a.sent();return[4,Promise.all(responses.map(function(response){return response.arrayBuffer()}))];case 2:buffers=_a.sent();return[2,buffers]}})})}exports.loadWeightsAsArrayBuffer=loadWeightsAsArrayBuffer;function loadWeights(manifest,filePathPrefix,weightNames,requestOptions){if(filePathPrefix===void 0){filePathPrefix=""}return __awaiter(this,void 0,void 0,function(){var groupIndicesToFetchMap,groupWeightsToFetch,weightsFound,allManifestWeightNames,weightsNotFound,groupIndicesToFetch,fetchUrls,buffers,weightsTensorMap,bufferIndexOffset;return __generator(this,function(_a){switch(_a.label){case 0:groupIndicesToFetchMap=manifest.map(function(){return false});groupWeightsToFetch={};weightsFound=weightNames!=null?weightNames.map(function(){return false}):[];allManifestWeightNames=[];manifest.forEach(function(manifestGroupConfig,groupIndex){var groupOffset=0;manifestGroupConfig.weights.forEach(function(weightsEntry){var rawDtype="quantization"in weightsEntry?weightsEntry.quantization.dtype:weightsEntry.dtype;var weightsBytes=types_1.DTYPE_VALUE_SIZE_MAP[rawDtype]*util.sizeFromShape(weightsEntry.shape);var enqueueWeightsForFetchingFn=function(){groupIndicesToFetchMap[groupIndex]=true;if(groupWeightsToFetch[groupIndex]==null){groupWeightsToFetch[groupIndex]=[]}groupWeightsToFetch[groupIndex].push({manifestEntry:weightsEntry,groupOffset:groupOffset,sizeBytes:weightsBytes})};if(weightNames!=null){weightNames.forEach(function(weightName,weightIndex){if(weightName===weightsEntry.name){enqueueWeightsForFetchingFn();weightsFound[weightIndex]=true}})}else{enqueueWeightsForFetchingFn()}allManifestWeightNames.push(weightsEntry.name);groupOffset+=weightsBytes})});if(!weightsFound.every(function(found){return found})){weightsNotFound=weightNames.filter(function(weight,i){return!weightsFound[i]});throw new Error("Could not find weights in manifest with names: "+(weightsNotFound.join(", ")+". \n")+"Manifest JSON has weights with names: "+(allManifestWeightNames.join(", ")+"."))}groupIndicesToFetch=groupIndicesToFetchMap.reduce(function(accumulator,shouldFetch,i){if(shouldFetch){accumulator.push(i)}return accumulator},[]);fetchUrls=[];groupIndicesToFetch.forEach(function(i){manifest[i].paths.forEach(function(filepath){var fetchUrl=filePathPrefix+(!filePathPrefix.endsWith("/")?"/":"")+filepath;fetchUrls.push(fetchUrl)})});return[4,loadWeightsAsArrayBuffer(fetchUrls,requestOptions)];case 1:buffers=_a.sent();weightsTensorMap={};bufferIndexOffset=0;groupIndicesToFetch.forEach(function(i){var numBuffers=manifest[i].paths.length;var groupBytes=0;for(var i_1=0;i_1<numBuffers;i_1++){groupBytes+=buffers[bufferIndexOffset+i_1].byteLength}var groupBuffer=new ArrayBuffer(groupBytes);var groupByteBuffer=new Uint8Array(groupBuffer);var groupBufferOffset=0;for(var i_2=0;i_2<numBuffers;i_2++){var buffer=new Uint8Array(buffers[bufferIndexOffset+i_2]);groupByteBuffer.set(buffer,groupBufferOffset);groupBufferOffset+=buffer.byteLength}var weightsEntries=groupWeightsToFetch[i];weightsEntries.forEach(function(weightsEntry){var byteBuffer=groupBuffer.slice(weightsEntry.groupOffset,weightsEntry.groupOffset+weightsEntry.sizeBytes);var nameToTensorMap=io_utils_1.decodeWeights(byteBuffer,[weightsEntry.manifestEntry]);for(var name_1 in nameToTensorMap){weightsTensorMap[name_1]=nameToTensorMap[name_1]}});bufferIndexOffset+=numBuffers});return[2,weightsTensorMap]}})})}exports.loadWeights=loadWeights},{"../util":185,"./io_utils":60,"./types":65}],67:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var DataStorage=function(){function DataStorage(dataMover){this.dataMover=dataMover;this.data=new WeakMap}DataStorage.prototype.get=function(dataId){if(!this.data.has(dataId)){this.dataMover.moveData(dataId)}return this.data.get(dataId)};DataStorage.prototype.set=function(dataId,value){this.data.set(dataId,value)};DataStorage.prototype.has=function(dataId){return this.data.has(dataId)};DataStorage.prototype.delete=function(dataId){return this.data.delete(dataId)};return DataStorage}();exports.DataStorage=DataStorage},{}],68:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var seedrandom=require("seedrandom");var environment_1=require("../environment");var log_1=require("../log");var array_ops_util=require("../ops/array_ops_util");var axis_util=require("../ops/axis_util");var broadcast_util=require("../ops/broadcast_util");var concat_util=require("../ops/concat_util");var erf_util=require("../ops/erf_util");var ops=require("../ops/ops");var ops_1=require("../ops/ops");var selu_util=require("../ops/selu_util");var slice_util_1=require("../ops/slice_util");var tensor_1=require("../tensor");var types_1=require("../types");var util=require("../util");var util_1=require("../util");var backend_1=require("./backend");var backend_util=require("./backend_util");var complex_util=require("./complex_util");var non_max_suppression_impl_1=require("./non_max_suppression_impl");var split_shared_1=require("./split_shared");var topk_impl_1=require("./topk_impl");var where_impl_1=require("./where_impl");var MathBackendCPU=function(){function MathBackendCPU(){this.blockSize=48;this.firstUse=true;if(environment_1.ENV.get("IS_BROWSER")){this.canvas=document.createElement("canvas")}}MathBackendCPU.prototype.setDataMover=function(dataMover){this.data=new backend_1.DataStorage(dataMover)};MathBackendCPU.prototype.register=function(dataId,shape,dtype){if(this.firstUse){this.firstUse=false;if(environment_1.ENV.get("IS_NODE")){log_1.warn("\n============================\n"+"Hi there 👋. Looks like you are running TensorFlow.js in "+"Node.js. To speed things up dramatically, install our node "+"backend, which binds to TensorFlow C++, by running "+"npm i @tensorflow/tfjs-node, "+"or npm i @tensorflow/tfjs-node-gpu if you have CUDA. "+"Then call require('@tensorflow/tfjs-node'); (-gpu "+"suffix for CUDA) at the start of your program. "+"Visit https://github.com/tensorflow/tfjs-node for more details."+"\n============================\n")}}if(this.data.has(dataId)){throw new Error("Data buffer is already registered")}this.data.set(dataId,{dtype:dtype})};MathBackendCPU.prototype.write=function(dataId,values){if(values==null){throw new Error("MathBackendCPU.write(): values can not be null")}this.data.get(dataId).values=values};MathBackendCPU.prototype.fromPixels=function(pixels,numChannels){if(pixels==null){throw new Error("pixels passed to tf.fromPixels() can not be null")}var vals;if(environment_1.ENV.get("IS_NODE")&&pixels.getContext==null){throw new Error("When running in node, pixels must be an HTMLCanvasElement "+"like the one returned by the `canvas` npm package")}if(pixels.getContext!=null){vals=pixels.getContext("2d").getImageData(0,0,pixels.width,pixels.height).data}else if(pixels instanceof ImageData){vals=pixels.data}else if(pixels instanceof HTMLImageElement||pixels instanceof HTMLVideoElement){if(this.canvas==null){throw new Error("Can't read pixels from HTMLImageElement outside "+"the browser.")}this.canvas.width=pixels.width;this.canvas.height=pixels.height;this.canvas.getContext("2d").drawImage(pixels,0,0,pixels.width,pixels.height);vals=this.canvas.getContext("2d").getImageData(0,0,pixels.width,pixels.height).data}else{throw new Error("pixels passed to tf.fromPixels() must be either an "+"HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or "+("ImageData, but was "+pixels.constructor.name))}var values;if(numChannels===4){values=new Int32Array(vals)}else{var numPixels=pixels.width*pixels.height;values=new Int32Array(numPixels*numChannels);for(var i=0;i<numPixels;i++){for(var channel=0;channel<numChannels;++channel){values[i*numChannels+channel]=vals[i*4+channel]}}}var outShape=[pixels.height,pixels.width,numChannels];return ops_1.tensor3d(values,outShape,"int32")};MathBackendCPU.prototype.read=function(dataId){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.readSync(dataId)]})})};MathBackendCPU.prototype.readSync=function(dataId){var _a=this.data.get(dataId),dtype=_a.dtype,complexTensors=_a.complexTensors;if(dtype==="complex64"){var realValues=complexTensors.real.dataSync();var imagValues=complexTensors.imag.dataSync();return complex_util.mergeRealAndImagArrays(realValues,imagValues)}return this.data.get(dataId).values};MathBackendCPU.prototype.disposeData=function(dataId){if(this.data.has(dataId)){var complexTensors=this.data.get(dataId).complexTensors;if(complexTensors!=null){complexTensors.real.dispose();complexTensors.imag.dispose()}this.data.delete(dataId)}};MathBackendCPU.prototype.time=function(f){return __awaiter(this,void 0,void 0,function(){var start,kernelMs;return __generator(this,function(_a){start=util_1.now();f();kernelMs=util_1.now()-start;return[2,{kernelMs:kernelMs}]})})};MathBackendCPU.prototype.memory=function(){return{unreliable:true}};MathBackendCPU.prototype.complex=function(real,imag){var result=tensor_1.Tensor.make(real.shape,{},"complex64");var resultData=this.data.get(result.dataId);resultData.complexTensors={real:environment_1.ENV.engine.keep(real.clone()),imag:environment_1.ENV.engine.keep(imag.clone())};return result};MathBackendCPU.prototype.real=function(input){var resultData=this.data.get(input.dataId);return resultData.complexTensors.real.clone()};MathBackendCPU.prototype.imag=function(input){var resultData=this.data.get(input.dataId);return resultData.complexTensors.imag.clone()};MathBackendCPU.prototype.assertNotComplex=function(tensor,opName){if(!Array.isArray(tensor)){tensor=[tensor]}tensor.forEach(function(t){if(t!=null){util.assert(t.dtype!=="complex64",opName+" does not support complex64 tensors.")}})};MathBackendCPU.prototype.slice=function(x,begin,size){this.assertNotComplex(x,"slice");var buffer=ops.buffer(size,x.dtype);for(var i=0;i<buffer.size;++i){var loc=buffer.indexToLoc(i);var xLoc=loc.map(function(idx,j){return idx+begin[j]});buffer.set.apply(buffer,[x.get.apply(x,xLoc)].concat(loc))}return buffer.toTensor()};MathBackendCPU.prototype.stridedSlice=function(x,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){this.assertNotComplex(x,"stridedSlice");var _a=slice_util_1.getStridedSlicedInfo(x.shape,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask),beginIndex=_a[0],size=_a[1],shrinkAxis=_a[2];var shape=size.filter(function(v,index){return shrinkAxis.indexOf(index)===-1});if(shape.some(function(axis){return axis===0})){return ops.tensor([],shape)}var buffer=ops.buffer(size,x.dtype);for(var i=0;i<buffer.size;i++){var loc=buffer.indexToLoc(i);var newLoc=new Array(loc.length);for(var j=0;j<newLoc.length;j++){newLoc[j]=loc[j]*strides[j]+beginIndex[j]}buffer.set.apply(buffer,[x.get.apply(x,newLoc)].concat(loc))}return buffer.toTensor().reshape(shape)};MathBackendCPU.prototype.reverse=function(x,axis){this.assertNotComplex(x,"reverse");var buffer=ops.buffer(x.shape,x.dtype);var xBuffer=x.buffer();var _loop_1=function(i){var outLoc=buffer.indexToLoc(i);var inLoc=outLoc.slice();axis.forEach(function(ax){return inLoc[ax]=x.shape[ax]-1-inLoc[ax]});buffer.set.apply(buffer,[xBuffer.get.apply(xBuffer,inLoc)].concat(outLoc))};for(var i=0;i<buffer.size;i++){_loop_1(i)}return buffer.toTensor()};MathBackendCPU.prototype.concat=function(tensors,axis){this.assertNotComplex(tensors,"concat");var tensors2D=tensors.map(function(t){var innerSize=util.sizeFromShape(t.shape.slice(axis));return t.as2D(-1,innerSize)});var outShape=concat_util.computeOutShape(tensors2D.map(function(t){return t.shape}),1);var values=ops.buffer(outShape,tensors[0].dtype).values;if(tensors2D[0].shape[0]===1){var offset_1=0;tensors2D.forEach(function(t){values.set(t.dataSync(),offset_1);offset_1+=t.size})}else{var colOffset_1=0;tensors2D.forEach(function(t){var tVals=t.dataSync();var tIdx=0;for(var row=0;row<t.shape[0];++row){var resIdx=row*outShape[1]+colOffset_1;for(var col=0;col<t.shape[1];++col){values[resIdx+col]=tVals[tIdx++]}}colOffset_1+=t.shape[1]})}var finalOutShape=concat_util.computeOutShape(tensors.map(function(t){return t.shape}),axis);return ops_1.tensor(values,finalOutShape,tensors[0].dtype)};MathBackendCPU.prototype.neg=function(x){this.assertNotComplex(x,"neg");return this.multiply(ops.scalar(-1),x)};MathBackendCPU.prototype.add=function(a,b){if(a.dtype==="complex64"||b.dtype==="complex64"){return this.broadcastedBinaryComplexOp(a.cast("complex64"),b.cast("complex64"),function(aReal,aImag,bReal,bImag){return{real:aReal+bReal,imag:aImag+bImag}})}return this.broadcastedBinaryOp(a,b,types_1.upcastType(a.dtype,b.dtype),function(aValue,bValue){return aValue+bValue})};MathBackendCPU.prototype.addN=function(tensors){this.assertNotComplex(tensors,"addN");var vals=tensors.map(function(t){return t.dataSync()});var result=ops.buffer(tensors[0].shape,tensors[0].dtype);var resultVals=result.values;for(var i=0;i<tensors.length;i++){var currVals=vals[i];for(var j=0;j<resultVals.length;j++){resultVals[j]+=currVals[j]}}return result.toTensor()};MathBackendCPU.prototype.subtract=function(a,b){if(a.dtype==="complex64"||b.dtype==="complex64"){return this.broadcastedBinaryComplexOp(a.cast("complex64"),b.cast("complex64"),function(aReal,aImag,bReal,bImag){return{real:aReal-bReal,imag:aImag-bImag}})}return this.broadcastedBinaryOp(a,b,types_1.upcastType(a.dtype,b.dtype),function(aValue,bValue){return aValue-bValue})};MathBackendCPU.prototype.pow=function(a,b){this.assertNotComplex([a,b],"pow");return this.broadcastedBinaryOp(a,b,a.dtype,function(aValue,bValue){return Math.pow(aValue,bValue)})};MathBackendCPU.prototype.batchMatMul=function(a,b,transposeA,transposeB){this.assertNotComplex([a,b],"matMul");var sharedDim=transposeA?a.shape[1]:a.shape[2];var leftDim=transposeA?a.shape[2]:a.shape[1];var rightDim=transposeB?b.shape[1]:b.shape[2];var batchDim=a.shape[0];var aValues=a.dataSync();var bValues=b.dataSync();var _a=transposeA?[a.strides[0],1,a.strides[1]]:[a.strides[0],a.strides[1],1],aBatch=_a[0],aOuterStep=_a[1],aInnerStep=_a[2];var _b=transposeB?[1,b.strides[1],b.strides[0]]:[b.strides[1],1,b.strides[0]],bInnerStep=_b[0],bOuterStep=_b[1],bBatch=_b[2];var size=leftDim*rightDim;var result=new Float32Array(batchDim*size);var blockSize=this.blockSize;for(var b_1=0;b_1<batchDim;b_1++){for(var i0=0;i0<leftDim;i0+=blockSize){for(var j0=0;j0<rightDim;j0+=blockSize){for(var k0=0;k0<sharedDim;k0+=blockSize){var iBlock=Math.min(i0+blockSize,leftDim);var jBlock=Math.min(j0+blockSize,rightDim);var kBlock=Math.min(k0+blockSize,sharedDim);for(var i=i0;i<iBlock;i++){for(var j=j0;j<jBlock;j++){var sum=0;for(var k=k0;k<kBlock;k++){sum+=aValues[b_1*aBatch+i*aOuterStep+k*aInnerStep]*bValues[k*bInnerStep+j*bOuterStep+b_1*bBatch]}result[b_1*size+(i*rightDim+j)]+=sum}}}}}}return ops.tensor3d(result,[batchDim,leftDim,rightDim])};MathBackendCPU.prototype.multiply=function(a,b){if(a.dtype==="complex64"||b.dtype==="complex64"){return this.broadcastedBinaryComplexOp(a.cast("complex64"),b.cast("complex64"),function(aReal,aImag,bReal,bImag){return{real:aReal*bReal-aImag*bImag,imag:aReal*bImag+aImag*bReal}})}return this.broadcastedBinaryOp(a,b,types_1.upcastType(a.dtype,b.dtype),function(aValue,bValue){return aValue*bValue})};MathBackendCPU.prototype.realDivide=function(a,b){this.assertNotComplex([a,b],"realDivide");var op=function(a,b){return a/b};var outputDtype="float32";return this.broadcastedBinaryOp(a,b,outputDtype,op)};MathBackendCPU.prototype.floorDiv=function(a,b){this.assertNotComplex([a,b],"floorDiv");var op=function(a,b){return Math.floor(a/b)};var outputDtype="int32";return this.broadcastedBinaryOp(a,b,outputDtype,op)};MathBackendCPU.prototype.sum=function(x,axes){this.assertNotComplex(x,"sum");axis_util.assertAxesAreInnerMostDims("sum",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var resultDtype=types_1.upcastType(x.dtype,"int32");var result=ops.zeros(outShape,resultDtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var sum=0;for(var j=0;j<reduceSize;++j){sum+=aVals[offset+j]}vals[i]=sum}return result};MathBackendCPU.prototype.unsortedSegmentSum=function(x,segmentIds,numSegments){this.assertNotComplex(x,"unsortedSegmentSum");var res=[];var numIters=x.rank-segmentIds.rank;for(var i=0;i<numIters;++i){segmentIds=segmentIds.expandDims(i+1)}for(var i=0;i<numSegments;++i){var segmentId=ops.scalar(i,"int32");var mask=ops.equal(segmentId,segmentIds).asType("float32");var sum=mask.mul(x).sum(0);res.push(sum)}return ops.stack(res)};MathBackendCPU.prototype.argMin=function(x,axis){this.assertNotComplex(x,"argMin");var axes=[axis];axis_util.assertAxesAreInnerMostDims("argMin",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ops.zeros(outShape,"int32");var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var min=aVals[offset];var minIndex=0;for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(value<min){min=value;minIndex=j}}vals[i]=minIndex}return result};MathBackendCPU.prototype.argMax=function(x,axis){this.assertNotComplex(x,"argMax");var axes=[axis];axis_util.assertAxesAreInnerMostDims("argMax",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ops.zeros(outShape,"int32");var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var max=aVals[offset];var maxIndex=0;for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(value>max){max=value;maxIndex=j}}vals[i]=maxIndex}return result};MathBackendCPU.prototype.cumsum=function(x,axis,exclusive,reverse){this.assertNotComplex(x,"cumsum");if(axis!==x.rank-1){throw new Error("backend.cumsum in CPU expects an inner-most axis="+(x.rank-1)+" "+("but got axis="+axis))}var resultDtype=types_1.upcastType(x.dtype,"int32");var result=ops.zeros(x.shape,resultDtype);var vals=result.dataSync();var aVals=x.dataSync();var finalDim=x.shape[x.rank-1];var indexAdjuster=reverse?function(i,j){return i+finalDim-j-1}:function(i,j){return i+j};for(var i=0;i<aVals.length;i+=finalDim){for(var j=0;j<finalDim;j++){var idx=indexAdjuster(i,j);if(j===0){vals[idx]=exclusive?0:aVals[idx]}else{var prevIdx=indexAdjuster(i,j-1);vals[idx]=exclusive?aVals[prevIdx]+vals[prevIdx]:aVals[idx]+vals[prevIdx]}}}return result};MathBackendCPU.prototype.equal=function(a,b){this.assertNotComplex([a,b],"equal");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal===bVal?1:0})};MathBackendCPU.prototype.notEqual=function(a,b){this.assertNotComplex([a,b],"notEqual");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal!==bVal?1:0})};MathBackendCPU.prototype.less=function(a,b){this.assertNotComplex([a,b],"less");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal<bVal?1:0})};MathBackendCPU.prototype.lessEqual=function(a,b){this.assertNotComplex([a,b],"lessEqual");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal<=bVal?1:0})};MathBackendCPU.prototype.greater=function(a,b){this.assertNotComplex([a,b],"greater");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal>bVal?1:0})};MathBackendCPU.prototype.greaterEqual=function(a,b){this.assertNotComplex([a,b],"greaterEqual");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal>=bVal?1:0})};MathBackendCPU.prototype.logicalNot=function(x){this.assertNotComplex(x,"logicalNot");var values=x.dataSync();var newValues=new Int32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=values[i]?0:1}return tensor_1.Tensor.make(x.shape,{values:newValues},"bool")};MathBackendCPU.prototype.logicalAnd=function(a,b){this.assertNotComplex([a,b],"logicalAnd");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal&&bVal})};MathBackendCPU.prototype.logicalOr=function(a,b){this.assertNotComplex([a,b],"logicalOr");return this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal||bVal})};MathBackendCPU.prototype.select=function(condition,a,b){this.assertNotComplex([condition,a,b],"select");var values=condition.dataSync();var aValues=a.dataSync();var bValues=b.dataSync();var result=ops.zeros(a.shape,types_1.upcastType(a.dtype,b.dtype));var newValues=result.dataSync();var index=0;var offset=condition.rank===0||condition.rank>1||a.rank===1?1:a.shape[1];for(var i=0;i<values.length;i++){for(var j=0;j<offset;j++){if(values[i]===1){newValues[index++]=aValues[i]}else{newValues[index++]=bValues[i]}}}return result};MathBackendCPU.prototype.where=function(condition){this.assertNotComplex([condition],"where");var condVals=condition.dataSync();return where_impl_1.whereImpl(condition.shape,condVals)};MathBackendCPU.prototype.topk=function(x,k,sorted){this.assertNotComplex(x,"topk");var xVals=x.dataSync();return topk_impl_1.topkImpl(xVals,x.shape,x.dtype,k,sorted)};MathBackendCPU.prototype.min=function(x,axes){this.assertNotComplex(x,"min");axis_util.assertAxesAreInnerMostDims("min",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ops.zeros(outShape,x.dtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var min=aVals[offset];for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(value<min){min=value}}vals[i]=min}return result};MathBackendCPU.prototype.minimum=function(a,b){this.assertNotComplex([a,b],"minimum");return this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){return Math.min(aVal,bVal)})};MathBackendCPU.prototype.mod=function(a,b){this.assertNotComplex([a,b],"mod");return this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){var rem=aVal%bVal;if(aVal<0&&bVal<0||aVal>=0&&bVal>=0){return rem}else{return(rem+bVal)%bVal}})};MathBackendCPU.prototype.max=function(x,axes){this.assertNotComplex(x,"max");axis_util.assertAxesAreInnerMostDims("max",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ops.zeros(outShape,x.dtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var max=aVals[offset];for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(value>max){max=value}}vals[i]=max}return result};MathBackendCPU.prototype.maximum=function(a,b){this.assertNotComplex([a,b],"maximum");return this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){return Math.max(aVal,bVal)})};MathBackendCPU.prototype.all=function(x,axes){this.assertNotComplex(x,"all");axis_util.assertAxesAreInnerMostDims("all",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ops.zeros(outShape,x.dtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var all=aVals[offset];for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];all=all&&value}vals[i]=all}return result};MathBackendCPU.prototype.any=function(x,axes){this.assertNotComplex(x,"any");axis_util.assertAxesAreInnerMostDims("any",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ops.zeros(outShape,x.dtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.dataSync();var aVals=x.dataSync();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var anyVal=aVals[offset];for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];anyVal=anyVal||value}vals[i]=anyVal}return result};MathBackendCPU.prototype.squaredDifference=function(a,b){this.assertNotComplex([a,b],"squaredDifference");return this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){var diff=aVal-bVal;return diff*diff})};MathBackendCPU.prototype.ceil=function(x){this.assertNotComplex(x,"ceil");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.ceil(values[i])}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.floor=function(x){this.assertNotComplex(x,"floor");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.floor(values[i])}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.sign=function(x){this.assertNotComplex(x,"x");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){if(values[i]<0){newValues[i]=-1}else if(values[i]>0){newValues[i]=1}else{newValues[i]=0}}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.round=function(x){this.assertNotComplex(x,"round");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var base=Math.floor(values[i]);if(values[i]-base<.5){newValues[i]=Math.floor(values[i])}else if(values[i]-base>.5){newValues[i]=Math.ceil(values[i])}else{if(base%2===0){newValues[i]=base}else{newValues[i]=base+1}}}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.exp=function(x){this.assertNotComplex(x,"exp");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.exp(values[i])}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.expm1=function(x){this.assertNotComplex(x,"expm1");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.expm1(values[i])}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.log=function(x){this.assertNotComplex(x,"log");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.log(value)}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.log1p=function(x){this.assertNotComplex(x,"log1p");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.log1p(value)}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.sqrt=function(x){this.assertNotComplex(x,"sqrt");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.sqrt(value)}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.rsqrt=function(x){this.assertNotComplex(x,"rsqrt");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=1/Math.sqrt(value)}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.square=function(x){this.assertNotComplex(x,"square");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=value*value}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.reciprocal=function(x){this.assertNotComplex(x,"reciprocal");var values=x.dataSync();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=1/values[i]}return tensor_1.Tensor.make(x.shape,{values:newValues})};MathBackendCPU.prototype.relu=function(x){this.assertNotComplex(x,"relu");var res=ops.zeros(x.shape,x.dtype);var resVals=res.dataSync();var inVals=x.dataSync();for(var i=0;i<inVals.length;++i){resVals[i]=Math.max(0,inVals[i])}return res};MathBackendCPU.prototype.elu=function(x){this.assertNotComplex(x,"elu");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){var v=values[i];if(v>=0){resultValues[i]=v}else{resultValues[i]=Math.exp(v)-1}}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.eluDer=function(dy,y){this.assertNotComplex([dy,y],"eluDer");var resultValues=new Float32Array(y.size);var values=y.dataSync();var dyValues=dy.dataSync();for(var i=0;i<values.length;++i){var v=values[i];if(v>=1){resultValues[i]=dyValues[i]}else{resultValues[i]=dyValues[i]*(v+1)}}return tensor_1.Tensor.make(y.shape,{values:resultValues})};MathBackendCPU.prototype.selu=function(x){this.assertNotComplex(x,"selu");var scaleAlpha=selu_util.SELU_SCALEALPHA;var scale=selu_util.SELU_SCALE;var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){var v=values[i];if(v>=0){resultValues[i]=scale*v}else{resultValues[i]=scaleAlpha*(Math.exp(v)-1)}}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.clip=function(x,min,max){this.assertNotComplex(x,"clip");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){var v=values[i];resultValues[i]=v>max?max:v<min?min:v}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.abs=function(x){this.assertNotComplex(x,"abs");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.abs(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.int=function(x){this.assertNotComplex(x,"int");var resultValues=new Int32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=values[i]}return tensor_1.Tensor.make(x.shape,{values:resultValues},"int32")};MathBackendCPU.prototype.sigmoid=function(x){this.assertNotComplex(x,"sigmoid");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=1/(1+Math.exp(-values[i]))}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.softplus=function(x){this.assertNotComplex(x,"softplus");var epsilon=1.1920928955078125e-7;var threshold=Math.log(epsilon)+2;var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){var tooLarge=values[i]>-threshold;var tooSmall=values[i]<threshold;var expX=Math.exp(values[i]);var result=void 0;if(tooSmall){result=expX}else if(tooLarge){result=values[i]}else{result=Math.log(1+expX)}resultValues[i]=result}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.sin=function(x){this.assertNotComplex(x,"sin");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.sin(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.cos=function(x){this.assertNotComplex(x,"cos");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.cos(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.tan=function(x){this.assertNotComplex(x,"tan");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.tan(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.asin=function(x){this.assertNotComplex(x,"asin");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.asin(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.acos=function(x){this.assertNotComplex(x,"acos");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.acos(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.atan=function(x){this.assertNotComplex(x,"atan");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.atan(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.atan2=function(a,b){this.assertNotComplex([a,b],"atan2");return this.broadcastedBinaryOp(a,b,a.dtype,function(aValue,bValue){return Math.atan2(aValue,bValue)})};MathBackendCPU.prototype.sinh=function(x){this.assertNotComplex(x,"sinh");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.sinh(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.cosh=function(x){this.assertNotComplex(x,"cosh");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.cosh(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.tanh=function(x){this.assertNotComplex(x,"tanh");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=util.tanh(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.asinh=function(x){this.assertNotComplex(x,"asinh");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.asinh(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.acosh=function(x){this.assertNotComplex(x,"acosh");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.acosh(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.atanh=function(x){this.assertNotComplex(x,"atanh");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){resultValues[i]=Math.atanh(values[i])}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.erf=function(x){this.assertNotComplex(x,"erf");var resultValues=new Float32Array(x.size);var values=x.dataSync();var p=erf_util.ERF_P;var a1=erf_util.ERF_A1;var a2=erf_util.ERF_A2;var a3=erf_util.ERF_A3;var a4=erf_util.ERF_A4;var a5=erf_util.ERF_A5;for(var i=0;i<values.length;++i){var v=values[i];var t=1/(1+p*v);resultValues[i]=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-v*v)}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.step=function(x,alpha){if(alpha===void 0){alpha=0}this.assertNotComplex(x,"step");var resultValues=new Float32Array(x.size);var values=x.dataSync();for(var i=0;i<values.length;++i){var value=values[i];if(isNaN(value)){resultValues[i]=NaN}else{resultValues[i]=value>0?1:alpha}}return tensor_1.Tensor.make(x.shape,{values:resultValues})};MathBackendCPU.prototype.conv2d=function(x,filter,convInfo){this.assertNotComplex([x,filter],"conv2d");var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var dilationHeight=convInfo.dilationHeight;var dilationWidth=convInfo.dilationWidth;var padLeft=convInfo.padInfo.left;var padTop=convInfo.padInfo.top;var y=ops.buffer(convInfo.outShape,x.dtype);var xVals=x.dataSync();var wVals=filter.dataSync();var yVals=y.values;for(var b=0;b<convInfo.batchSize;++b){var xOffset1=b*x.strides[0];var yOffset1=b*y.strides[0];for(var yR=0;yR<convInfo.outHeight;++yR){var yOffset2=yOffset1+yR*y.strides[1];var xRCorner=yR*convInfo.strideHeight-padLeft;for(var wR=0;wR<filterHeight;wR++){var xR=xRCorner+wR*dilationHeight;if(xR<0||xR>=convInfo.inHeight){continue}var wOffset1=wR*filter.strides[0];var xOffset2=xOffset1+xR*x.strides[1];for(var yC=0;yC<convInfo.outWidth;++yC){var yOffset3=yOffset2+yC*convInfo.outChannels;var xCCorner=yC*convInfo.strideWidth-padTop;for(var wC=0;wC<filterWidth;wC++){var xC=xCCorner+wC*dilationWidth;if(xC<0||xC>=convInfo.inWidth){continue}var wOffset2=wOffset1+wC*filter.strides[1];var xOffset3=xOffset2+xC*convInfo.inChannels;var wOffset3=wOffset2;for(var d1=0;d1<convInfo.inChannels;++d1){var xVal=xVals[xOffset3+d1];for(var d2=0;d2<convInfo.outChannels;++d2){yVals[yOffset3+d2]+=xVal*wVals[wOffset3+d2]}wOffset3+=convInfo.outChannels}}}}}}return y.toTensor()};MathBackendCPU.prototype.conv2dDerInput=function(dy,filter,convInfo){this.assertNotComplex([dy,filter],"conv2dDerInput");var dx=ops.buffer(convInfo.inShape,"float32");var dxValues=dx.values;var _a=dx.strides,dxS0=_a[0],dxS1=_a[1],dxS2=_a[2];var dyValues=dy.dataSync();var _b=dy.strides,dyS0=_b[0],dyS1=_b[1],dyS2=_b[2];var fltValues=filter.dataSync();var _c=filter.strides,fltS0=_c[0],fltS1=_c[1],fltS2=_c[2];var batchSize=convInfo.batchSize,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inChannels=convInfo.inChannels,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth,outChannels=convInfo.outChannels,outHeight=convInfo.outHeight,outWidth=convInfo.outWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth;var topPad=filterHeight-1-convInfo.padInfo.top;var leftPad=filterWidth-1-convInfo.padInfo.left;for(var b=0;b<batchSize;++b){for(var d1=0;d1<inChannels;++d1){for(var xR=0;xR<inHeight;++xR){var xRCorner=xR-topPad;var xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight));var yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight);for(var xC=0;xC<inWidth;++xC){var xCCorner=xC-leftPad;var xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth));var yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth);var dotProd=0;for(var yR=xRMin;yR<yRMax;++yR){var wR=yR*strideHeight-xRCorner;for(var yC=xCMin;yC<yCMax;++yC){var wC=yC*strideWidth-xCCorner;var dyOffset=dyS0*b+dyS1*yR+dyS2*yC;var fltOffset=fltS0*(filterHeight-1-wR)+fltS1*(filterWidth-1-wC)+fltS2*d1;for(var d2=0;d2<outChannels;++d2){var pixel=dyValues[dyOffset+d2];var weight=fltValues[fltOffset+d2];dotProd+=pixel*weight}}}dxValues[dxS0*b+dxS1*xR+dxS2*xC+d1]=dotProd}}}}return dx.toTensor()};MathBackendCPU.prototype.conv2dDerFilter=function(x,dy,convInfo){this.assertNotComplex([x,dy],"conv2dDerFilter");var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var dW=ops.buffer(convInfo.filterShape,"float32");var leftPad=convInfo.padInfo.left;var topPad=convInfo.padInfo.top;for(var wR=0;wR<filterHeight;++wR){var yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight));var yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight);for(var wC=0;wC<filterWidth;++wC){var yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth));var yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth);for(var d1=0;d1<convInfo.inChannels;++d1){for(var d2=0;d2<convInfo.outChannels;++d2){var dotProd=0;for(var b=0;b<convInfo.batchSize;++b){for(var yR=yRMin;yR<yRMax;++yR){var xR=wR+yR*strideHeight-topPad;for(var yC=yCMin;yC<yCMax;++yC){var xC=wC+yC*strideWidth-leftPad;dotProd+=x.get(b,xR,xC,d1)*dy.get(b,yR,yC,d2)}}}dW.set(dotProd,wR,wC,d1,d2)}}}}return dW.toTensor()};MathBackendCPU.prototype.depthwiseConv2D=function(x,filter,convInfo){this.assertNotComplex([x,filter],"depthwiseConv2D");var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var dilationHeight=convInfo.dilationHeight;var dilationWidth=convInfo.dilationWidth;var padLeft=convInfo.padInfo.left;var padTop=convInfo.padInfo.top;var chMul=convInfo.outChannels/convInfo.inChannels;var y=ops.buffer(convInfo.outShape,x.dtype);var xVals=x.dataSync();var wVals=filter.dataSync();var yVals=y.values;for(var b=0;b<convInfo.batchSize;++b){var xOffset1=b*x.strides[0];var yOffset1=b*y.strides[0];for(var yR=0;yR<convInfo.outHeight;++yR){var yOffset2=yOffset1+yR*y.strides[1];var xRCorner=yR*convInfo.strideHeight-padLeft;for(var wR=0;wR<filterHeight;++wR){var xR=xRCorner+wR*dilationHeight;if(xR<0||xR>=convInfo.inHeight){continue}var wOffset1=wR*filter.strides[0];var xOffset2=xOffset1+xR*x.strides[1];for(var yC=0;yC<convInfo.outWidth;++yC){var yOffset3=yOffset2+yC*y.strides[2];var xCCorner=yC*convInfo.strideWidth-padTop;for(var wC=0;wC<filterWidth;++wC){var xC=xCCorner+wC*dilationWidth;if(xC<0||xC>=convInfo.inWidth){continue}var wOffset2=wOffset1+wC*filter.strides[1];var xOffset3=xOffset2+xC*convInfo.inChannels;var yOffset4=yOffset3;var wOffset3=wOffset2;for(var d1=0;d1<convInfo.inChannels;++d1){var xVal=xVals[xOffset3+d1];for(var q=0;q<chMul;++q){yVals[yOffset4+q]+=xVal*wVals[wOffset3+q]}yOffset4+=chMul;wOffset3+=chMul}}}}}}return y.toTensor()};MathBackendCPU.prototype.depthwiseConv2DDerInput=function(dy,filter,convInfo){this.assertNotComplex([dy,filter],"depthwiseConv2DDerInput");var dx=ops.buffer(convInfo.inShape,"float32");var dxValues=dx.values;var _a=dx.strides,dxS0=_a[0],dxS1=_a[1],dxS2=_a[2];var dyValues=dy.dataSync();var _b=dy.strides,dyS0=_b[0],dyS1=_b[1],dyS2=_b[2];var fltValues=filter.dataSync();var _c=filter.strides,fltS0=_c[0],fltS1=_c[1],fltS2=_c[2];var batchSize=convInfo.batchSize,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inChannels=convInfo.inChannels,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth,outChannels=convInfo.outChannels,outHeight=convInfo.outHeight,outWidth=convInfo.outWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth;var topPad=filterHeight-1-convInfo.padInfo.top;var leftPad=filterWidth-1-convInfo.padInfo.left;var chMul=outChannels/inChannels;for(var b=0;b<batchSize;++b){for(var d1=0;d1<inChannels;++d1){for(var xR=0;xR<inHeight;++xR){var xRCorner=xR-topPad;var xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight));var yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight);for(var xC=0;xC<inWidth;++xC){var xCCorner=xC-leftPad;var xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth));var yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth);var dotProd=0;for(var yR=xRMin;yR<yRMax;++yR){var wR=yR*strideHeight-xRCorner;for(var yC=xCMin;yC<yCMax;++yC){var wC=yC*strideWidth-xCCorner;var dyOffset=dyS0*b+dyS1*yR+dyS2*yC;var fltOffset=fltS0*(filterHeight-1-wR)+fltS1*(filterWidth-1-wC)+fltS2*d1;for(var dm=0;dm<chMul;++dm){var d2=d1*chMul+dm;var pixel=dyValues[dyOffset+d2];var weight=fltValues[fltOffset+dm];dotProd+=pixel*weight}}}dxValues[dxS0*b+dxS1*xR+dxS2*xC+d1]=dotProd}}}}return dx.toTensor()};MathBackendCPU.prototype.depthwiseConv2DDerFilter=function(x,dy,convInfo){this.assertNotComplex([x,dy],"depthwiseConv2DDerFilter");var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var dW=ops.buffer(convInfo.filterShape,"float32");var leftPad=convInfo.padInfo.left;var topPad=convInfo.padInfo.top;var chMul=convInfo.outChannels/convInfo.inChannels;for(var wR=0;wR<filterHeight;++wR){var yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight));var yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight);for(var wC=0;wC<filterWidth;++wC){var yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth));var yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth);for(var d2=0;d2<convInfo.outChannels;++d2){var d1=Math.trunc(d2/chMul);var dm=d2%chMul;var dotProd=0;for(var b=0;b<convInfo.batchSize;++b){for(var yR=yRMin;yR<yRMax;++yR){var xR=wR+yR*strideHeight-topPad;for(var yC=yCMin;yC<yCMax;++yC){var xC=wC+yC*strideWidth-leftPad;dotProd+=x.get(b,xR,xC,d1)*dy.get(b,yR,yC,d2)}}}dW.set(dotProd,wR,wC,d1,dm)}}}return dW.toTensor()};MathBackendCPU.prototype.tile=function(x,reps){this.assertNotComplex(x,"tile");var newShape=new Array(x.rank);for(var i=0;i<newShape.length;i++){newShape[i]=x.shape[i]*reps[i]}var result=ops.buffer(newShape,x.dtype);var xBuf=x.buffer();for(var i=0;i<result.values.length;++i){var newLoc=result.indexToLoc(i);var originalLoc=new Array(x.rank);for(var i_1=0;i_1<originalLoc.length;i_1++){originalLoc[i_1]=newLoc[i_1]%x.shape[i_1]}var originalIndex=xBuf.locToIndex(originalLoc);result.values[i]=xBuf.values[originalIndex]}return result.toTensor()};MathBackendCPU.prototype.pad=function(x,paddings,constantValue){this.assertNotComplex(x,"pad");var outShape=paddings.map(function(p,i){return p[0]+x.shape[i]+p[1]});var start=paddings.map(function(p){return p[0]});var xBuffer=x.buffer();var buffer=ops.buffer(outShape,x.dtype);if(constantValue!==0){buffer.values.fill(constantValue)}for(var i=0;i<x.size;i++){var coords=xBuffer.indexToLoc(i);var outCoords=coords.map(function(c,i){return c+start[i]});buffer.set.apply(buffer,[x.get.apply(x,coords)].concat(outCoords))}return buffer.toTensor()};MathBackendCPU.prototype.transpose=function(x,perm){this.assertNotComplex(x,"transpose");var newShape=new Array(x.rank);for(var i=0;i<newShape.length;i++){newShape[i]=x.shape[perm[i]]}var values=x.dataSync();var result=ops_1.buffer(newShape,x.dtype);var xBuf=x.buffer();for(var i=0;i<x.size;++i){var loc=xBuf.indexToLoc(i);var newLoc=new Array(loc.length);for(var i_2=0;i_2<newLoc.length;i_2++){newLoc[i_2]=loc[perm[i_2]]}var newIndex=result.locToIndex(newLoc);result.values[newIndex]=values[i]}return result.toTensor()};MathBackendCPU.prototype.gather=function(x,indices,axis){this.assertNotComplex([x,indices],"gather");var newShape=x.shape.slice();var indicesValues=indices.dataSync();newShape[axis]=indicesValues.length;var result=ops_1.buffer(newShape,x.dtype);var xBuf=x.buffer();for(var i=0;i<result.size;++i){var newLoc=result.indexToLoc(i);var originalLoc=newLoc.slice();originalLoc[axis]=indicesValues[newLoc[axis]];var originalIndex=xBuf.locToIndex(originalLoc);result.values[i]=xBuf.values[originalIndex]}return result.toTensor()};MathBackendCPU.prototype.batchToSpaceND=function(x,blockShape,crops){this.assertNotComplex([x],"batchToSpaceND");var prod=blockShape.reduce(function(a,b){return a*b});var reshaped=array_ops_util.getReshaped(x.shape,blockShape,prod);var permuted=array_ops_util.getPermuted(reshaped.length,blockShape.length);var reshapedPermuted=array_ops_util.getReshapedPermuted(x.shape,blockShape,prod);var sliceBeginCoords=array_ops_util.getSliceBeginCoords(crops,blockShape.length);var sliceSize=array_ops_util.getSliceSize(reshapedPermuted,crops,blockShape.length);return x.reshape(reshaped).transpose(permuted).reshape(reshapedPermuted).slice(sliceBeginCoords,sliceSize)};MathBackendCPU.prototype.spaceToBatchND=function(x,blockShape,paddings){this.assertNotComplex([x],"spaceToBatchND");var prod=blockShape.reduce(function(a,b){return a*b});var completePaddings=[[0,0]];completePaddings.push.apply(completePaddings,paddings);for(var i=1+blockShape.length;i<x.shape.length;++i){completePaddings.push([0,0])}var paddedX=x.pad(completePaddings);var reshapedPaddedShape=array_ops_util.getReshaped(paddedX.shape,blockShape,prod,false);var permutedReshapedPaddedPermutation=array_ops_util.getPermuted(reshapedPaddedShape.length,blockShape.length,false);var flattenShape=array_ops_util.getReshapedPermuted(paddedX.shape,blockShape,prod,false);return paddedX.reshape(reshapedPaddedShape).transpose(permutedReshapedPaddedPermutation).reshape(flattenShape)};MathBackendCPU.prototype.pool=function(x,convInfo,poolType){this.assertNotComplex(x,"pool");var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var y=ops.buffer(convInfo.outShape,"float32");var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;var initialValue=poolType==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;for(var b=0;b<convInfo.batchSize;++b){for(var d=0;d<convInfo.inChannels;++d){for(var yR=0;yR<convInfo.outHeight;++yR){var xRCorner=yR*strideHeight-padTop;var xRMin=Math.max(0,xRCorner);var xRMax=Math.min(convInfo.inHeight,filterHeight+xRCorner);for(var yC=0;yC<convInfo.outWidth;++yC){var xCCorner=yC*strideWidth-padLeft;var xCMin=Math.max(0,xCCorner);var xCMax=Math.min(convInfo.inWidth,filterWidth+xCCorner);var minMaxValue=initialValue;var avgValue=0;var count=0;for(var xR=xRMin;xR<xRMax;++xR){for(var xC=xCMin;xC<xCMax;++xC){var pixel=x.get(b,xR,xC,d);if(poolType==="max"&&pixel>minMaxValue){minMaxValue=pixel}else if(poolType==="avg"){avgValue+=pixel;count++}}if(isNaN(minMaxValue)){break}}y.set(poolType==="avg"?avgValue/count:minMaxValue,b,yR,yC,d)}}}}return y.toTensor()};MathBackendCPU.prototype.maxPool=function(x,convInfo){return this.pool(x,convInfo,"max")};MathBackendCPU.prototype.maxPoolPositions=function(x,convInfo){var maxPositions=ops.buffer(convInfo.outShape,"int32");var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;for(var b=0;b<convInfo.batchSize;++b){for(var d=0;d<convInfo.inChannels;++d){for(var yR=0;yR<convInfo.outHeight;++yR){var xRCorner=yR*strideHeight-padTop;var xRMin=Math.max(0,xRCorner);var xRMax=Math.min(convInfo.inHeight,filterHeight+xRCorner);for(var yC=0;yC<convInfo.outWidth;++yC){var xCCorner=yC*strideWidth-padLeft;var xCMin=Math.max(0,xCCorner);var xCMax=Math.min(convInfo.inWidth,filterWidth+xCCorner);var maxValue=Number.NEGATIVE_INFINITY;var maxPosition=-1;for(var xR=xRMin;xR<xRMax;++xR){var wR=xR-xRCorner;for(var xC=xCMin;xC<xCMax;++xC){var wC=xC-xCCorner;var pixel=x.get(b,xR,xC,d);if(pixel>maxValue){maxValue=pixel;maxPosition=wR*filterWidth+wC}}}maxPositions.set(maxPosition,b,yR,yC,d)}}}}return maxPositions.toTensor()};MathBackendCPU.prototype.maxPoolBackprop=function(dy,x,y,convInfo){this.assertNotComplex([x,y],"maxPoolBackprop");var maxPositions=this.maxPoolPositions(x,convInfo);var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var padLeft=filterWidth-1-convInfo.padInfo.left;var padTop=filterHeight-1-convInfo.padInfo.top;var dx=ops.buffer(x.shape,"float32");for(var b=0;b<convInfo.batchSize;++b){for(var d=0;d<convInfo.inChannels;++d){for(var dxR=0;dxR<convInfo.inHeight;++dxR){for(var dxC=0;dxC<convInfo.inWidth;++dxC){var dyRCorner=dxR-padTop;var dyCCorner=dxC-padLeft;var dotProd=0;for(var wR=0;wR<filterHeight;++wR){var dyR=(dyRCorner+wR)/strideHeight;if(dyR<0||dyR>=convInfo.outHeight||Math.floor(dyR)!==dyR){continue}for(var wC=0;wC<filterWidth;++wC){var dyC=(dyCCorner+wC)/strideWidth;if(dyC<0||dyC>=convInfo.outWidth||Math.floor(dyC)!==dyC){continue}var maxPos=filterHeight*filterWidth-1-maxPositions.get(b,dyR,dyC,d);var curPos=wR*filterWidth+wC;var mask=maxPos===curPos?1:0;if(mask===0){continue}var pixel=dy.get(b,dyR,dyC,d);dotProd+=pixel*mask}}dx.set(dotProd,b,dxR,dxC,d)}}}}return dx.toTensor()};MathBackendCPU.prototype.avgPoolBackprop=function(dy,x,convInfo){this.assertNotComplex([dy,x],"avgPoolBackprop");var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var padLeft=filterWidth-1-convInfo.padInfo.left;var padTop=filterHeight-1-convInfo.padInfo.top;var dx=ops.buffer(x.shape,"float32");var avgMultiplier=1/(filterHeight*filterWidth);for(var b=0;b<convInfo.batchSize;++b){for(var d=0;d<convInfo.inChannels;++d){for(var dxR=0;dxR<convInfo.inHeight;++dxR){for(var dxC=0;dxC<convInfo.inWidth;++dxC){var dyRCorner=dxR-padTop;var dyCCorner=dxC-padLeft;var dotProd=0;for(var wR=0;wR<filterHeight;++wR){var dyR=(dyRCorner+wR)/strideHeight;if(dyR<0||dyR>=convInfo.outHeight||Math.floor(dyR)!==dyR){continue}for(var wC=0;wC<filterWidth;++wC){var dyC=(dyCCorner+wC)/strideWidth;if(dyC<0||dyC>=convInfo.outWidth||Math.floor(dyC)!==dyC){continue}var pixel=dy.get(b,dyR,dyC,d);dotProd+=pixel}}dx.set(dotProd*avgMultiplier,b,dxR,dxC,d)}}}}return dx.toTensor()};MathBackendCPU.prototype.cast=function(x,dtype){return backend_util.castTensor(x,dtype,this)};MathBackendCPU.prototype.reshape=function(x,shape){return backend_util.reshapeTensor(x,shape)};MathBackendCPU.prototype.avgPool=function(x,convInfo){this.assertNotComplex(x,"avgPool");return this.pool(x,convInfo,"avg").toFloat()};MathBackendCPU.prototype.resizeBilinear=function(x,newHeight,newWidth,alignCorners){this.assertNotComplex(x,"resizeBilinear");var _a=x.shape,batch=_a[0],oldHeight=_a[1],oldWidth=_a[2],numChannels=_a[3];var output=ops.buffer([batch,newHeight,newWidth,numChannels],x.dtype);var effectiveInputSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth];var effectiveOutputSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];for(var b=0;b<batch;b++){for(var r=0;r<newHeight;r++){for(var c=0;c<newWidth;c++){for(var d=0;d<numChannels;d++){var sourceFracRow=effectiveInputSize[0]*r/effectiveOutputSize[0];var sourceFracCol=effectiveInputSize[1]*c/effectiveOutputSize[1];var sourceRowFloor=Math.floor(sourceFracRow);var sourceRowCeil=Math.min(oldHeight-1,Math.ceil(sourceFracRow));var sourceColFloor=Math.floor(sourceFracCol);var sourceColCeil=Math.min(oldWidth-1,Math.ceil(sourceFracCol));var topLeft=x.get(b,sourceRowFloor,sourceColFloor,d);var bottomLeft=x.get(b,sourceRowCeil,sourceColFloor,d);var topRight=x.get(b,sourceRowFloor,sourceColCeil,d);var bottomRight=x.get(b,sourceRowCeil,sourceColCeil,d);var rowFrac=sourceFracRow-sourceRowFloor;var colFrac=sourceFracCol-sourceColFloor;var top_1=topLeft+(topRight-topLeft)*colFrac;var bottom=bottomLeft+(bottomRight-bottomLeft)*colFrac;var newValue=top_1+(bottom-top_1)*rowFrac;output.set(newValue,b,r,c,d)}}}}return output.toTensor()};MathBackendCPU.prototype.resizeBilinearBackprop=function(dy,x,alignCorners){this.assertNotComplex([dy,x],"resizeBilinearBackprop");var _a=x.shape,batch=_a[0],xHeight=_a[1],xWidth=_a[2],depth=_a[3];var _b=dy.shape,yHeight=_b[1],yWidth=_b[2];var output=ops.buffer([batch,xHeight,xWidth,depth],x.dtype);var effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth];var effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth];var heightScale=effectiveXSize[0]/effectiveYSize[0];var widthScale=effectiveXSize[1]/effectiveYSize[1];for(var b=0;b<batch;b++){for(var r=0;r<yHeight;r++){var dxR=r*heightScale;var topDxRIndex=Math.floor(dxR);var bottomDxRIndex=Math.min(Math.ceil(dxR),xHeight-1);var dxRLerp=dxR-topDxRIndex;var inverseDxRLerp=1-dxRLerp;for(var c=0;c<yWidth;c++){var dxC=c*widthScale;var leftDxCIndex=Math.floor(dxC);var rightDxCIndex=Math.min(Math.ceil(dxC),xWidth-1);var dxCLerp=dxC-leftDxCIndex;var inverseDxCLerp=1-dxCLerp;for(var d=0;d<depth;d++){var dyVal=dy.get(b,r,c,d);var topLeft=output.get(b,topDxRIndex,leftDxCIndex,d);topLeft+=dyVal*inverseDxRLerp*inverseDxCLerp;output.set(topLeft,b,topDxRIndex,leftDxCIndex,d);var topRight=output.get(b,topDxRIndex,rightDxCIndex,d);topRight+=dyVal*inverseDxRLerp*dxCLerp;output.set(topRight,b,topDxRIndex,rightDxCIndex,d);var bottomLeft=output.get(b,bottomDxRIndex,leftDxCIndex,d);bottomLeft+=dyVal*dxRLerp*inverseDxCLerp;output.set(bottomLeft,b,bottomDxRIndex,leftDxCIndex,d);var bottomRight=output.get(b,bottomDxRIndex,rightDxCIndex,d);bottomRight+=dyVal*dxRLerp*dxCLerp;output.set(bottomRight,b,bottomDxRIndex,rightDxCIndex,d)}}}}return output.toTensor()};MathBackendCPU.prototype.resizeNearestNeighbor=function(x,newHeight,newWidth,alignCorners){this.assertNotComplex(x,"resizeNearestNeighbor");var _a=x.shape,batch=_a[0],oldHeight=_a[1],oldWidth=_a[2],numChannels=_a[3];var output=ops.buffer([batch,newHeight,newWidth,numChannels],x.dtype);var effectiveInputSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth];var effectiveOutputSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];for(var b=0;b<batch;b++){for(var r=0;r<newHeight;r++){for(var c=0;c<newWidth;c++){for(var d=0;d<numChannels;d++){var sourceFracRow=effectiveInputSize[0]*r/effectiveOutputSize[0];var sourceFracCol=effectiveInputSize[1]*c/effectiveOutputSize[1];var sourceNearestRow=Math.min(oldHeight-1,alignCorners?Math.round(sourceFracRow):Math.floor(sourceFracRow));var sourceNearestCol=Math.min(oldWidth-1,alignCorners?Math.round(sourceFracCol):Math.floor(sourceFracCol));var newValue=x.get(b,sourceNearestRow,sourceNearestCol,d);output.set(newValue,b,r,c,d)}}}}return output.toTensor()};MathBackendCPU.prototype.resizeNearestNeighborBackprop=function(dy,x,alignCorners){this.assertNotComplex([dy,x],"resizeNearestNeighborBackprop");var _a=x.shape,batch=_a[0],xHeight=_a[1],xWidth=_a[2],depth=_a[3];var _b=dy.shape,yHeight=_b[1],yWidth=_b[2];var output=ops.buffer([batch,xHeight,xWidth,depth],x.dtype);var effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth];var effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth];var heightScale=effectiveXSize[0]/effectiveYSize[0];var widthScale=effectiveXSize[1]/effectiveYSize[1];var invHeightScale=1/heightScale;var invWidthScale=1/widthScale;var winHeight=Math.ceil(invHeightScale)*2+2;var winWidth=Math.ceil(invWidthScale)*2+2;for(var b=0;b<batch;b++){for(var r=0;r<xHeight;r++){for(var c=0;c<xWidth;c++){var startRLerp=Math.floor(r*invHeightScale);var startDyR=Math.floor(startRLerp-winHeight/2);var startCLerp=Math.floor(c*invWidthScale);var startDyC=Math.floor(startCLerp-winWidth/2);for(var d=0;d<depth;d++){var accum=0;for(var dyROffset=0;dyROffset<winHeight;dyROffset++){var dyR=dyROffset+startDyR;if(dyR<0||dyR>=yHeight){continue}for(var dyCOffSet=0;dyCOffSet<winWidth;dyCOffSet++){var dyC=dyCOffSet+startDyC;if(dyC<0||dyC>=yWidth){continue}var sourceFracRow=effectiveXSize[0]*(dyR/effectiveYSize[0]);var sourceFracCol=effectiveXSize[1]*(dyC/effectiveYSize[1]);var sourceNearestRow=Math.min(xHeight-1,alignCorners?Math.round(sourceFracRow):Math.floor(sourceFracRow));var sourceNearestCol=Math.min(xWidth-1,alignCorners?Math.round(sourceFracCol):Math.floor(sourceFracCol));if(r===sourceNearestRow&&c===sourceNearestCol){accum+=dy.get(b,dyR,dyC,d)}}}output.set(accum,b,r,c,d)}}}}return output.toTensor()};MathBackendCPU.prototype.batchNormalization=function(x,mean,variance,varianceEpsilon,scale,offset){this.assertNotComplex([x,mean,variance,scale,offset],"batchNormalization");var xVals=x.dataSync();var mVals=mean.dataSync();var varVals=variance.dataSync();var sVals=scale?scale.dataSync():new Float32Array([1]);var offVals=offset?offset.dataSync():new Float32Array([0]);var outVals=new Float32Array(xVals.length);var offValsLength=offVals.length;var sValsLength=sVals.length;var varValsLength=varVals.length;var mValsLength=mVals.length;var offi=0;var mi=0;var si=0;var vi=0;for(var i=0;i<xVals.length;++i){outVals[i]=offVals[offi++]+(xVals[i]-mVals[mi++])*sVals[si++]/Math.sqrt(varVals[vi++]+varianceEpsilon);if(offi>=offValsLength){offi=0}if(mi>=mValsLength){mi=0}if(si>=sValsLength){si=0}if(vi>=varValsLength){vi=0}}return ops_1.tensor4d(outVals,x.shape)};MathBackendCPU.prototype.localResponseNormalization4D=function(x,depthRadius,bias,alpha,beta){this.assertNotComplex(x,"localResponseNormalization4D");var channels=x.shape[3];var maxD=channels-1;var xValues=x.dataSync();var size=util.sizeFromShape(x.shape);var result=new Float32Array(size);function sumAcrossChannels(offset){var currentChannel=offset%channels;var beginSumOffset=offset-currentChannel+Math.max(0,currentChannel-depthRadius);var endSumOffset=offset-currentChannel+Math.min(currentChannel+depthRadius,maxD);var sum=0;for(;beginSumOffset<=endSumOffset;beginSumOffset++){var z=xValues[beginSumOffset];sum+=z*z}return sum}for(var offset=0;offset<size;offset++){var sum=sumAcrossChannels(offset);var val=xValues[offset]*Math.pow(bias+alpha*sum,-beta);result[offset]=val}return ops.tensor4d(result,x.shape)};MathBackendCPU.prototype.LRNGrad=function(dy,inputImage,outputImage,depthRadius,bias,alpha,beta){this.assertNotComplex(dy,"LRNGrad");var channels=dy.shape[3];var dyValues=dy.dataSync();var inputImageValues=inputImage.dataSync();var outputImageValues=outputImage.dataSync();var result=new Float32Array(util.sizeFromShape(dy.shape));var size=util.sizeFromShape(dy.shape);for(var offset=0;offset<size;offset++){var currentChannel=offset%channels;var depthBegin=offset-currentChannel+Math.max(0,currentChannel-depthRadius);var depthEnd=offset-currentChannel+Math.min(channels,currentChannel+depthRadius+1);var norm=0;for(var k=depthBegin;k<depthEnd;k++){norm+=Math.pow(inputImageValues[k],2)}norm=alpha*norm+bias;for(var k=depthBegin;k<depthEnd;k++){var dyi=-2*alpha*beta*inputImageValues[k]*outputImageValues[offset]/norm;if(offset===k){dyi+=Math.pow(norm,-beta)}dyi*=dyValues[offset];result[k]+=dyi}}return ops.tensor4d(result,dy.shape)};MathBackendCPU.prototype.multinomial=function(logits,normalized,numSamples,seed){this.assertNotComplex(logits,"multinomial");var probabilities=normalized?logits:ops.softmax(logits);var batchSize=probabilities.shape[0];var numEvents=probabilities.shape[1];var res=ops.zeros([batchSize,numSamples],"int32");var resVals=res.dataSync();var probVals=probabilities.dataSync();for(var b=0;b<batchSize;++b){var offset=b*numEvents;var cdf=new Float32Array(numEvents-1);cdf[0]=probVals[offset];for(var event_1=1;event_1<cdf.length;++event_1){cdf[event_1]=cdf[event_1-1]+probVals[offset+event_1]}var random=seedrandom.alea(seed.toString());var outOffset=b*numSamples;for(var sampleId=0;sampleId<numSamples;++sampleId){var r=random();resVals[outOffset+sampleId]=cdf.length;for(var event_2=0;event_2<cdf.length;event_2++){if(r<cdf[event_2]){resVals[outOffset+sampleId]=event_2;break}}}}return res};MathBackendCPU.prototype.oneHot=function(indices,depth,onValue,offValue){this.assertNotComplex(indices,"oneHot");var res=new Float32Array(indices.size*depth);res.fill(offValue);for(var event_3=0;event_3<indices.size;++event_3){if(indices.get(event_3)>=0&&indices.get(event_3)<depth){res[event_3*depth+indices.get(event_3)]=onValue}}return ops.tensor2d(res,[indices.size,depth],"int32")};MathBackendCPU.prototype.nonMaxSuppression=function(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){this.assertNotComplex(boxes,"nonMaxSuppression");var boxesVals=boxes.dataSync();var scoresVals=scores.dataSync();return non_max_suppression_impl_1.nonMaxSuppressionImpl(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold)};MathBackendCPU.prototype.depthToSpace=function(x,blockSize,dataFormat){util.assert(dataFormat==="NHWC","Only NHWC dataFormat supported on CPU for depthToSpace. Got "+dataFormat);util.assert(blockSize>1,"blockSize should be > 1 for depthToSpace, but was: "+blockSize);var batchSize=x.shape[0];var inputHeight=x.shape[1];var inputWidth=x.shape[2];var inputDepth=x.shape[3];var outputHeight=inputHeight*blockSize;var outputWidth=inputWidth*blockSize;var outputDepth=inputDepth/(blockSize*blockSize);var xValues=x.dataSync();var result=new Float32Array(batchSize*outputHeight*outputWidth*outputDepth);var outputIdx=0;for(var b=0;b<batchSize;++b){for(var h=0;h<outputHeight;++h){var inH=Math.floor(h/blockSize);var offsetH=h%blockSize;for(var w=0;w<outputWidth;++w){var inW=Math.floor(w/blockSize);var offsetW=w%blockSize;var offsetD=(offsetH*blockSize+offsetW)*outputDepth;for(var d=0;d<outputDepth;++d){var inD=d+offsetD;var inputIdx=inD+inputDepth*(inW+inputWidth*(inH+inputHeight*b));result[outputIdx++]=xValues[inputIdx]}}}}return ops.tensor4d(result,[batchSize,outputHeight,outputWidth,outputDepth])};MathBackendCPU.prototype.broadcastedBinaryOp=function(a,b,dtype,op){var newShape=broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);var result=ops.buffer(newShape,dtype);var aVals=a.dataSync();var bVals=b.dataSync();var aBroadcastDims=broadcast_util.getBroadcastDims(a.shape,newShape);var bBroadcastDims=broadcast_util.getBroadcastDims(b.shape,newShape);var resVals=result.values;if(aBroadcastDims.length+bBroadcastDims.length===0){for(var i=0;i<resVals.length;++i){resVals[i]=op(aVals[i%aVals.length],bVals[i%bVals.length])}}else{var aBuf=a.buffer();var bBuf=b.buffer();var _loop_2=function(i){var loc=result.indexToLoc(i);var aLoc=loc.slice(-a.rank);aBroadcastDims.forEach(function(d){return aLoc[d]=0});var aIndex=aBuf.locToIndex(aLoc);var bLoc=loc.slice(-b.rank);bBroadcastDims.forEach(function(d){return bLoc[d]=0});var bIndex=bBuf.locToIndex(bLoc);resVals[i]=op(aVals[aIndex],bVals[bIndex])};for(var i=0;i<resVals.length;++i){_loop_2(i)}}return result.toTensor()};MathBackendCPU.prototype.broadcastedBinaryComplexOp=function(a,b,op){var newShape=broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);var realResult=ops.buffer(newShape,"float32");var imagResult=ops.buffer(newShape,"float32");var aVals=a.dataSync();var bVals=b.dataSync();var aBroadcastDims=broadcast_util.getBroadcastDims(a.shape,newShape);var bBroadcastDims=broadcast_util.getBroadcastDims(b.shape,newShape);var realVals=realResult.values;var imagVals=imagResult.values;if(aBroadcastDims.length+bBroadcastDims.length===0){for(var i=0;i<realVals.length;i++){var aIdx=i%aVals.length;var bIdx=i%bVals.length;var result=op(aVals[aIdx*2],aVals[aIdx*2+1],bVals[bIdx*2],bVals[bIdx*2+1]);realVals[i]=result.real;imagVals[i]=result.imag}}else{var aRealBuf=this.data.get(a.dataId).complexTensors.real.buffer();var bRealBuf=this.data.get(b.dataId).complexTensors.real.buffer();var _loop_3=function(i){var loc=realResult.indexToLoc(i);var aLoc=loc.slice(-a.rank);aBroadcastDims.forEach(function(d){return aLoc[d]=0});var aIndex=aRealBuf.locToIndex(aLoc);var bLoc=loc.slice(-b.rank);bBroadcastDims.forEach(function(d){return bLoc[d]=0});var bIndex=bRealBuf.locToIndex(bLoc);var opResult=op(aVals[aIndex*2],aVals[aIndex*2+1],bVals[bIndex*2],bVals[bIndex*2+1]);realVals[i]=opResult.real;imagVals[i]=opResult.imag};for(var i=0;i<realVals.length;i++){_loop_3(i)}}return this.complex(realResult.toTensor(),imagResult.toTensor())};MathBackendCPU.prototype.split=function(x,sizeSplits,axis){return split_shared_1.split(x,sizeSplits,axis)};MathBackendCPU.prototype.dispose=function(){};MathBackendCPU.prototype.floatPrecision=function(){return 32};MathBackendCPU.prototype.cropAndResize=function(images,boxes,boxIndex,cropSize,method,extrapolationValue){var _a=images.shape,batch=_a[0],imageHeight=_a[1],imageWidth=_a[2],numChannels=_a[3];var numBoxes=boxes.shape[0];var cropHeight=cropSize[0],cropWidth=cropSize[1];var output=ops.buffer([numBoxes,cropHeight,cropWidth,numChannels]);var boxVals=boxes.dataSync();var boxIndVals=boxIndex.dataSync();var imageVals=images.dataSync();var inStride=images.strides;var outStride=output.strides;for(var b=0;b<numBoxes;b++){var startInd=b*4;var y1=boxVals[startInd];var x1=boxVals[startInd+1];var y2=boxVals[startInd+2];var x2=boxVals[startInd+3];var bInd=boxIndVals[b];if(bInd>=batch){continue}var heightScale=cropHeight>1?(y2-y1)*(imageHeight-1)/(cropHeight-1):0;var widthScale=cropWidth>1?(x2-x1)*(imageWidth-1)/(cropWidth-1):0;for(var y=0;y<cropHeight;y++){var yInd=cropHeight>1?y1*(imageHeight-1)+y*heightScale:.5*(y1+y2)*(imageHeight-1);if(yInd<0||yInd>imageHeight-1){for(var x=0;x<cropWidth;x++){for(var c=0;c<numChannels;c++){var ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}}continue}if(method==="bilinear"){var topInd=Math.floor(yInd);var bottomInd=Math.ceil(yInd);var yLerp=yInd-topInd;for(var x=0;x<cropWidth;x++){var xInd=cropWidth>1?x1*(imageWidth-1)+x*widthScale:.5*(x1+x2)*(imageWidth-1);if(xInd<0||xInd>imageWidth-1){for(var c=0;c<numChannels;c++){var ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}continue}var leftInd=Math.floor(xInd);var rightInd=Math.ceil(xInd);var xLerp=xInd-leftInd;for(var c=0;c<numChannels;c++){var ind=c+leftInd*inStride[2]+topInd*inStride[1]+bInd*inStride[0];var topLeft=imageVals[ind];ind=c+rightInd*inStride[2]+topInd*inStride[1]+bInd*inStride[0];var topRight=imageVals[ind];ind=c+leftInd*inStride[2]+bottomInd*inStride[1]+bInd*inStride[0];var bottomLeft=imageVals[ind];ind=c+rightInd*inStride[2]+bottomInd*inStride[1]+bInd*inStride[0];var bottomRight=imageVals[ind];var top_2=topLeft+(topRight-topLeft)*xLerp;var bottom=bottomLeft+(bottomRight-bottomLeft)*xLerp;ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=top_2+(bottom-top_2)*yLerp}}}else{for(var x=0;x<cropWidth;++x){var xInd=cropWidth>1?x1*(imageWidth-1)+x*widthScale:.5*(x1+x2)*(imageWidth-1);if(xInd<0||xInd>imageWidth-1){for(var c=0;c<numChannels;c++){var ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}continue}var closestX=Math.round(xInd);var closestY=Math.round(yInd);for(var c=0;c<numChannels;c++){var inInd=c+closestX*inStride[2]+closestY*inStride[1]+bInd*inStride[0];var outInd=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[outInd]=imageVals[inInd]}}}}}return output.toTensor()};return MathBackendCPU}();exports.MathBackendCPU=MathBackendCPU;environment_1.ENV.registerBackend("cpu",function(){return new MathBackendCPU},1,tensor_1.setTensorTracker)},{"../environment":51,"../log":124,"../ops/array_ops_util":126,"../ops/axis_util":127,"../ops/broadcast_util":130,"../ops/concat_util":134,"../ops/erf_util":137,"../ops/ops":148,"../ops/selu_util":157,"../ops/slice_util":159,"../tensor":178,"../types":184,"../util":185,"./backend":67,"./backend_util":69,"./complex_util":71,"./non_max_suppression_impl":72,"./split_shared":73,"./topk_impl":74,"./where_impl":123,seedrandom:256}],69:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_ops_1=require("../ops/tensor_ops");var tensor_1=require("../tensor");var util_1=require("../util");function castTensor(x,dtype,backend){if(dtype==="complex64"){if(x.dtype==="complex64"){return x.clone()}var zerosTensor=tensor_ops_1.zeros(x.shape);var floatX=x.toFloat();var result=backend.complex(floatX,zerosTensor);zerosTensor.dispose();floatX.dispose();return result}if(!util_1.hasEncodingLoss(x.dtype,dtype)){return tensor_1.Tensor.make(x.shape,{dataId:x.dataId},dtype)}if(x.dtype==="complex64"){var real=backend.real(x);var result=real.cast(dtype);real.dispose();return result}if(dtype==="int32"){return backend.int(x)}else if(dtype==="bool"){var zero=tensor_ops_1.scalar(0,x.dtype);var result=backend.notEqual(x,zero);zero.dispose();return result}else{throw new Error("Error in Cast: unknown dtype argument ("+dtype+")")}}exports.castTensor=castTensor;function reshapeTensor(x,shape){return tensor_1.Tensor.make(shape,{dataId:x.dataId},x.dtype)}exports.reshapeTensor=reshapeTensor},{"../ops/tensor_ops":162,"../tensor":178,"../util":185}],70:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var log_1=require("../log");var array_ops_util=require("../ops/array_ops_util");var axis_util=require("../ops/axis_util");var concat_util_1=require("../ops/concat_util");var reduce_util=require("../ops/reduce_util");var segment_util=require("../ops/segment_util");var slice_util_1=require("../ops/slice_util");var softmax_1=require("../ops/softmax");var tensor_ops_1=require("../ops/tensor_ops");var tensor_1=require("../tensor");var types_1=require("../types");var util=require("../util");var util_1=require("../util");var backend_1=require("./backend");var backend_util=require("./backend_util");var complex_util_1=require("./complex_util");var non_max_suppression_impl_1=require("./non_max_suppression_impl");var split_shared_1=require("./split_shared");var topk_impl_1=require("./topk_impl");var argminmax_gpu_1=require("./webgl/argminmax_gpu");var avg_pool_backprop_gpu_1=require("./webgl/avg_pool_backprop_gpu");var batchnorm_gpu_1=require("./webgl/batchnorm_gpu");var binaryop_complex_gpu=require("./webgl/binaryop_complex_gpu");var binaryop_complex_gpu_1=require("./webgl/binaryop_complex_gpu");var binaryop_gpu=require("./webgl/binaryop_gpu");var binaryop_gpu_1=require("./webgl/binaryop_gpu");var clip_gpu_1=require("./webgl/clip_gpu");var concat_gpu_1=require("./webgl/concat_gpu");var conv_backprop_gpu_1=require("./webgl/conv_backprop_gpu");var conv_backprop_gpu_depthwise_1=require("./webgl/conv_backprop_gpu_depthwise");var conv_gpu_1=require("./webgl/conv_gpu");var conv_gpu_depthwise_1=require("./webgl/conv_gpu_depthwise");var crop_and_resize_gpu_1=require("./webgl/crop_and_resize_gpu");var cumsum_gpu_1=require("./webgl/cumsum_gpu");var depth_to_space_gpu_1=require("./webgl/depth_to_space_gpu");var encode_float_gpu_1=require("./webgl/encode_float_gpu");var from_pixels_gpu_1=require("./webgl/from_pixels_gpu");var gather_gpu_1=require("./webgl/gather_gpu");var gpgpu_context_1=require("./webgl/gpgpu_context");var gpgpu_math=require("./webgl/gpgpu_math");var gpgpu_util=require("./webgl/gpgpu_util");var lrn_gpu_1=require("./webgl/lrn_gpu");var lrn_grad_gpu_1=require("./webgl/lrn_grad_gpu");var max_pool_backprop_gpu_1=require("./webgl/max_pool_backprop_gpu");var mulmat_gpu_1=require("./webgl/mulmat_gpu");var mulmat_packed_gpu_1=require("./webgl/mulmat_packed_gpu");var multinomial_gpu_1=require("./webgl/multinomial_gpu");var onehot_gpu_1=require("./webgl/onehot_gpu");var pack_gpu_1=require("./webgl/pack_gpu");var pad_gpu_1=require("./webgl/pad_gpu");var pool_gpu_1=require("./webgl/pool_gpu");var reduce_gpu_1=require("./webgl/reduce_gpu");var resize_bilinear_backprop_gpu_1=require("./webgl/resize_bilinear_backprop_gpu");var resize_bilinear_gpu_1=require("./webgl/resize_bilinear_gpu");var resize_nearest_neighbor_backprop_gpu_1=require("./webgl/resize_nearest_neighbor_backprop_gpu");var resize_nearest_neighbor_gpu_1=require("./webgl/resize_nearest_neighbor_gpu");var reverse_gpu_1=require("./webgl/reverse_gpu");var segment_gpu_1=require("./webgl/segment_gpu");var select_gpu_1=require("./webgl/select_gpu");var slice_gpu_1=require("./webgl/slice_gpu");var strided_slice_gpu_1=require("./webgl/strided_slice_gpu");var tex_util_1=require("./webgl/tex_util");var texture_manager_1=require("./webgl/texture_manager");var tile_gpu_1=require("./webgl/tile_gpu");var transpose_gpu_1=require("./webgl/transpose_gpu");var unary_op=require("./webgl/unaryop_gpu");var unaryop_gpu_1=require("./webgl/unaryop_gpu");var unpack_gpu_1=require("./webgl/unpack_gpu");var webgl_util=require("./webgl/webgl_util");var where_impl_1=require("./where_impl");var BEFORE_PAGING_CONSTANT=300;exports.SIZE_UPLOAD_UNIFORM=32;var MathBackendWebGL=function(){function MathBackendWebGL(gpgpu,delayedStorage){if(delayedStorage===void 0){delayedStorage=true}this.gpgpu=gpgpu;this.delayedStorage=delayedStorage;this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.lruDataGPU=[];this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.binaryCache={};this.disposed=false;if(environment_1.ENV.get("WEBGL_VERSION")<1){throw new Error("WebGL is not supported on this device")}if(environment_1.ENV.get("IS_BROWSER")){this.canvas=document.createElement("canvas")}if(gpgpu==null){this.gpgpu=new gpgpu_context_1.GPGPUContext(gpgpu_util.createWebGLContext(this.canvas));this.gpgpuCreatedLocally=true}else{this.gpgpuCreatedLocally=false}if(environment_1.ENV.get("WEBGL_PAGING_ENABLED")){this.NUM_BYTES_BEFORE_PAGING=window.screen.height*window.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT}this.textureManager=new texture_manager_1.TextureManager(this.gpgpu)}MathBackendWebGL.prototype.register=function(dataId,shape,dtype){if(this.texData.has(dataId)){throw new Error("Data buffer is already registered")}this.texData.set(dataId,{shape:shape,dtype:dtype,values:null,texture:null,complexTensors:null,texShape:null,usage:tex_util_1.TextureUsage.RENDER})};MathBackendWebGL.prototype.setDataMover=function(dataMover){this.texData=new backend_1.DataStorage(dataMover)};MathBackendWebGL.prototype.fromPixels=function(pixels,numChannels){if(pixels==null){throw new Error("pixels passed to tf.fromPixels() can not be null")}var texShape=[pixels.height,pixels.width];var outShape=[pixels.height,pixels.width,numChannels];if(!(pixels instanceof HTMLVideoElement)&&!(pixels instanceof HTMLImageElement)&&!(pixels instanceof HTMLCanvasElement)&&!(pixels instanceof ImageData)){throw new Error("pixels passed to tf.fromPixels() must be either an "+"HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or "+("ImageData, but was "+pixels.constructor.name))}if(pixels instanceof HTMLVideoElement){if(this.fromPixelsCanvas==null){if(!environment_1.ENV.get("IS_BROWSER")){throw new Error("Can't read pixels from HTMLImageElement outside the browser.")}if(document.readyState!=="complete"){throw new Error("The DOM is not ready yet. Please call tf.fromPixels() "+"once the DOM is ready. One way to do that is to add an event "+"listener for `DOMContentLoaded` on the document object")}this.fromPixelsCanvas=document.createElement("canvas")}this.fromPixelsCanvas.width=pixels.width;this.fromPixelsCanvas.height=pixels.height;this.fromPixelsCanvas.getContext("2d").drawImage(pixels,0,0,pixels.width,pixels.height);pixels=this.fromPixelsCanvas}var tempPixelHandle=this.makeTensorHandle(texShape,"int32");this.texData.get(tempPixelHandle.dataId).usage=tex_util_1.TextureUsage.PIXELS;this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelHandle.dataId),pixels);var program=new from_pixels_gpu_1.FromPixelsProgram(outShape);var res=this.compileAndRun(program,[tempPixelHandle]);this.disposeData(tempPixelHandle.dataId);return res};MathBackendWebGL.prototype.makeTensorHandle=function(shape,dtype){var dataId={};this.register(dataId,shape,dtype);return{dataId:dataId,shape:shape,dtype:dtype}};MathBackendWebGL.prototype.write=function(dataId,values){if(values==null){throw new Error("MathBackendWebGL.write(): values can not be null")}var texData=this.texData.get(dataId);var texture=texData.texture,texShape=texData.texShape,usage=texData.usage,dtype=texData.dtype;if(dtype==="complex64"){throw new Error("Cannot write to a complex64 dtype. "+"Please use tf.complex(real, imag).")}if(texture!=null){this.releaseTexture(dataId,texture,texShape,usage);texData.texture=null;texData.texShape=null}texData.usage=tex_util_1.TextureUsage.UPLOAD;texData.values=values;if(!this.delayedStorage){this.uploadToGPU(dataId)}};MathBackendWebGL.prototype.readSync=function(dataId){var texData=this.texData.get(dataId);var values=texData.values,dtype=texData.dtype,complexTensors=texData.complexTensors;if(values!=null){this.cacheOnCPU(dataId);return values}var shouldTimeProgram=this.activeTimers!=null;var start;if(shouldTimeProgram){start=performance.now()}var result;if(dtype==="complex64"){var realValues=complexTensors.real.dataSync();var imagValues=complexTensors.imag.dataSync();result=complex_util_1.mergeRealAndImagArrays(realValues,imagValues)}else{result=this.getValuesFromTexture(dataId)}if(shouldTimeProgram){this.downloadWaitMs+=performance.now()-start}this.cacheOnCPU(dataId,result);return texData.values};MathBackendWebGL.prototype.read=function(dataId){return __awaiter(this,void 0,void 0,function(){var subscribers_1,texData,texture,values,texShape,bufferOrTexture,vals,subscribers;return __generator(this,function(_a){switch(_a.label){case 0:if(this.pendingRead.has(dataId)){subscribers_1=this.pendingRead.get(dataId);return[2,new Promise(function(resolve){return subscribers_1.push(resolve)})]}texData=this.texData.get(dataId);texture=texData.texture,values=texData.values,texShape=texData.texShape;if(values!=null){this.cacheOnCPU(dataId);return[2,values]}this.pendingRead.set(dataId,[]);if(!environment_1.ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&environment_1.ENV.get("WEBGL_VERSION")===2){throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and "+"WEBGL_VERSION=2 not yet supported.")}bufferOrTexture=this.gpgpu.maybeCreateBufferFromTexture(texture,texShape[0],texShape[1]);return[4,this.gpgpu.createAndWaitForFence()];case 1:_a.sent();if(bufferOrTexture instanceof WebGLTexture){vals=this.getValuesFromTexture(dataId)}else{vals=this.gpgpu.downloadFloat32MatrixFromBuffer(bufferOrTexture,texShape[0],texShape[1])}this.cacheOnCPU(dataId,vals);subscribers=this.pendingRead.get(dataId);this.pendingRead.delete(dataId);subscribers.forEach(function(resolve){return resolve(vals)});if(this.pendingDisposal.has(dataId)){this.pendingDisposal.delete(dataId);this.disposeData(dataId)}return[2,vals]}})})};MathBackendWebGL.prototype.getValuesFromTexture=function(dataId){var _a=this.texData.get(dataId),shape=_a.shape,dtype=_a.dtype,texture=_a.texture,texShape=_a.texShape;if(environment_1.ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED")){if(this.texData.get(dataId).usage===tex_util_1.TextureUsage.PACK){return this.gpgpu.downloadMatrixFromPackedTexture(texture,texShape[0],texShape[1])}else{return this.gpgpu.downloadFloat32MatrixFromOutputTexture(texture,texShape[0],texShape[1])}}var tmpTarget=this.makeTensorHandle(shape,"float32");tmpTarget.size=util_1.sizeFromShape(shape);this.texData.get(tmpTarget.dataId).usage=tex_util_1.TextureUsage.DOWNLOAD;var program=new encode_float_gpu_1.EncodeFloatProgram(shape);var pageToCpu=false;this.compileAndRun(program,[{shape:shape,dtype:dtype,dataId:dataId}],tmpTarget,null,pageToCpu);var tmpData=this.texData.get(tmpTarget.dataId);var vals=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture,tmpData.texShape[0],tmpData.texShape[1]);this.disposeData(tmpTarget.dataId);return vals};MathBackendWebGL.prototype.time=function(f){return __awaiter(this,void 0,void 0,function(){var oldActiveTimers,newActiveTimers,outerMostTime,flattenedActiveTimers,kernelMs,res;return __generator(this,function(_a){switch(_a.label){case 0:oldActiveTimers=this.activeTimers;newActiveTimers=[];outerMostTime=false;if(this.programTimersStack==null){this.programTimersStack=newActiveTimers;outerMostTime=true}else{this.activeTimers.push(newActiveTimers)}this.activeTimers=newActiveTimers;f();flattenedActiveTimers=util.flatten(this.activeTimers);this.activeTimers=oldActiveTimers;if(outerMostTime){this.programTimersStack=null}return[4,Promise.all(flattenedActiveTimers).then(function(results){var sum=0;results.forEach(function(result){return sum+=result});return sum})];case 1:kernelMs=_a.sent();res={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:kernelMs,wallMs:null};this.uploadWaitMs=0;this.downloadWaitMs=0;return[2,res]}})})};MathBackendWebGL.prototype.memory=function(){return{unreliable:false,numBytesInGPU:this.numBytesInGPU}};MathBackendWebGL.prototype.startTimer=function(){if(environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){return this.gpgpu.beginQuery()}return{startMs:performance.now(),endMs:null}};MathBackendWebGL.prototype.endTimer=function(query){if(environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){this.gpgpu.endQuery();return query}query.endMs=performance.now();return query};MathBackendWebGL.prototype.getQueryTime=function(query){return __awaiter(this,void 0,void 0,function(){var timerQuery;return __generator(this,function(_a){if(environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){return[2,this.gpgpu.waitForQueryAndGetTime(query)]}timerQuery=query;return[2,timerQuery.endMs-timerQuery.startMs]})})};MathBackendWebGL.prototype.disposeData=function(dataId){if(this.pendingDisposal.has(dataId)){return}if(this.pendingRead.has(dataId)){this.pendingDisposal.add(dataId);return}if(this.texData.has(dataId)){var _a=this.texData.get(dataId),texture=_a.texture,texShape=_a.texShape,usage=_a.usage,complexTensors=_a.complexTensors;if(texture!=null){this.releaseTexture(dataId,texture,texShape,usage)}if(complexTensors!=null){complexTensors.real.dispose();complexTensors.imag.dispose()}this.texData.delete(dataId)}};MathBackendWebGL.prototype.getTexture=function(dataId){this.uploadToGPU(dataId);return this.texData.get(dataId).texture};MathBackendWebGL.prototype.getGPGPUContext=function(){return this.gpgpu};MathBackendWebGL.prototype.getCanvas=function(){return this.canvas};MathBackendWebGL.prototype.complex=function(real,imag){var result=this.makeOutputArray(real.shape,"complex64");var resultData=this.texData.get(result.dataId);resultData.complexTensors={real:environment_1.ENV.engine.keep(real.clone()),imag:environment_1.ENV.engine.keep(imag.clone())};return result};MathBackendWebGL.prototype.real=function(input){var resultData=this.texData.get(input.dataId);return resultData.complexTensors.real.clone()};MathBackendWebGL.prototype.imag=function(input){var resultData=this.texData.get(input.dataId);return resultData.complexTensors.imag.clone()};MathBackendWebGL.prototype.slice=function(x,begin,size){var program=new slice_gpu_1.SliceProgram(size);var customSetup=program.getCustomSetupFunc(begin);return this.compileAndRun(program,[x],null,customSetup)};MathBackendWebGL.prototype.stridedSlice=function(x,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){var _a=slice_util_1.getStridedSlicedInfo(x.shape,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask),beginIndex=_a[0],size=_a[1],shrinkAxis=_a[2];var shape=size.filter(function(v,index){return shrinkAxis.indexOf(index)===-1});if(shape.some(function(axis){return axis===0})){return tensor_ops_1.tensor([],shape)}var program=new strided_slice_gpu_1.StridedSliceProgram(beginIndex,strides,size,shrinkAxis);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.reverse=function(x,axis){var program=new reverse_gpu_1.ReverseProgram(x.shape,axis);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.concat2Tensors=function(a,b,axis){var outShape=concat_util_1.computeOutShape([a.shape,b.shape],axis);var a2D=a.as2D(-1,util_1.sizeFromShape(a.shape.slice(axis)));var b2D=b.as2D(-1,util_1.sizeFromShape(b.shape.slice(axis)));var program=new concat_gpu_1.ConcatProgram(a2D.shape,b2D.shape);var res=this.compileAndRun(program,[a2D,b2D]);return res.reshape(outShape)};MathBackendWebGL.prototype.concat=function(tensors,axis){if(tensors.length===1){return tensors[0]}var result=tensors[0];for(var i=1;i<tensors.length;++i){result=this.concat2Tensors(result,tensors[i],axis)}return result};MathBackendWebGL.prototype.neg=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.NEG);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.batchMatMul=function(a,b,transposeA,transposeB){var outerShapeA=transposeA?a.shape[2]:a.shape[1];var outerShapeB=transposeB?b.shape[1]:b.shape[2];if(environment_1.ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")&&a.shape[0]===1&&b.shape[0]===1&&util.arraysEqual(webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl,[outerShapeA,outerShapeB]),[outerShapeA,outerShapeB])){var aSqueezed=a.as2D(a.shape[1],a.shape[2]);var bSqueezed=b.as2D(b.shape[1],b.shape[2]);var packProgramA=new pack_gpu_1.PackProgram(aSqueezed.shape);var packedAOutput=tensor_1.Tensor.make(aSqueezed.shape,{});this.texData.get(packedAOutput.dataId).usage=tex_util_1.TextureUsage.PACK;var packedA=this.compileAndRun(packProgramA,[aSqueezed],packedAOutput);var packProgramB=new pack_gpu_1.PackProgram(bSqueezed.shape);var packedBOutput=tensor_1.Tensor.make(bSqueezed.shape,{});this.texData.get(packedBOutput.dataId).usage=tex_util_1.TextureUsage.PACK;var packedB=this.compileAndRun(packProgramB,[bSqueezed],packedBOutput);var program=new mulmat_packed_gpu_1.MatMulPackedProgram(packedA.shape,packedB.shape,[outerShapeA,outerShapeB],transposeA,transposeB);var packedMatMulOutput=tensor_1.Tensor.make(program.outputShape,{});this.texData.get(packedMatMulOutput.dataId).usage=tex_util_1.TextureUsage.PACK;var result=this.compileAndRun(program,[packedA,packedB],packedMatMulOutput);var unpackProgram=new unpack_gpu_1.UnpackProgram(result.shape);var unpacked=this.compileAndRun(unpackProgram,[result]);packedAOutput.dispose();packedBOutput.dispose();packedMatMulOutput.dispose();return unpacked.reshape([1,result.shape[0],result.shape[1]])}else{return this.compileAndRun(new mulmat_gpu_1.MatMulProgram(a.shape,b.shape,transposeA,transposeB),[a,b])}};MathBackendWebGL.prototype.multiply=function(a,b){if(a.dtype==="complex64"){var aData=this.texData.get(a.dataId);var bData=this.texData.get(b.dataId);var realProgram=new binaryop_complex_gpu_1.BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL,a.shape,b.shape);var imagProgram=new binaryop_complex_gpu_1.BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG,a.shape,b.shape);var inputs=[this.makeComplexComponentTensorHandle(a,aData.complexTensors.real),this.makeComplexComponentTensorHandle(a,aData.complexTensors.imag),this.makeComplexComponentTensorHandle(b,bData.complexTensors.real),this.makeComplexComponentTensorHandle(b,bData.complexTensors.imag)];var real=this.compileAndRun(realProgram,inputs);var imag=this.compileAndRun(imagProgram,inputs);var complex=this.complex(real,imag);real.dispose();imag.dispose();return complex}var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,a.dtype);return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.batchNormalization=function(x,mean,variance,varianceEpsilon,scale,offset){var inputs=[x,mean,variance];var offsetShape=null;if(offset!=null){offsetShape=offset.shape;inputs.push(offset)}var scaleShape=null;if(scale!=null){scaleShape=scale.shape;inputs.push(scale)}var program=new batchnorm_gpu_1.BatchNormProgram(x.shape,mean.shape,variance.shape,offsetShape,scaleShape,varianceEpsilon);return this.compileAndRun(program,inputs)};MathBackendWebGL.prototype.localResponseNormalization4D=function(x,radius,bias,alpha,beta){var program=new lrn_gpu_1.LRNProgram(x.shape,radius,bias,alpha,beta);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.LRNGrad=function(dy,inputImage,outputImage,depthRadius,bias,alpha,beta){var program=new lrn_grad_gpu_1.LRNGradProgram(inputImage.shape,depthRadius,bias,alpha,beta);return this.compileAndRun(program,[inputImage,outputImage,dy])};MathBackendWebGL.prototype.tile=function(x,reps){var program=new tile_gpu_1.TileProgram(x.shape,reps);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.pad=function(x,paddings,constantValue){var program=new pad_gpu_1.PadProgram(x.shape,paddings,constantValue);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.transpose=function(x,perm){var program=new transpose_gpu_1.TransposeProgram(x.shape,perm);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.gather=function(x,indices,axis){var program=new gather_gpu_1.GatherProgram(x.shape,indices.size,axis);return this.compileAndRun(program,[x,indices])};MathBackendWebGL.prototype.batchToSpaceND=function(x,blockShape,crops){util.assert(x.rank<=4,"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");var prod=blockShape.reduce(function(a,b){return a*b});var reshaped=array_ops_util.getReshaped(x.shape,blockShape,prod);var permuted=array_ops_util.getPermuted(reshaped.length,blockShape.length);var reshapedPermuted=array_ops_util.getReshapedPermuted(x.shape,blockShape,prod);var sliceBeginCoords=array_ops_util.getSliceBeginCoords(crops,blockShape.length);var sliceSize=array_ops_util.getSliceSize(reshapedPermuted,crops,blockShape.length);return x.reshape(reshaped).transpose(permuted).reshape(reshapedPermuted).slice(sliceBeginCoords,sliceSize)};MathBackendWebGL.prototype.spaceToBatchND=function(x,blockShape,paddings){util.assert(x.rank<=4,"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");var prod=blockShape.reduce(function(a,b){return a*b});var completePaddings=[[0,0]];completePaddings.push.apply(completePaddings,paddings);for(var i=1+blockShape.length;i<x.shape.length;++i){completePaddings.push([0,0])}var paddedX=x.pad(completePaddings);var reshapedPaddedShape=array_ops_util.getReshaped(paddedX.shape,blockShape,prod,false);var permutedReshapedPaddedPermutation=array_ops_util.getPermuted(reshapedPaddedShape.length,blockShape.length,false);var flattenShape=array_ops_util.getReshapedPermuted(paddedX.shape,blockShape,prod,false);return paddedX.reshape(reshapedPaddedShape).transpose(permutedReshapedPaddedPermutation).reshape(flattenShape)};MathBackendWebGL.prototype.reduce=function(x,reduceType,dtype){var batchSize=x.shape[0];var inSize=x.shape[1];var windowSize=reduce_util.computeOptimalWindowSize(inSize);var reduceInfo={windowSize:windowSize,inSize:inSize,batchSize:batchSize};var program=new reduce_gpu_1.ReduceProgram(reduceInfo,reduceType);var _a=program.outputShape,rows=_a[0],cols=_a[1];var output=this.makeOutputArray([rows,cols],dtype);this.compileAndRun(program,[x],output);if(output.shape[1]===1){return output}return this.reduce(output,reduceType,dtype)};MathBackendWebGL.prototype.argReduce=function(x,reduceType,bestIndicesA){if(bestIndicesA===void 0){bestIndicesA=null}var batchSize=x.shape[0];var inSize=x.shape[1];if(bestIndicesA!=null){batchSize=bestIndicesA.shape[0];inSize=bestIndicesA.shape[1]}var windowSize=reduce_util.computeOptimalWindowSize(inSize);var reduceInfo={windowSize:windowSize,inSize:inSize,batchSize:batchSize};var program=new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo,reduceType,bestIndicesA==null);var _a=program.outputShape,rows=_a[0],cols=_a[1];var output=this.makeOutputArray([rows,cols],"int32");var inputs=[x];if(bestIndicesA!=null){inputs.push(bestIndicesA)}this.compileAndRun(program,inputs,output);if(output.shape[1]===1){return output}return this.argReduce(x,reduceType,output)};MathBackendWebGL.prototype.sum=function(x,axes){axis_util.assertAxesAreInnerMostDims("sum",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);var outputDType=types_1.sumOutType(x.dtype);return this.reduce(a2D,"sum",outputDType).reshape(outShape)};MathBackendWebGL.prototype.unsortedSegmentSum=function(x,segmentIds,numSegments){var axis=0;var permutation=axis_util.getAxesPermutation([axis],x.rank);var permutedX=x;if(permutation!=null){permutedX=x.transpose(permutation);axis=axis_util.getInnerMostAxes(1,x.rank)[0]}var outShape=segment_util.computeOutShape(permutedX.shape,axis,numSegments);var inSize=util.sizeFromShape([permutedX.shape[axis]]);var a2D=permutedX.as2D(-1,inSize);var outputDType=types_1.sumOutType(x.dtype);var result=this.segOpCompute(a2D,"unsortedSegmentSum",segmentIds,outputDType,numSegments).reshape(outShape);if(permutation!=null){result=result.transpose(axis_util.getUndoAxesPermutation(permutation))}return result};MathBackendWebGL.prototype.segOpCompute=function(x,segOpType,segmentIds,dtype,numSegments){var batchSize=x.shape[0];var inSize=x.shape[1];var windowSize=segment_util.segOpComputeOptimalWindowSize(inSize,numSegments);var segOpInfo={windowSize:windowSize,inSize:inSize,batchSize:batchSize,numSegments:numSegments};var program=new segment_gpu_1.SegmentOpProgram(segOpInfo,segOpType);var _a=program.outputShape,rows=_a[0],cols=_a[1];var output=this.makeOutputArray([rows,cols],dtype);this.compileAndRun(program,[x,segmentIds],output);if(output.shape[1]===numSegments){return output}segmentIds=tensor_ops_1.range(0,numSegments).tile([inSize/windowSize]);return this.segOpCompute(output,segOpType,segmentIds,dtype,numSegments)};MathBackendWebGL.prototype.argMin=function(x,axis){var axes=[axis];axis_util.assertAxesAreInnerMostDims("argMin",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);return this.argReduce(a2D,"min").reshape(outShape)};MathBackendWebGL.prototype.argMax=function(x,axis){var axes=[axis];axis_util.assertAxesAreInnerMostDims("argMax",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);return this.argReduce(a2D,"max").reshape(outShape)};MathBackendWebGL.prototype.cumsum=function(x,axis,exclusive,reverse){if(axis!==x.rank-1){throw new Error("WebGL cumsum shader expects an inner-most axis="+(x.rank-1)+" "+("but got axis="+axis))}var program=new cumsum_gpu_1.CumSumProgram(x.shape,exclusive,reverse);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.equal=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.notEqual=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.less=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.lessEqual=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.greater=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.greaterEqual=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.logicalNot=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.LOGICAL_NOT);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.logicalAnd=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.logicalOr=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,"bool");return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.select=function(condition,a,b){var program=new select_gpu_1.SelectProgram(condition.rank,a.shape,a.rank);var output=this.makeOutputArray(program.outputShape,types_1.upcastType(a.dtype,b.dtype));return this.compileAndRun(program,[condition,a,b],output)};MathBackendWebGL.prototype.where=function(condition){log_1.warn("tf.where() in webgl locks the UI thread. "+"Call tf.whereAsync() instead");var condVals=condition.dataSync();return where_impl_1.whereImpl(condition.shape,condVals)};MathBackendWebGL.prototype.topk=function(x,k,sorted){var xVals=x.dataSync();return topk_impl_1.topkImpl(xVals,x.shape,x.dtype,k,sorted)};MathBackendWebGL.prototype.min=function(x,axes){axis_util.assertAxesAreInnerMostDims("min",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);return this.reduce(a2D,"min",a2D.dtype).reshape(outShape)};MathBackendWebGL.prototype.minimum=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN,a.shape,b.shape);return this.compileAndRun(program,[a,b])};MathBackendWebGL.prototype.mod=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MOD,a.shape,b.shape);var customSetup=program.getCustomSetupFunc();return this.compileAndRun(program,[a,b],null,customSetup)};MathBackendWebGL.prototype.max=function(x,axes){axis_util.assertAxesAreInnerMostDims("max",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);return this.reduce(a2D,"max",a2D.dtype).reshape(outShape)};MathBackendWebGL.prototype.maximum=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX,a.shape,b.shape);return this.compileAndRun(program,[a,b])};MathBackendWebGL.prototype.all=function(x,axes){axis_util.assertAxesAreInnerMostDims("all",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);return this.reduce(a2D,"all",a2D.dtype).reshape(outShape)};MathBackendWebGL.prototype.any=function(x,axes){axis_util.assertAxesAreInnerMostDims("any",axes,x.rank);var _a=axis_util.computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1];var inSize=util.sizeFromShape(reduceShape);var a2D=x.as2D(-1,inSize);return this.reduce(a2D,"any",a2D.dtype).reshape(outShape)};MathBackendWebGL.prototype.squaredDifference=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SQUARED_DIFFERENCE,a.shape,b.shape);return this.compileAndRun(program,[a,b])};MathBackendWebGL.prototype.realDivide=function(a,b){var op=binaryop_gpu.DIV;var outputDtype="float32";var program=new binaryop_gpu_1.BinaryOpProgram(op,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,outputDtype);return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.floorDiv=function(a,b){var op=binaryop_gpu.INT_DIV;var outputDtype="int32";var program=new binaryop_gpu_1.BinaryOpProgram(op,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,outputDtype);return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.add=function(a,b){if(a.dtype==="complex64"&&b.dtype==="complex64"){return this.complexSeparableBinaryOp(a,b,binaryop_gpu.ADD)}var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,types_1.upcastType(a.dtype,b.dtype));return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.complexSeparableBinaryOp=function(a,b,op){var _this=this;var aData=this.texData.get(a.dataId);var bData=this.texData.get(b.dataId);var _a=[[aData.complexTensors.real,bData.complexTensors.real],[aData.complexTensors.imag,bData.complexTensors.imag]].map(function(complexParts){var aPart=complexParts[0],bPart=complexParts[1];var program=new binaryop_gpu_1.BinaryOpProgram(op,a.shape,b.shape);var output=_this.makeOutputArray(program.outputShape,types_1.upcastType(aPart.dtype,bPart.dtype));var aHandle=_this.makeComplexComponentTensorHandle(a,aPart);var bHandle=_this.makeComplexComponentTensorHandle(b,bPart);return _this.compileAndRun(program,[aHandle,bHandle],output)}),real=_a[0],imag=_a[1];var complex=this.complex(real,imag);real.dispose();imag.dispose();return complex};MathBackendWebGL.prototype.makeComplexComponentTensorHandle=function(complexTensor,complexPart){return{dataId:complexPart.dataId,dtype:complexPart.dtype,shape:complexTensor.shape}};MathBackendWebGL.prototype.addN=function(tensors){var res=tensors[0];for(var i=1;i<tensors.length;i++){res=this.add(res,tensors[i])}return res};MathBackendWebGL.prototype.subtract=function(a,b){if(a.dtype==="complex64"&&b.dtype==="complex64"){return this.complexSeparableBinaryOp(a,b,binaryop_gpu.SUB)}var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,types_1.upcastType(a.dtype,b.dtype));return this.compileAndRun(program,[a,b],output)};MathBackendWebGL.prototype.pow=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW,a.shape,b.shape);var customSetup=program.getCustomSetupFunc();var output=this.makeOutputArray(program.outputShape,types_1.upcastType(a.dtype,b.dtype));return this.compileAndRun(program,[a,b],output,customSetup)};MathBackendWebGL.prototype.ceil=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.CEIL);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.floor=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.FLOOR);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.sign=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SIGN);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.round=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ROUND);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.exp=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.EXP);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.expm1=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.EXPM1);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.log=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.LOG);var customSetup=program.getCustomSetupFunc();return this.compileAndRun(program,[x],null,customSetup)};MathBackendWebGL.prototype.log1p=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.LOG1P);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.sqrt=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SQRT);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.rsqrt=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.RSQRT);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.square=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SQUARE);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.reciprocal=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.RECIPROCAL);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.relu=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.RELU);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.elu=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ELU);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.eluDer=function(dy,y){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ELU_DER,dy.shape,y.shape);return this.compileAndRun(program,[dy,y])};MathBackendWebGL.prototype.selu=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SELU);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.int=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.TO_INT);var output=this.makeOutputArray(program.outputShape,"int32");return this.compileAndRun(program,[x],output)};MathBackendWebGL.prototype.clip=function(x,min,max){var program=new clip_gpu_1.ClipProgram(x.shape,min,max);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.abs=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ABS);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.sigmoid=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SIGMOID);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.softplus=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SOFTPLUS);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.sin=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SIN);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.cos=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.COS);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.tan=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.TAN);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.asin=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ASIN);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.acos=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ACOS);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.atan=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ATAN);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.atan2=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ATAN2,a.shape,b.shape);return this.compileAndRun(program,[a,b])};MathBackendWebGL.prototype.sinh=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SINH);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.cosh=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.COSH);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.tanh=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.TANH);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.asinh=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ASINH);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.acosh=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ACOSH);var customSetup=program.getCustomSetupFunc();return this.compileAndRun(program,[x],null,customSetup)};MathBackendWebGL.prototype.atanh=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ATANH);var customSetup=program.getCustomSetupFunc();return this.compileAndRun(program,[x],null,customSetup)};MathBackendWebGL.prototype.erf=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.ERF);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.step=function(x,alpha){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.STEP(alpha));return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.conv2d=function(x,filter,convInfo){var program=new conv_gpu_1.Conv2DProgram(convInfo);return this.compileAndRun(program,[x,filter])};MathBackendWebGL.prototype.conv2dDerInput=function(dy,filter,convInfo){var program=new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])};MathBackendWebGL.prototype.conv2dDerFilter=function(x,dy,convInfo){var program=new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])};MathBackendWebGL.prototype.depthwiseConv2D=function(x,filter,convInfo){var program=new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);return this.compileAndRun(program,[x,filter])};MathBackendWebGL.prototype.depthwiseConv2DDerInput=function(dy,filter,convInfo){var program=new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])};MathBackendWebGL.prototype.depthwiseConv2DDerFilter=function(x,dy,convInfo){var program=new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])};MathBackendWebGL.prototype.maxPool=function(x,convInfo){var program=new pool_gpu_1.Pool2DProgram(convInfo,"max",false);var output=this.makeOutputArray(program.outputShape,x.dtype);return this.compileAndRun(program,[x],output)};MathBackendWebGL.prototype.avgPool=function(x,convInfo){var program=new pool_gpu_1.Pool2DProgram(convInfo,"avg",false);var output=this.makeOutputArray(program.outputShape,"float32");return this.compileAndRun(program,[x],output)};MathBackendWebGL.prototype.maxPoolBackprop=function(dy,x,y,convInfo){var getPositions=true;var maxPoolPositionsProgram=new pool_gpu_1.Pool2DProgram(convInfo,"max",getPositions);var maxPoolPositions=this.compileAndRun(maxPoolPositionsProgram,[x]);var maxPoolBackPropProgram=new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);var output=this.makeOutputArray(maxPoolBackPropProgram.outputShape,x.dtype);var result=this.compileAndRun(maxPoolBackPropProgram,[dy,maxPoolPositions],output);maxPoolPositions.dispose();return result};MathBackendWebGL.prototype.avgPoolBackprop=function(dy,x,convInfo){var avgPoolBackpropProgram=new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);var output=this.makeOutputArray(avgPoolBackpropProgram.outputShape,x.dtype);return this.compileAndRun(avgPoolBackpropProgram,[dy],output)};MathBackendWebGL.prototype.cast=function(x,dtype){return backend_util.castTensor(x,dtype,this)};MathBackendWebGL.prototype.reshape=function(x,shape){return backend_util.reshapeTensor(x,shape)};MathBackendWebGL.prototype.resizeBilinear=function(x,newHeight,newWidth,alignCorners){var program=new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape,newHeight,newWidth,alignCorners);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.resizeBilinearBackprop=function(dy,x,alignCorners){var program=new resize_bilinear_backprop_gpu_1.ResizeBilinearBackpropProgram(dy,x,alignCorners);return this.compileAndRun(program,[dy])};MathBackendWebGL.prototype.resizeNearestNeighbor=function(x,newHeight,newWidth,alignCorners){var program=new resize_nearest_neighbor_gpu_1.ResizeNearestNeighborProgram(x.shape,newHeight,newWidth,alignCorners);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.resizeNearestNeighborBackprop=function(dy,x,alignCorners){var program=new resize_nearest_neighbor_backprop_gpu_1.ResizeNearestNeigborBackpropProgram(dy,x,alignCorners);return this.compileAndRun(program,[dy])};MathBackendWebGL.prototype.multinomial=function(logits,normalized,numSamples,seed){var probs=normalized?logits:softmax_1.softmax(logits);var batchSize=probs.shape[0];var numOutcomes=probs.shape[1];var program=new multinomial_gpu_1.MultinomialProgram(batchSize,numOutcomes,numSamples);var output=this.makeOutputArray(program.outputShape,"int32");var customSetup=program.getCustomSetupFunc(seed);return this.compileAndRun(program,[probs],output,customSetup)};MathBackendWebGL.prototype.oneHot=function(indices,depth,onValue,offValue){var program=new onehot_gpu_1.OneHotProgram(indices.size,depth,onValue,offValue);return this.compileAndRun(program,[indices])};MathBackendWebGL.prototype.nonMaxSuppression=function(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){log_1.warn("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");var boxesVals=boxes.dataSync();var scoresVals=scores.dataSync();return non_max_suppression_impl_1.nonMaxSuppressionImpl(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold)};MathBackendWebGL.prototype.cropAndResize=function(image,boxes,boxIndex,cropSize,method,extrapolationValue){var program=new crop_and_resize_gpu_1.CropAndResizeProgram(image.shape,boxes.shape,cropSize,method,extrapolationValue);return this.compileAndRun(program,[image,boxes,boxIndex])};MathBackendWebGL.prototype.depthToSpace=function(x,blockSize,dataFormat){util.assert(blockSize>1,"blockSize should be > 1 for depthToSpace, but was: "+blockSize);var batchSize=x.shape[0];var inputHeight=dataFormat==="NHWC"?x.shape[1]:x.shape[2];var inputWidth=dataFormat==="NHWC"?x.shape[2]:x.shape[3];var inputDepth=dataFormat==="NHWC"?x.shape[3]:x.shape[1];var outputHeight=inputHeight*blockSize;var outputWidth=inputWidth*blockSize;var outputDepth=inputDepth/(blockSize*blockSize);var outputShape=dataFormat==="NHWC"?[batchSize,outputHeight,outputWidth,outputDepth]:[batchSize,outputDepth,outputHeight,outputWidth];var program=new depth_to_space_gpu_1.DepthToSpaceProgram(outputShape,blockSize,dataFormat);return this.compileAndRun(program,[x])};MathBackendWebGL.prototype.split=function(x,sizeSplits,axis){return split_shared_1.split(x,sizeSplits,axis)};MathBackendWebGL.prototype.makeOutputArray=function(shape,dtype){return tensor_1.Tensor.make(shape,{},dtype)};MathBackendWebGL.prototype.compileAndRun=function(program,inputs,output,customSetup,pageToCpu){var _this=this;if(pageToCpu===void 0){pageToCpu=true}if(output==null){output=this.makeOutputArray(program.outputShape,inputs[0].dtype)}if(output.size===0){this.texData.get(output.dataId).values=util_1.getTypedArrayFromDType(output.dtype,0);return output}var inputsData=inputs.map(function(input){if(input.dtype==="complex64"){throw new Error("GPGPUProgram does not support complex64 input. For complex64 "+"dtypes, please separate the program into real and imaginary "+"parts.")}var texData=_this.texData.get(input.dataId);if(texData.texture==null&&util.sizeFromShape(input.shape)<=exports.SIZE_UPLOAD_UNIFORM){return{shape:input.shape,texData:null,isUniform:true,uniformValues:_this.readSync(input.dataId)}}_this.uploadToGPU(input.dataId);return{shape:input.shape,texData:texData,isUniform:false}});this.uploadToGPU(output.dataId);var outputData={shape:output.shape,texData:this.texData.get(output.dataId),isUniform:false};var key=gpgpu_math.makeShaderKey(program,inputsData,outputData);var binary=this.getAndSaveBinary(key,function(){return gpgpu_math.compileProgram(_this.gpgpu,program,inputsData,outputData)});var shouldTimeProgram=this.activeTimers!=null;var query;if(shouldTimeProgram){query=this.startTimer()}gpgpu_math.runProgram(binary,inputsData,outputData,customSetup);if(environment_1.ENV.get("WEBGL_PAGING_ENABLED")&&pageToCpu&&this.numBytesInGPU>this.NUM_BYTES_BEFORE_PAGING){var numBytesToPage=this.numBytesInGPU-this.NUM_BYTES_BEFORE_PAGING;while(numBytesToPage>0&&this.lruDataGPU.length>0){var dataId=this.lruDataGPU.shift();var _a=this.texData.get(dataId),shape=_a.shape,dtype=_a.dtype;numBytesToPage-=this.computeBytes(shape,dtype);this.read(dataId)}}if(shouldTimeProgram){query=this.endTimer(query);this.activeTimers.push(this.getQueryTime(query))}return output};MathBackendWebGL.prototype.getAndSaveBinary=function(key,getBinary){if(!(key in this.binaryCache)){this.binaryCache[key]=getBinary()}return this.binaryCache[key]};MathBackendWebGL.prototype.getTextureManager=function(){return this.textureManager};MathBackendWebGL.prototype.dispose=function(){if(this.disposed){return}for(var key in this.binaryCache){this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram)}this.textureManager.dispose();this.canvas.remove();if(this.fromPixelsCanvas!=null){this.fromPixelsCanvas.remove()}if(this.gpgpuCreatedLocally){this.gpgpu.dispose()}this.disposed=true};MathBackendWebGL.prototype.floatPrecision=function(){var _this=this;return globals_1.tidy(function(){if(_this.abs(tensor_ops_1.scalar(1e-8)).get()>0){return 32}return 16})};MathBackendWebGL.prototype.uploadToGPU=function(dataId){var texData=this.texData.get(dataId);var shape=texData.shape,values=texData.values,texture=texData.texture,dtype=texData.dtype,usage=texData.usage;if(environment_1.ENV.get("WEBGL_PAGING_ENABLED")&&texture!=null){var index=this.lruDataGPU.indexOf(dataId);if(index>=0){this.lruDataGPU.splice(this.lruDataGPU.indexOf(dataId),1);this.lruDataGPU.push(dataId)}return}var shouldTimeProgram=this.activeTimers!=null;var start;if(shouldTimeProgram){start=performance.now()}var texShape=webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl,shape);texData.texShape=texShape;var newTexture=this.acquireTexture(dataId,texShape,usage);texData.texture=newTexture;if(values!=null){this.gpgpu.uploadMatrixToTexture(newTexture,texShape[0],texShape[1],typedArrayToFloat32(values,dtype));texData.values=null;if(shouldTimeProgram){this.uploadWaitMs+=performance.now()-start}}};MathBackendWebGL.prototype.cacheOnCPU=function(dataId,float32Values){var dontKeepCopyOnGPU=this.delayedStorage;var texData=this.texData.get(dataId);var texture=texData.texture,texShape=texData.texShape,dtype=texData.dtype,usage=texData.usage;if(dontKeepCopyOnGPU&&texture!=null){this.releaseTexture(dataId,texture,texShape,usage);texData.texture=null;texData.texShape=null}texData.usage=tex_util_1.TextureUsage.UPLOAD;if(float32Values!=null){texData.values=float32ToTypedArray(float32Values,dtype)}};MathBackendWebGL.prototype.releaseTexture=function(dataId,texture,texShape,texType){var _a=this.texData.get(dataId),shape=_a.shape,dtype=_a.dtype;if(environment_1.ENV.get("WEBGL_PAGING_ENABLED")){var idx=this.lruDataGPU.indexOf(dataId);if(idx>=0){this.lruDataGPU.splice(idx,1)}}this.numBytesInGPU-=this.computeBytes(shape,dtype);this.textureManager.releaseTexture(texture,texShape,texType)};MathBackendWebGL.prototype.acquireTexture=function(dataId,texShape,texType){var _a=this.texData.get(dataId),shape=_a.shape,dtype=_a.dtype;if(environment_1.ENV.get("WEBGL_PAGING_ENABLED")){this.lruDataGPU.push(dataId)}this.numBytesInGPU+=this.computeBytes(shape,dtype);return this.textureManager.acquireTexture(texShape,texType)};MathBackendWebGL.prototype.computeBytes=function(shape,dtype){return util.sizeFromShape(shape)*util.bytesPerElement(dtype)};return MathBackendWebGL}();exports.MathBackendWebGL=MathBackendWebGL;if(environment_1.ENV.get("IS_BROWSER")){environment_1.ENV.registerBackend("webgl",function(){return new MathBackendWebGL},2,tensor_1.setTensorTracker)}function float32ToTypedArray(a,dtype){if(dtype==="float32"||dtype==="complex64"){return a}else if(dtype==="int32"||dtype==="bool"){var result=dtype==="int32"?new Int32Array(a.length):new Uint8Array(a.length);for(var i=0;i<result.length;++i){result[i]=Math.round(a[i])}return result}else{throw new Error("Unknown dtype "+dtype)}}function typedArrayToFloat32(a,dtype){return a instanceof Float32Array?a:new Float32Array(a)}},{"../environment":51,"../globals":53,"../log":124,"../ops/array_ops_util":126,"../ops/axis_util":127,"../ops/concat_util":134,"../ops/reduce_util":151,"../ops/segment_util":156,"../ops/slice_util":159,"../ops/softmax":160,"../ops/tensor_ops":162,"../tensor":178,"../types":184,"../util":185,"./backend":67,"./backend_util":69,"./complex_util":71,"./non_max_suppression_impl":72,"./split_shared":73,"./topk_impl":74,"./webgl/argminmax_gpu":75,"./webgl/avg_pool_backprop_gpu":76,"./webgl/batchnorm_gpu":77,"./webgl/binaryop_complex_gpu":78,"./webgl/binaryop_gpu":79,"./webgl/clip_gpu":80,"./webgl/concat_gpu":81,"./webgl/conv_backprop_gpu":82,"./webgl/conv_backprop_gpu_depthwise":83,"./webgl/conv_gpu":84,"./webgl/conv_gpu_depthwise":85,"./webgl/crop_and_resize_gpu":86,"./webgl/cumsum_gpu":87,"./webgl/depth_to_space_gpu":88,"./webgl/encode_float_gpu":89,"./webgl/from_pixels_gpu":90,"./webgl/gather_gpu":91,"./webgl/gpgpu_context":92,"./webgl/gpgpu_math":93,"./webgl/gpgpu_util":94,"./webgl/lrn_gpu":95,"./webgl/lrn_grad_gpu":96,"./webgl/max_pool_backprop_gpu":97,"./webgl/mulmat_gpu":98,"./webgl/mulmat_packed_gpu":99,"./webgl/multinomial_gpu":100,"./webgl/onehot_gpu":101,"./webgl/pack_gpu":102,"./webgl/pad_gpu":103,"./webgl/pool_gpu":104,"./webgl/reduce_gpu":105,"./webgl/resize_bilinear_backprop_gpu":106,"./webgl/resize_bilinear_gpu":107,"./webgl/resize_nearest_neighbor_backprop_gpu":108,"./webgl/resize_nearest_neighbor_gpu":109,"./webgl/reverse_gpu":110,"./webgl/segment_gpu":111,"./webgl/select_gpu":112,"./webgl/slice_gpu":114,"./webgl/strided_slice_gpu":115,"./webgl/tex_util":116,"./webgl/texture_manager":117,"./webgl/tile_gpu":118,"./webgl/transpose_gpu":119,"./webgl/unaryop_gpu":120,"./webgl/unpack_gpu":121,"./webgl/webgl_util":122,"./where_impl":123}],71:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function mergeRealAndImagArrays(real,imag){if(real.length!==imag.length){throw new Error("Cannot merge real and imag arrays of different lengths. real:"+(real.length+", imag: "+imag.length+"."))}var result=new Float32Array(real.length*2);for(var i=0;i<result.length;i+=2){result[i]=real[i/2];result[i+1]=imag[i/2]}return result}exports.mergeRealAndImagArrays=mergeRealAndImagArrays;function splitRealAndImagArrays(complex){var real=new Float32Array(complex.length/2);var imag=new Float32Array(complex.length/2);for(var i=0;i<complex.length;i+=2){real[i/2]=complex[i];imag[i/2]=complex[i+1]}return{real:real,imag:imag}}exports.splitRealAndImagArrays=splitRealAndImagArrays},{}],72:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_ops_1=require("../ops/tensor_ops");function nonMaxSuppressionImpl(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){var candidates=Array.from(scores).map(function(score,boxIndex){return{score:score,boxIndex:boxIndex}}).filter(function(c){return c.score>scoreThreshold}).sort(function(c1,c2){return c2.score-c1.score});var selected=[];for(var i=0;i<candidates.length;i++){var _a=candidates[i],score=_a.score,boxIndex=_a.boxIndex;if(score<scoreThreshold){break}var ignoreCandidate=false;for(var j=selected.length-1;j>=0;--j){var iou=intersectionOverUnion(boxes,boxIndex,selected[j]);if(iou>=iouThreshold){ignoreCandidate=true;break}}if(!ignoreCandidate){selected.push(boxIndex);if(selected.length>=maxOutputSize){break}}}return tensor_ops_1.tensor1d(selected,"int32")}exports.nonMaxSuppressionImpl=nonMaxSuppressionImpl;function intersectionOverUnion(boxes,i,j){var iCoord=boxes.subarray(i*4,i*4+4);var jCoord=boxes.subarray(j*4,j*4+4);var yminI=Math.min(iCoord[0],iCoord[2]);var xminI=Math.min(iCoord[1],iCoord[3]);var ymaxI=Math.max(iCoord[0],iCoord[2]);var xmaxI=Math.max(iCoord[1],iCoord[3]);var yminJ=Math.min(jCoord[0],jCoord[2]);var xminJ=Math.min(jCoord[1],jCoord[3]);var ymaxJ=Math.max(jCoord[0],jCoord[2]);var xmaxJ=Math.max(jCoord[1],jCoord[3]);var areaI=(ymaxI-yminI)*(xmaxI-xminI);var areaJ=(ymaxJ-yminJ)*(xmaxJ-xminJ);if(areaI<=0||areaJ<=0){return 0}var intersectionYmin=Math.max(yminI,yminJ);var intersectionXmin=Math.max(xminI,xminJ);var intersectionYmax=Math.min(ymaxI,ymaxJ);var intersectionXmax=Math.min(xmaxI,xmaxJ);var intersectionArea=Math.max(intersectionYmax-intersectionYmin,0)*Math.max(intersectionXmax-intersectionXmin,0);return intersectionArea/(areaI+areaJ-intersectionArea)}},{"../ops/tensor_ops":162}],73:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function split(x,sizeSplits,axis){var begin=Array(x.rank).fill(0);var size=x.shape.slice();return sizeSplits.map(function(s){size[axis]=s;var slice=x.slice(begin,size);begin[axis]+=s;return slice})}exports.split=split},{}],74:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_ops_1=require("../ops/tensor_ops");var util_1=require("../util");function topkImpl(x,xShape,xDtype,k,sorted){var lastDim=xShape[xShape.length-1];var _a=[x.length/lastDim,lastDim],batch=_a[0],size=_a[1];var allTopKVals=util_1.getTypedArrayFromDType(xDtype,batch*k);var allTopKIndices=util_1.getTypedArrayFromDType("int32",batch*k);for(var b=0;b<batch;b++){var offset=b*size;var vals=x.subarray(offset,offset+size);var valAndInd=[];for(var i=0;i<vals.length;i++){valAndInd.push({value:vals[i],index:i})}valAndInd.sort(function(a,b){return b.value-a.value});var outOffset=b*k;var topKVals=allTopKVals.subarray(outOffset,outOffset+k);var topKIndices=allTopKIndices.subarray(outOffset,outOffset+k);for(var i=0;i<k;i++){topKVals[i]=valAndInd[i].value;topKIndices[i]=valAndInd[i].index}}var outputShape=xShape.slice();outputShape[outputShape.length-1]=k;return[tensor_ops_1.tensor(allTopKVals,outputShape,xDtype),tensor_ops_1.tensor(allTopKIndices,outputShape,"int32")]}exports.topkImpl=topkImpl},{"../ops/tensor_ops":162,"../util":185}],75:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ArgMinMaxProgram=function(){function ArgMinMaxProgram(reduceInfo,op,firstPass){this.variableNames=["A"];var windowSize=reduceInfo.windowSize;var batchSize=reduceInfo.batchSize;var inSize=reduceInfo.inSize;var outSize=Math.ceil(inSize/windowSize);if(!firstPass){this.variableNames.push("bestIndicesA")}this.outputShape=[batchSize,outSize];var compOp=op==="max"?">":"<";var indexSnippet=firstPass?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+windowSize+";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < "+windowSize+"; i++) {\n          int inIdx = "+indexSnippet+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+compOp+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}return ArgMinMaxProgram}();exports.ArgMinMaxProgram=ArgMinMaxProgram},{}],76:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var AvgPool2DBackpropProgram=function(){function AvgPool2DBackpropProgram(convInfo){this.variableNames=["dy"];this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=filterHeight-1-convInfo.padInfo.top;var padLeft=filterWidth-1-convInfo.padInfo.left;var avgMultiplier=1/(filterHeight*filterWidth);this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n      const float avgMultiplier = float("+avgMultiplier+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return AvgPool2DBackpropProgram}();exports.AvgPool2DBackpropProgram=AvgPool2DBackpropProgram},{}],77:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../../ops/broadcast_util");var BatchNormProgram=function(){function BatchNormProgram(xShape,meanShape,varianceShape,offsetShape,scaleShape,varianceEpsilon){this.outputShape=[];this.supportsBroadcasting=true;this.variableNames=["x","mean","variance"];broadcast_util.assertAndGetBroadcastShape(xShape,meanShape);broadcast_util.assertAndGetBroadcastShape(xShape,varianceShape);var offsetSnippet="0.0";if(offsetShape!=null){broadcast_util.assertAndGetBroadcastShape(xShape,offsetShape);this.variableNames.push("offset");offsetSnippet="getOffsetAtOutCoords()"}var scaleSnippet="1.0";if(scaleShape!=null){broadcast_util.assertAndGetBroadcastShape(xShape,scaleShape);this.variableNames.push("scale");scaleSnippet="getScaleAtOutCoords()"}this.outputShape=xShape;this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+offsetSnippet+";\n        float scale = "+scaleSnippet+";\n        float inv = scale * inversesqrt(variance + float("+varianceEpsilon+"));\n        setOutput((x - mean) * inv + offset);\n      }\n    "}return BatchNormProgram}();exports.BatchNormProgram=BatchNormProgram},{"../../ops/broadcast_util":130}],78:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../../ops/broadcast_util");exports.COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};var BinaryOpComplexProgram=function(){function BinaryOpComplexProgram(op,aShape,bShape){this.variableNames=["AReal","AImag","BReal","BImag"];this.supportsBroadcasting=true;this.outputShape=broadcast_util.assertAndGetBroadcastShape(aShape,bShape);this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+op+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}return BinaryOpComplexProgram}();exports.BinaryOpComplexProgram=BinaryOpComplexProgram},{"../../ops/broadcast_util":130}],79:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../../ops/broadcast_util");var CHECK_NAN_SNIPPET="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";exports.ADD="return a + b;";exports.SUB="return a - b;";exports.MUL="return a * b;";exports.DIV="if (a == b) return 1.0;\n  return a / b;";exports.INT_DIV="\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n";exports.POW="\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";exports.SQUARED_DIFFERENCE="return (a - b) * (a - b);";exports.EQUAL="return float(a == b);";exports.NOT_EQUAL="return float(a != b);";exports.LESS="return float(a < b);";exports.LESS_EQUAL="return float(a <= b);";exports.GREATER="return float(a > b);";exports.GREATER_EQUAL="return float(a >= b);";exports.LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);";exports.LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);";exports.MAX=CHECK_NAN_SNIPPET+"\n  return max(a, b);\n";exports.MIN=CHECK_NAN_SNIPPET+"\n  return min(a, b);\n";exports.MOD="if (b == 0.0) return NAN;\n  return mod(a, b);";exports.ATAN2=CHECK_NAN_SNIPPET+"\n  return atan(a, b);\n";exports.ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);";var BinaryOpProgram=function(){function BinaryOpProgram(op,aShape,bShape){this.variableNames=["A","B"];this.supportsBroadcasting=true;this.outputShape=broadcast_util.assertAndGetBroadcastShape(aShape,bShape);this.userCode="\n      uniform float NAN;\n      float binaryOperation(float a, float b) {\n        "+op+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}BinaryOpProgram.prototype.getCustomSetupFunc=function(){var _this=this;return function(gpgpu,webGLProgram){if(_this.startLoc==null){_this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"NAN");if(_this.startLoc==null){return}}gpgpu.gl.uniform1f(_this.startLoc,NaN)}};return BinaryOpProgram}();exports.BinaryOpProgram=BinaryOpProgram},{"../../ops/broadcast_util":130}],80:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ClipProgram=function(){function ClipProgram(aShape,min,max){this.variableNames=["A"];this.outputShape=aShape;this.userCode="\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, float("+min+"), float("+max+")));\n      }\n    "}return ClipProgram}();exports.ClipProgram=ClipProgram},{}],81:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var concat_util=require("../../ops/concat_util");var ConcatProgram=function(){function ConcatProgram(aShape,bShape){this.variableNames=["A","B"];this.outputShape=[];this.outputShape=concat_util.computeOutShape([aShape,bShape],1);this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < "+aShape[1]+") {\n          value = getA(yR, yC);\n        } else {\n          yC -= "+aShape[1]+";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    "}return ConcatProgram}();exports.ConcatProgram=ConcatProgram},{"../../ops/concat_util":134}],82:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Conv2DDerFilterProgram=function(){function Conv2DDerFilterProgram(convInfo){this.variableNames=["x","dy"];this.outputShape=convInfo.filterShape;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+convInfo.batchSize+"; b++) {\n          for (int yR = 0; yR < "+convInfo.outHeight+"; yR++) {\n            int xR = wR + yR * "+strideHeight+" - "+padTop+";\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+convInfo.outWidth+"; yC++) {\n              int xC = wC + yC * "+strideWidth+" - "+padLeft+";\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv2DDerFilterProgram}();exports.Conv2DDerFilterProgram=Conv2DDerFilterProgram;var Conv2DDerInputProgram=function(){function Conv2DDerInputProgram(convInfo){this.variableNames=["dy","W"];this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=filterHeight-1-convInfo.padInfo.top;var padLeft=filterWidth-1-convInfo.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+filterHeight+" - 1 - wR;\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+filterWidth+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+convInfo.outChannels+"; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv2DDerInputProgram}();exports.Conv2DDerInputProgram=Conv2DDerInputProgram},{}],83:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var DepthwiseConv2DDerFilterProgram=function(){function DepthwiseConv2DDerFilterProgram(convInfo){this.variableNames=["x","dy"];this.outputShape=convInfo.filterShape;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;var channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+channelMul+" + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < "+convInfo.batchSize+"; b++) {\n          for (int yR = 0; yR < "+convInfo.outHeight+"; yR++) {\n            int xR = wR + yR * "+strideHeight+" - "+padTop+";\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+convInfo.outWidth+"; yC++) {\n              int xC = wC + yC * "+strideWidth+" - "+padLeft+";\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return DepthwiseConv2DDerFilterProgram}();exports.DepthwiseConv2DDerFilterProgram=DepthwiseConv2DDerFilterProgram;var DepthwiseConv2DDerInputProgram=function(){function DepthwiseConv2DDerInputProgram(convInfo){this.variableNames=["dy","W"];this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=filterHeight-1-convInfo.padInfo.top;var padLeft=filterWidth-1-convInfo.padInfo.left;var channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+filterHeight+" - 1 - wR;\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+filterWidth+" - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+channelMul+"; dm++) {\n              int d2 = d1 * "+channelMul+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return DepthwiseConv2DDerInputProgram}();exports.DepthwiseConv2DDerInputProgram=DepthwiseConv2DDerInputProgram},{}],84:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Conv2DProgram=function(){function Conv2DProgram(convInfo){this.variableNames=["x","W"];this.outputShape=convInfo.outShape;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var dilationHeight=convInfo.dilationHeight;var dilationWidth=convInfo.dilationWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var inputDepthNearestVec4=Math.floor(convInfo.inChannels/4)*4;var inputDepthVec4Remainder=convInfo.inChannels%4;this.userCode="\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR * "+dilationHeight+";\n\n          if (xR < 0 || xR >= "+convInfo.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            int xC = xCCorner + wC * "+dilationWidth+";\n\n            if (xC < 0 || xC >= "+convInfo.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+inputDepthNearestVec4+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(inputDepthVec4Remainder===1)+") {\n              dotProd +=\n                getX(batch, xR, xC, "+inputDepthNearestVec4+") *\n                getW(wR, wC, "+inputDepthNearestVec4+", d2);\n            } else if ("+(inputDepthVec4Remainder===2)+") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, "+inputDepthNearestVec4+"),\n                getX(batch, xR, xC, "+inputDepthNearestVec4+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+inputDepthNearestVec4+", d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(inputDepthVec4Remainder===3)+") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, "+inputDepthNearestVec4+"),\n                getX(batch, xR, xC, "+inputDepthNearestVec4+" + 1),\n                getX(batch, xR, xC, "+inputDepthNearestVec4+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+inputDepthNearestVec4+", d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 1, d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv2DProgram}();exports.Conv2DProgram=Conv2DProgram},{}],85:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var DepthwiseConv2DProgram=function(){function DepthwiseConv2DProgram(convInfo){this.variableNames=["x","W"];this.outputShape=convInfo.outShape;var xNumRows=convInfo.inHeight;var xNumCols=convInfo.inWidth;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var dilationHeight=convInfo.dilationHeight;var dilationWidth=convInfo.dilationWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode="\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+channelMul+";\n        int q = d2 - d1 * "+channelMul+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR * "+dilationHeight+";\n\n          if (xR < 0 || xR >= "+xNumRows+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            int xC = xCCorner + wC * "+dilationWidth+";\n\n            if (xC < 0 || xC >= "+xNumCols+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return DepthwiseConv2DProgram}();exports.DepthwiseConv2DProgram=DepthwiseConv2DProgram},{}],86:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var CropAndResizeProgram=function(){function CropAndResizeProgram(imageShape,boxShape,cropSize,method,extrapolationValue){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];var batch=imageShape[0],imageHeight=imageShape[1],imageWidth=imageShape[2],depth=imageShape[3];var numBoxes=boxShape[0];var cropHeight=cropSize[0],cropWidth=cropSize[1];this.outputShape=[numBoxes,cropHeight,cropWidth,depth];var methodId=method==="bilinear"?1:0;var _a=[imageHeight-1+".0",imageWidth-1+".0"],inputHeightFloat=_a[0],inputWidthFloat=_a[1];var _b=cropHeight>1?[""+(imageHeight-1)/(cropHeight-1),"(y2-y1) * height_ratio","y1*"+inputHeightFloat+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+inputHeightFloat],heightRatio=_b[0],heightScale=_b[1],inY=_b[2];var _c=cropWidth>1?[""+(imageWidth-1)/(cropWidth-1),"(x2-x1) * width_ratio","x1*"+inputWidthFloat+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+inputWidthFloat],widthRatio=_c[0],widthScale=_c[1],inX=_c[2];this.userCode="\n      const float height_ratio = float("+heightRatio+");\n      const float width_ratio = float("+widthRatio+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+batch+") {\n          return;\n        }\n\n        float height_scale = "+heightScale+";\n        float width_scale = "+widthScale+";\n\n        float in_y = "+inY+";\n        if( in_y < 0.0 || in_y > "+inputHeightFloat+" ) {\n          setOutput(float("+extrapolationValue+"));\n          return;\n        }\n        float in_x = "+inX+";\n        if( in_x < 0.0 || in_x > "+inputWidthFloat+" ) {\n          setOutput(float("+extrapolationValue+"));\n          return;\n        }\n\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\n        if("+methodId+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\n\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          float newValue = top + (bottom - top) * fracRC.x;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestRC = ivec2(floor(\n            sourceFracIndexRC + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\n          setOutput(newValue);\n        }\n      }\n    "}return CropAndResizeProgram}();exports.CropAndResizeProgram=CropAndResizeProgram},{}],87:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var CumSumProgram=function(){function CumSumProgram(shape,exclusive,reverse){this.variableNames=["x"];this.outputShape=shape;var rank=shape.length;var finalDim=shape[shape.length-1];var comparator=reverse?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(reverse?"return "+finalDim+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+shader_compiler_1.getCoordsDataType(rank)+" coords = getOutputCoords();\n        int end = "+getFinalCoord(rank,"coords")+";\n        float val = 0.0;\n        for (int i = "+finalDim+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+comparator+" end) {\n            continue;\n          }\n          if (idx == end && "+exclusive+") {\n            continue;\n          }\n          "+getFinalCoord(rank,"coords")+" = idx;\n          val += getX("+getCoords(rank,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}return CumSumProgram}();exports.CumSumProgram=CumSumProgram;function getCoords(rank,name){if(rank===1){return""+name}else if(rank===2){return name+".x, "+name+".y"}else if(rank===3){return name+".x, "+name+".y, "+name+".z"}else if(rank===4){return name+".x, "+name+".y, "+name+".z, "+name+".w"}else{throw Error("Cumulative sum for rank "+rank+" is not yet supported")}}function getFinalCoord(rank,name){if(rank===1){return""+name}else if(rank===2){return name+".y"}else if(rank===3){return name+".z"}else if(rank===4){return name+".w"}else{throw Error("Cumulative sum for rank "+rank+" is not yet supported")}}},{"./shader_compiler":113}],88:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var DepthToSpaceProgram=function(){function DepthToSpaceProgram(outputShape,blockSize,dataFormat){this.variableNames=["x"];this.outputShape=[];this.outputShape=outputShape;this.blockSize=blockSize;this.dataFormat=dataFormat;this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+blockSize+";\n      int offset_h = imod(h, "+blockSize+");\n      int in_w = w / "+blockSize+";\n      int offset_w = imod(w, "+blockSize+");\n      int offset_d = (offset_h * "+blockSize+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}DepthToSpaceProgram.prototype.getHeightCoordString=function(){if(this.dataFormat==="NHWC"){return"coords[1]"}else{return"coords[2]"}};DepthToSpaceProgram.prototype.getWidthCoordString=function(){if(this.dataFormat==="NHWC"){return"coords[2]"}else{return"coords[3]"}};DepthToSpaceProgram.prototype.getDepthCoordString=function(){if(this.dataFormat==="NHWC"){return"coords[3]"}else{return"coords[1]"}};DepthToSpaceProgram.prototype.getOutputDepthSize=function(){if(this.dataFormat==="NHWC"){return this.outputShape[3]}else{return this.outputShape[1]}};DepthToSpaceProgram.prototype.getInputSamplingString=function(){if(this.dataFormat==="NHWC"){return"getX(b, in_h, in_w, in_d)"}else{return"getX(b, in_d, in_h, in_w)"}};return DepthToSpaceProgram}();exports.DepthToSpaceProgram=DepthToSpaceProgram},{}],89:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var EncodeFloatProgram=function(){function EncodeFloatProgram(outputShape){this.variableNames=["A"];this.outputShape=outputShape;this.userCode="\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        gl_FragColor = encode_float(x);\n      }\n    "}return EncodeFloatProgram}();exports.EncodeFloatProgram=EncodeFloatProgram},{}],90:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var FromPixelsProgram=function(){function FromPixelsProgram(outputShape){this.variableNames=["A"];var height=outputShape[0],width=outputShape[1];this.outputShape=outputShape;this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+width+".0, "+height+".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}return FromPixelsProgram}();exports.FromPixelsProgram=FromPixelsProgram},{}],91:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var GatherProgram=function(){function GatherProgram(aShape,indicesLength,axis){this.variableNames=["A","indices"];var outputShape=aShape.slice();outputShape[axis]=indicesLength;this.outputShape=outputShape;this.rank=outputShape.length;var dtype=shader_compiler_1.getCoordsDataType(this.rank);var sourceCoords=getSourceCoords(aShape,axis);this.userCode="\n      void main() {\n        "+dtype+" resRC = getOutputCoords();\n        setOutput(getA("+sourceCoords+"));\n      }\n    "}return GatherProgram}();exports.GatherProgram=GatherProgram;function getSourceCoords(aShape,axis){var rank=aShape.length;if(rank>4){throw Error("Gather for rank "+rank+" is not yet supported")}if(rank===1){return"int(getIndices(resRC))"}var currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w"];var sourceCoords=[];for(var i=0;i<aShape.length;i++){if(i===axis){sourceCoords.push("int(getIndices("+currentCoords[i]+"))")}else{sourceCoords.push(""+currentCoords[i])}}return sourceCoords.join()}},{"./shader_compiler":113}],92:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var util=require("../../util");var gpgpu_util=require("./gpgpu_util");var tex_util=require("./tex_util");var webgl_util=require("./webgl_util");var GPGPUContext=function(){function GPGPUContext(gl){this.outputTexture=null;this.program=null;this.disposed=false;this.autoDebugValidate=false;this.vertexAttrsAreBound=false;this.itemsToPoll=[];if(gl!=null){this.gl=gl}else{this.gl=gpgpu_util.createWebGLContext()}if(environment_1.ENV.get("WEBGL_VERSION")===1){this.textureFloatExtension=webgl_util.getExtensionOrThrow(this.gl,"OES_texture_float");this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float");if(!environment_1.ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")){this.textureHalfFloatExtension=webgl_util.getExtensionOrThrow(this.gl,"OES_texture_half_float");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}}else{this.colorBufferFloatExtension=webgl_util.getExtensionOrThrow(this.gl,"EXT_color_buffer_float")}this.loseContextExtension=webgl_util.getExtensionOrThrow(this.gl,"WEBGL_lose_context");this.vertexBuffer=gpgpu_util.createVertexBuffer(this.gl);this.indexBuffer=gpgpu_util.createIndexBuffer(this.gl);this.framebuffer=webgl_util.createFramebuffer(this.gl);this.textureConfig=gpgpu_util.getTextureConfig(this.gl,this.textureHalfFloatExtension)}GPGPUContext.prototype.dispose=function(){var _this=this;if(this.disposed){return}if(this.program!=null){console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram."+" This is probably a resource leak, delete the program with "+"GPGPUContext.deleteProgram before disposing.")}if(this.outputTexture!=null){console.warn("Disposing a GPGPUContext that still has a bound output matrix "+"texture.  This is probably a resource leak, delete the output "+"matrix texture with GPGPUContext.deleteMatrixTexture before "+"disposing.")}var gl=this.gl;webgl_util.callAndCheck(gl,function(){return gl.finish()});webgl_util.callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,null)});webgl_util.callAndCheck(gl,function(){return gl.deleteFramebuffer(_this.framebuffer)});webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,null)});webgl_util.callAndCheck(gl,function(){return gl.deleteBuffer(_this.vertexBuffer)});webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null)});webgl_util.callAndCheck(gl,function(){return gl.deleteBuffer(_this.indexBuffer)});this.loseContextExtension.loseContext();this.disposed=true};GPGPUContext.prototype.enableAutomaticDebugValidation=function(enabled){this.autoDebugValidate=enabled;webgl_util.enableDebugWebGLErrorChecking(enabled)};GPGPUContext.prototype.createFloat32MatrixTexture=function(rows,columns){this.throwIfDisposed();return gpgpu_util.createFloat32MatrixTexture(this.gl,rows,columns,this.textureConfig)};GPGPUContext.prototype.createFloat16MatrixTexture=function(rows,columns){this.throwIfDisposed();return gpgpu_util.createFloat16MatrixTexture(this.gl,rows,columns,this.textureConfig)};GPGPUContext.prototype.createUnsignedBytesMatrixTexture=function(rows,columns){this.throwIfDisposed();return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl,rows,columns,this.textureConfig)};GPGPUContext.prototype.uploadPixelDataToTexture=function(texture,pixels){this.throwIfDisposed();gpgpu_util.uploadPixelDataToTexture(this.gl,texture,pixels)};GPGPUContext.prototype.createPackedMatrixTexture=function(rows,columns){this.throwIfDisposed();return gpgpu_util.createPackedMatrixTexture(this.gl,rows,columns,this.textureConfig)};GPGPUContext.prototype.deleteMatrixTexture=function(texture){var _this=this;this.throwIfDisposed();if(this.outputTexture===texture){webgl_util.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);this.outputTexture=null}webgl_util.callAndCheck(this.gl,function(){return _this.gl.deleteTexture(texture)})};GPGPUContext.prototype.uploadMatrixToTexture=function(texture,rows,columns,matrix){this.throwIfDisposed();var numChannels=webgl_util.getNumChannels();return gpgpu_util.uploadMatrixToTexture(this.gl,texture,rows,columns,matrix,numChannels,this.textureConfig)};GPGPUContext.prototype.uploadMatrixToPackedTexture=function(texture,rows,columns,matrix){this.throwIfDisposed();return gpgpu_util.uploadMatrixToPackedTexture(this.gl,texture,rows,columns,matrix,this.textureConfig)};GPGPUContext.prototype.downloadFloat32MatrixFromOutputTexture=function(texture,rows,columns){var _this=this;return this.downloadMatrixDriver(texture,function(){return gpgpu_util.downloadFloat32MatrixFromOutputTexture(_this.gl,rows,columns,_this.textureConfig)})};GPGPUContext.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(texture,rows,columns){var _this=this;return this.downloadMatrixDriver(texture,function(){return gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(_this.gl,rows,columns,_this.textureConfig)})};GPGPUContext.prototype.downloadFloat32MatrixFromBuffer=function(buffer,rows,columns){return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl,buffer,rows,columns,this.textureConfig)};GPGPUContext.prototype.maybeCreateBufferFromTexture=function(texture,rows,columns){this.bindTextureToFrameBuffer(texture);var result=gpgpu_util.maybeCreateBufferFromOutputTexture(this.gl,texture,rows,columns,this.textureConfig);this.unbindTextureToFrameBuffer();return result};GPGPUContext.prototype.createAndWaitForFence=function(){var fenceContext=this.createFence(this.gl);return this.pollFence(fenceContext)};GPGPUContext.prototype.createFence=function(gl){var _this=this;var query;var isFencePassed;if(environment_1.ENV.get("WEBGL_FENCE_API_ENABLED")){var gl2_1=gl;var sync_1=gl2_1.fenceSync(gl2_1.SYNC_GPU_COMMANDS_COMPLETE,0);gl.flush();isFencePassed=function(){var status=gl2_1.clientWaitSync(sync_1,0,0);return status===gl2_1.ALREADY_SIGNALED||status===gl2_1.CONDITION_SATISFIED};query=sync_1}else if(environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){query=this.beginQuery();this.endQuery();isFencePassed=function(){return _this.isQueryAvailable(query,environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}}else{isFencePassed=function(){return true}}return{query:query,isFencePassed:isFencePassed}};GPGPUContext.prototype.downloadMatrixFromPackedTexture=function(texture,rows,columns){var _this=this;return this.downloadMatrixDriver(texture,function(){return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl,rows,columns,_this.textureConfig)})};GPGPUContext.prototype.createProgram=function(fragmentShaderSource){this.throwIfDisposed();var gl=this.gl;var fragmentShader=webgl_util.createFragmentShader(gl,fragmentShaderSource);var vertexShader=gpgpu_util.createVertexShader(gl);var program=webgl_util.createProgram(gl);webgl_util.callAndCheck(gl,function(){return gl.attachShader(program,vertexShader)});webgl_util.callAndCheck(gl,function(){return gl.attachShader(program,fragmentShader)});webgl_util.linkProgram(gl,program);if(this.autoDebugValidate){webgl_util.validateProgram(gl,program)}if(!this.vertexAttrsAreBound){this.setProgram(program);this.vertexAttrsAreBound=gpgpu_util.bindVertexProgramAttributeStreams(gl,this.program,this.vertexBuffer)}return program};GPGPUContext.prototype.deleteProgram=function(program){var _this=this;this.throwIfDisposed();if(program===this.program){this.program=null}if(program!=null){webgl_util.callAndCheck(this.gl,function(){return _this.gl.deleteProgram(program)})}};GPGPUContext.prototype.setProgram=function(program){var _this=this;this.throwIfDisposed();this.program=program;if(this.program!=null&&this.autoDebugValidate){webgl_util.validateProgram(this.gl,this.program)}webgl_util.callAndCheck(this.gl,function(){return _this.gl.useProgram(program)})};GPGPUContext.prototype.getUniformLocation=function(program,uniformName,shouldThrow){if(shouldThrow===void 0){shouldThrow=true}this.throwIfDisposed();if(shouldThrow){return webgl_util.getProgramUniformLocationOrThrow(this.gl,program,uniformName)}else{return webgl_util.getProgramUniformLocation(this.gl,program,uniformName)}};GPGPUContext.prototype.getAttributeLocation=function(program,attribute){var _this=this;this.throwIfDisposed();return webgl_util.callAndCheck(this.gl,function(){return _this.gl.getAttribLocation(program,attribute)})};GPGPUContext.prototype.getUniformLocationNoThrow=function(program,uniformName){this.throwIfDisposed();return this.gl.getUniformLocation(program,uniformName)};GPGPUContext.prototype.setInputMatrixTexture=function(inputMatrixTexture,uniformLocation,textureUnit){this.throwIfDisposed();this.throwIfNoProgram();webgl_util.bindTextureToProgramUniformSampler(this.gl,this.program,inputMatrixTexture,uniformLocation,textureUnit)};GPGPUContext.prototype.setOutputMatrixTexture=function(outputMatrixTexture,rows,columns){this.setOutputMatrixTextureDriver(outputMatrixTexture,columns,rows)};GPGPUContext.prototype.setOutputPackedMatrixTexture=function(outputPackedMatrixTexture,rows,columns){this.throwIfDisposed();var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];this.setOutputMatrixTextureDriver(outputPackedMatrixTexture,width,height)};GPGPUContext.prototype.setOutputMatrixWriteRegion=function(startRow,numRows,startColumn,numColumns){this.setOutputMatrixWriteRegionDriver(startColumn,startRow,numColumns,numRows)};GPGPUContext.prototype.setOutputPackedMatrixWriteRegion=function(startRow,numRows,startColumn,numColumns){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")};GPGPUContext.prototype.debugValidate=function(){if(this.program!=null){webgl_util.validateProgram(this.gl,this.program)}webgl_util.validateFramebuffer(this.gl)};GPGPUContext.prototype.executeProgram=function(){this.throwIfDisposed();this.throwIfNoProgram();var gl=this.gl;if(this.autoDebugValidate){this.debugValidate()}webgl_util.callAndCheck(gl,function(){return gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0)})};GPGPUContext.prototype.blockUntilAllProgramsCompleted=function(){var _this=this;this.throwIfDisposed();webgl_util.callAndCheck(this.gl,function(){return _this.gl.finish()})};GPGPUContext.prototype.getQueryTimerExtension=function(){if(this.disjointQueryTimerExtension==null){this.disjointQueryTimerExtension=webgl_util.getExtensionOrThrow(this.gl,environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")}return this.disjointQueryTimerExtension};GPGPUContext.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()};GPGPUContext.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()};GPGPUContext.prototype.beginQuery=function(){if(environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){var gl2=this.gl;var ext_1=this.getQueryTimerExtensionWebGL2();var query_1=gl2.createQuery();gl2.beginQuery(ext_1.TIME_ELAPSED_EXT,query_1);return query_1}var ext=this.getQueryTimerExtensionWebGL1();var query=ext.createQueryEXT();ext.beginQueryEXT(ext.TIME_ELAPSED_EXT,query);return query};GPGPUContext.prototype.endQuery=function(){if(environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){var gl2=this.gl;var ext_2=this.getQueryTimerExtensionWebGL2();gl2.endQuery(ext_2.TIME_ELAPSED_EXT);return}var ext=this.getQueryTimerExtensionWebGL1();ext.endQueryEXT(ext.TIME_ELAPSED_EXT)};GPGPUContext.prototype.waitForQueryAndGetTime=function(query){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4,util.repeatedTry(function(){return _this.isQueryAvailable(query,environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:_a.sent();return[2,this.getQueryTime(query,environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})};GPGPUContext.prototype.getQueryTime=function(query,queryTimerVersion){if(queryTimerVersion===0){return null}if(queryTimerVersion===2){var gl2=this.gl;var timeElapsedNanos=gl2.getQueryParameter(query,gl2.QUERY_RESULT);return timeElapsedNanos/1e6}else{var ext=this.getQueryTimerExtensionWebGL1();var timeElapsedNanos=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_EXT);return timeElapsedNanos/1e6}};GPGPUContext.prototype.isQueryAvailable=function(query,queryTimerVersion){if(queryTimerVersion===0){return true}if(queryTimerVersion===2){var gl2=this.gl;var ext=this.getQueryTimerExtensionWebGL2();var available=gl2.getQueryParameter(query,gl2.QUERY_RESULT_AVAILABLE);if(this.disjoint==null){this.disjoint=this.gl.getParameter(ext.GPU_DISJOINT_EXT)}return available&&!this.disjoint}else{var ext=this.getQueryTimerExtensionWebGL1();var available=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_AVAILABLE_EXT);if(this.disjoint==null){this.disjoint=this.gl.getParameter(ext.GPU_DISJOINT_EXT)}return available&&!this.disjoint}};GPGPUContext.prototype.pollFence=function(fenceContext){var _this=this;return new Promise(function(resolve){_this.addItemToPoll(function(){return fenceContext.isFencePassed()},function(){return resolve()})})};GPGPUContext.prototype.pollItems=function(){var index=binSearchLastTrue(this.itemsToPoll.map(function(x){return x.isDoneFn}));for(var i=0;i<=index;++i){var resolveFn=this.itemsToPoll[i].resolveFn;resolveFn()}this.itemsToPoll=this.itemsToPoll.slice(index+1)};GPGPUContext.prototype.addItemToPoll=function(isDoneFn,resolveFn){var _this=this;this.itemsToPoll.push({isDoneFn:isDoneFn,resolveFn:resolveFn});if(this.itemsToPoll.length>1){return}util.repeatedTry(function(){_this.pollItems();return _this.itemsToPoll.length===0})};GPGPUContext.prototype.bindTextureToFrameBuffer=function(texture){this.throwIfDisposed();webgl_util.bindColorTextureToFramebuffer(this.gl,texture,this.framebuffer);if(this.autoDebugValidate){webgl_util.validateFramebuffer(this.gl)}};GPGPUContext.prototype.unbindTextureToFrameBuffer=function(){if(this.outputTexture!=null){webgl_util.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer);if(this.autoDebugValidate){webgl_util.validateFramebuffer(this.gl)}}else{webgl_util.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}};GPGPUContext.prototype.downloadMatrixDriver=function(texture,downloadAndDecode){this.bindTextureToFrameBuffer(texture);var result=downloadAndDecode();this.unbindTextureToFrameBuffer();return result};GPGPUContext.prototype.setOutputMatrixTextureDriver=function(outputMatrixTextureMaybePacked,width,height){this.throwIfDisposed();var gl=this.gl;webgl_util.bindColorTextureToFramebuffer(gl,outputMatrixTextureMaybePacked,this.framebuffer);if(this.autoDebugValidate){webgl_util.validateFramebuffer(gl)}this.outputTexture=outputMatrixTextureMaybePacked;webgl_util.callAndCheck(gl,function(){return gl.viewport(0,0,width,height)});webgl_util.callAndCheck(gl,function(){return gl.scissor(0,0,width,height)})};GPGPUContext.prototype.setOutputMatrixWriteRegionDriver=function(x,y,width,height){var _this=this;this.throwIfDisposed();webgl_util.callAndCheck(this.gl,function(){return _this.gl.scissor(x,y,width,height)})};GPGPUContext.prototype.throwIfDisposed=function(){if(this.disposed){throw new Error("Attempted to use disposed GPGPUContext.")}};GPGPUContext.prototype.throwIfNoProgram=function(){if(this.program==null){throw new Error("No GPU program is currently set.")}};return GPGPUContext}();exports.GPGPUContext=GPGPUContext;function binSearchLastTrue(arr){var start=0;var end=arr.length-1;var best=-1;while(start<=end){var mid=start+end>>1;var isDone=arr[mid]();if(isDone){best=mid;start=mid+1}else{end=mid-1}}return best}exports.binSearchLastTrue=binSearchLastTrue},{"../../environment":51,"../../util":185,"./gpgpu_util":94,"./tex_util":116,"./webgl_util":122}],93:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var shader_compiler=require("./shader_compiler");var tex_util_1=require("./tex_util");function compileProgram(gpgpu,program,inputs,output){var userCode=program.userCode;var inputInfos=inputs.map(function(input,i){var shapeInfo={logicalShape:input.shape,texShape:input.isUniform?null:input.texData.texShape,isUniform:input.isUniform,isPacked:input.isUniform?false:input.texData.usage===tex_util_1.TextureUsage.PACK};return{name:program.variableNames[i],shapeInfo:shapeInfo}});var inShapeInfos=inputInfos.map(function(x){return x.shapeInfo});var outShapeInfo={logicalShape:output.shape,texShape:output.texData.texShape,isUniform:false,isPacked:output.texData.usage===tex_util_1.TextureUsage.PACK};var source=shader_compiler.makeShader(inputInfos,outShapeInfo,userCode,program.supportsBroadcasting===true);var webGLProgram=gpgpu.createProgram(source);var uniformLocations={};for(var i=0;i<program.variableNames.length;i++){var uniformName=program.variableNames[i];var shouldThrow=false;uniformLocations[uniformName]=gpgpu.getUniformLocation(webGLProgram,uniformName,shouldThrow)}return{program:program,source:source,webGLProgram:webGLProgram,uniformLocations:uniformLocations,gpgpu:gpgpu,inShapeInfos:inShapeInfos,outShapeInfo:outShapeInfo}}exports.compileProgram=compileProgram;function validateBinaryAndProgram(shapeInfos,inputs){if(shapeInfos.length!==inputs.length){throw Error("Binary was compiled with "+shapeInfos.length+" inputs, but "+("was executed with "+inputs.length+" inputs"))}shapeInfos.forEach(function(s,i){var shapeA=s.logicalShape;var input=inputs[i];var shapeB=input.shape;if(!util.arraysEqual(shapeA,shapeB)){throw Error("Binary was compiled with different shapes than "+("the current args. Shapes "+shapeA+" and "+shapeB+" must match"))}if(s.isUniform&&input.isUniform){return}var texShapeA=s.texShape;var texShapeB=input.isUniform?null:input.texData.texShape;if(!util.arraysEqual(texShapeA,texShapeB)){throw Error("Binary was compiled with different texture shapes than the"+(" current args. Shape "+texShapeA+" and "+texShapeB+" must match"))}})}function runProgram(binary,inputs,output,customSetup){validateBinaryAndProgram(binary.inShapeInfos,inputs);validateBinaryAndProgram([binary.outShapeInfo],[output]);var outTex=output.texData.texture;var outTexShape=output.texData.texShape;var gpgpu=binary.gpgpu;if(output.texData.usage===tex_util_1.TextureUsage.PACK){gpgpu.setOutputPackedMatrixTexture(outTex,outTexShape[0],outTexShape[1])}else{gpgpu.setOutputMatrixTexture(outTex,outTexShape[0],outTexShape[1])}gpgpu.setProgram(binary.webGLProgram);inputs.forEach(function(input,i){var variableName=binary.program.variableNames[i];var variableUniformLocation=binary.uniformLocations[variableName];if(variableUniformLocation!=null){if(input.isUniform){if(util.sizeFromShape(input.shape)===1){gpgpu.gl.uniform1f(variableUniformLocation,input.uniformValues[0])}else{var vals=input.uniformValues;if(!(vals instanceof Float32Array)){vals=new Float32Array(vals)}gpgpu.gl.uniform1fv(variableUniformLocation,vals)}return}var tex=input.texData.texture;gpgpu.setInputMatrixTexture(tex,variableUniformLocation,i)}});if(customSetup!=null){customSetup(gpgpu,binary.webGLProgram)}gpgpu.executeProgram()}exports.runProgram=runProgram;function makeShaderKey(program,inputs,output){var keyInputs="";inputs.concat(output).forEach(function(x){keyInputs+=x.shape+"_"+(x.isUniform?"uniform":x.texData.texShape)});var keyUserCode=program.userCode;var keyBroadcast=(program.supportsBroadcasting===true).toString();var key=program.constructor.name;key+="_"+keyBroadcast+"_"+keyInputs+"_"+keyUserCode;return key}exports.makeShaderKey=makeShaderKey},{"../../util":185,"./shader_compiler":113,"./tex_util":116}],94:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var tex_util=require("./tex_util");var webgl_util=require("./webgl_util");function getWebGLContextAttributes(){return{alpha:false,antialias:false,premultipliedAlpha:false,preserveDrawingBuffer:false,depth:false,stencil:false,failIfMajorPerformanceCaveat:true}}exports.getWebGLContextAttributes=getWebGLContextAttributes;function createWebGLContext(canvas){var attributes=getWebGLContextAttributes();var gl;if(canvas!=null){gl=webgl_util.createWebGLRenderingContextFromCanvas(canvas,attributes)}else{gl=webgl_util.createWebGLRenderingContext(attributes)}webgl_util.callAndCheck(gl,function(){return gl.disable(gl.DEPTH_TEST)});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.STENCIL_TEST)});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.BLEND)});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.DITHER)});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.POLYGON_OFFSET_FILL)});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.SAMPLE_COVERAGE)});webgl_util.callAndCheck(gl,function(){return gl.enable(gl.SCISSOR_TEST)});webgl_util.callAndCheck(gl,function(){return gl.enable(gl.CULL_FACE)});webgl_util.callAndCheck(gl,function(){return gl.cullFace(gl.BACK)});return gl}exports.createWebGLContext=createWebGLContext;function createVertexShader(gl){var vertexShaderSource="\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";return webgl_util.createVertexShader(gl,vertexShaderSource)}exports.createVertexShader=createVertexShader;function createVertexBuffer(gl){var vertexArray=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return webgl_util.createStaticVertexBuffer(gl,vertexArray)}exports.createVertexBuffer=createVertexBuffer;function createIndexBuffer(gl){var triangleVertexIndices=new Uint16Array([0,1,2,2,1,3]);return webgl_util.createStaticIndexBuffer(gl,triangleVertexIndices)}exports.createIndexBuffer=createIndexBuffer;function getTextureConfig(gl,textureHalfFloatExtension){var glany=gl;var internalFormatFloat;var internalFormatHalfFloat;var internalFormatPackedFloat;var textureFormatFloat;var downloadTextureFormat;var downloadUnpackNumChannels;var defaultNumChannels;var textureTypeHalfFloat;if(environment_1.ENV.get("WEBGL_VERSION")===2){internalFormatFloat=glany.R32F;internalFormatHalfFloat=glany.R16F;internalFormatPackedFloat=glany.RGBA32F;textureFormatFloat=glany.RED;downloadUnpackNumChannels=4;defaultNumChannels=1;textureTypeHalfFloat=glany.HALF_FLOAT}else{internalFormatFloat=gl.RGBA;internalFormatHalfFloat=gl.RGBA;internalFormatPackedFloat=glany.RGBA;textureFormatFloat=gl.RGBA;downloadUnpackNumChannels=4;defaultNumChannels=4;textureTypeHalfFloat=textureHalfFloatExtension!=null?textureHalfFloatExtension.HALF_FLOAT_OES:null}downloadTextureFormat=gl.RGBA;return{internalFormatFloat:internalFormatFloat,internalFormatHalfFloat:internalFormatHalfFloat,internalFormatPackedFloat:internalFormatPackedFloat,textureFormatFloat:textureFormatFloat,downloadTextureFormat:downloadTextureFormat,downloadUnpackNumChannels:downloadUnpackNumChannels,defaultNumChannels:defaultNumChannels,textureTypeHalfFloat:textureTypeHalfFloat}}exports.getTextureConfig=getTextureConfig;function createAndConfigureTexture(gl,width,height,internalFormat,textureFormat,textureType){webgl_util.validateTextureSize(gl,width,height);var texture=webgl_util.createTexture(gl);var tex2d=gl.TEXTURE_2D;webgl_util.callAndCheck(gl,function(){return gl.bindTexture(tex2d,texture)});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_MIN_FILTER,gl.NEAREST)});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_MAG_FILTER,gl.NEAREST)});webgl_util.callAndCheck(gl,function(){return gl.texImage2D(tex2d,0,internalFormat,width,height,0,textureFormat,textureType,null)});webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null)});return texture}function createFloat32MatrixTexture(gl,rows,columns,textureConfig){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];return createAndConfigureTexture(gl,width,height,textureConfig.internalFormatFloat,textureConfig.textureFormatFloat,gl.FLOAT)}exports.createFloat32MatrixTexture=createFloat32MatrixTexture;function createFloat16MatrixTexture(gl,rows,columns,textureConfig){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];return createAndConfigureTexture(gl,width,height,textureConfig.internalFormatFloat,textureConfig.textureFormatFloat,textureConfig.textureTypeHalfFloat)}exports.createFloat16MatrixTexture=createFloat16MatrixTexture;function createUnsignedBytesMatrixTexture(gl,rows,columns,textureConfig){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];return createAndConfigureTexture(gl,width,height,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE)}exports.createUnsignedBytesMatrixTexture=createUnsignedBytesMatrixTexture;function createPackedMatrixTexture(gl,rows,columns,textureConfig){var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];return createAndConfigureTexture(gl,width,height,textureConfig.internalFormatPackedFloat,gl.RGBA,gl.FLOAT)}exports.createPackedMatrixTexture=createPackedMatrixTexture;function bindVertexProgramAttributeStreams(gl,program,vertexBuffer){var posOffset=0;var uvOffset=3*4;var stride=3*4+2*4;webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer)});var success=webgl_util.bindVertexBufferToProgramAttribute(gl,program,"clipSpacePos",vertexBuffer,3,stride,posOffset);return success&&webgl_util.bindVertexBufferToProgramAttribute(gl,program,"uv",vertexBuffer,2,stride,uvOffset)}exports.bindVertexProgramAttributeStreams=bindVertexProgramAttributeStreams;function uploadPixelDataToTexture(gl,texture,pixels){webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,texture)});webgl_util.callAndCheck(gl,function(){return gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,pixels)});webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null)})}exports.uploadPixelDataToTexture=uploadPixelDataToTexture;function uploadDataToTexture(gl,texture,width,height,data,textureFormat){webgl_util.validateTextureSize(gl,width,height);webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,texture)});webgl_util.callAndCheck(gl,function(){return gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,width,height,textureFormat,gl.FLOAT,data)});webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null)})}function uploadMatrixToTexture(gl,texture,rows,columns,matrix,numChannels,textureConfig){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var unpackedArray;if(textureConfig.defaultNumChannels===1){unpackedArray=matrix}else{unpackedArray=new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length,numChannels));tex_util.encodeMatrixToUnpackedArray(matrix,unpackedArray,numChannels)}uploadDataToTexture(gl,texture,w,h,unpackedArray,textureConfig.textureFormatFloat)}exports.uploadMatrixToTexture=uploadMatrixToTexture;function uploadMatrixToPackedTexture(gl,texture,rows,columns,matrix,textureConfig){var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var packedRGBA=new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows,columns));tex_util.encodeMatrixToPackedRGBA(matrix,rows,columns,packedRGBA);uploadDataToTexture(gl,texture,w,h,packedRGBA,gl.RGBA)}exports.uploadMatrixToPackedTexture=uploadMatrixToPackedTexture;function maybeCreateBufferFromOutputTexture(gl,texture,rows,columns,textureConfig){var bufferOrTexture=texture;if(environment_1.ENV.get("WEBGL_VERSION")===2){var gl2_1=gl;var buffer_1=gl2_1.createBuffer();webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl2_1.PIXEL_PACK_BUFFER,buffer_1)});var bytesPerFloat=4;var bufferSizeBytes_1=bytesPerFloat*tex_util.getUnpackedArraySizeFromMatrixSize(rows*columns,textureConfig.downloadUnpackNumChannels);webgl_util.callAndCheck(gl,function(){return gl.bufferData(gl2_1.PIXEL_PACK_BUFFER,bufferSizeBytes_1,gl.STATIC_DRAW)});webgl_util.callAndCheck(gl,function(){return gl2_1.readPixels(0,0,columns,rows,gl.RGBA,gl.FLOAT,0)});webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl2_1.PIXEL_PACK_BUFFER,null)});bufferOrTexture=buffer_1}return bufferOrTexture}exports.maybeCreateBufferFromOutputTexture=maybeCreateBufferFromOutputTexture;function downloadFloat32MatrixFromBuffer(gl,buffer,rows,columns,textureConfig){var gl2=gl;var downloadTarget=new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows*columns,textureConfig.downloadUnpackNumChannels));gl2.bindBuffer(gl.ARRAY_BUFFER,buffer);gl2.getBufferSubData(gl.ARRAY_BUFFER,0,downloadTarget);gl2.bindBuffer(gl.ARRAY_BUFFER,null);var matrix=new Float32Array(rows*columns);tex_util.decodeMatrixFromUnpackedArray(downloadTarget,matrix,textureConfig.downloadUnpackNumChannels);return matrix}exports.downloadFloat32MatrixFromBuffer=downloadFloat32MatrixFromBuffer;function downloadFloat32MatrixFromOutputTexture(gl,rows,columns,textureConfig){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var downloadTarget=new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows*columns,textureConfig.downloadUnpackNumChannels));webgl_util.callAndCheck(gl,function(){return gl.readPixels(0,0,w,h,textureConfig.downloadTextureFormat,gl.FLOAT,downloadTarget)});var matrix=new Float32Array(rows*columns);tex_util.decodeMatrixFromUnpackedArray(downloadTarget,matrix,textureConfig.downloadUnpackNumChannels);return matrix}exports.downloadFloat32MatrixFromOutputTexture=downloadFloat32MatrixFromOutputTexture;function downloadByteEncodedFloatMatrixFromOutputTexture(gl,rows,columns,textureConfig){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var numChannels=4;var downloadTarget=new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows*columns,numChannels));webgl_util.callAndCheck(gl,function(){return gl.readPixels(0,0,w,h,textureConfig.downloadTextureFormat,gl.UNSIGNED_BYTE,downloadTarget)});return new Float32Array(downloadTarget.buffer)}exports.downloadByteEncodedFloatMatrixFromOutputTexture=downloadByteEncodedFloatMatrixFromOutputTexture;function downloadMatrixFromPackedOutputTexture(gl,rows,columns,textureConfig){var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var packedRGBA=new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows,columns));webgl_util.callAndCheck(gl,function(){return gl.readPixels(0,0,w,h,gl.RGBA,gl.FLOAT,packedRGBA)});var matrix=new Float32Array(rows*columns);return tex_util.decodeMatrixFromPackedRGBA(packedRGBA,rows,columns,matrix)}exports.downloadMatrixFromPackedOutputTexture=downloadMatrixFromPackedOutputTexture},{"../../environment":51,"./tex_util":116,"./webgl_util":122}],95:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var LRNProgram=function(){function LRNProgram(xShape,radius,bias,alpha,beta){this.variableNames=["x"];this.outputShape=[];var rad=radius;var maxD=xShape[3]-1;this.outputShape=xShape;var powOperator;var basis="float("+bias+") + float("+alpha+") * sum";if(beta===.5){powOperator="inversesqrt("+basis+")"}else if(beta===1){powOperator="1.0/("+basis+")"}else{powOperator="exp(log("+basis+") * float(-"+beta+"));"}this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+rad+"; j <= "+rad+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+maxD+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+powOperator+";\n        setOutput(val);\n      }\n    "}return LRNProgram}();exports.LRNProgram=LRNProgram},{}],96:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var LRNGradProgram=function(){function LRNGradProgram(inputShape,depthRadius,bias,alpha,beta){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=inputShape;this.depth=inputShape[3];this.depthRadius=depthRadius;this.bias=bias;this.alpha=alpha;this.beta=beta;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+depthRadius+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+depthRadius+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+alpha+") * norm + float("+bias+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+alpha+")\n                * float("+beta+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+beta+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}return LRNGradProgram}();exports.LRNGradProgram=LRNGradProgram},{}],97:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MaxPool2DBackpropProgram=function(){function MaxPool2DBackpropProgram(convInfo){this.variableNames=["dy","maxPos"];this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=filterHeight-1-convInfo.padInfo.top;var padLeft=filterWidth-1-convInfo.padInfo.left;var lastIndex=filterHeight*filterWidth-1;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+lastIndex+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+filterWidth+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return MaxPool2DBackpropProgram}();exports.MaxPool2DBackpropProgram=MaxPool2DBackpropProgram},{}],98:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MatMulProgram=function(){function MatMulProgram(aShape,bShape,transposeA,transposeB){if(transposeA===void 0){transposeA=false}if(transposeB===void 0){transposeB=false}this.variableNames=["matrixA","matrixB"];var batchSize=aShape[0];var outerShapeA=transposeA?aShape[2]:aShape[1];var outerShapeB=transposeB?bShape[1]:bShape[2];var sharedDim=transposeA?aShape[1]:aShape[2];this.outputShape=[batchSize,outerShapeA,outerShapeB];var aSnippetFromOffset=function(vec4Offset,indexVar){return transposeA?"batch, "+indexVar+" + "+vec4Offset+", aRow":"batch, aRow, "+indexVar+" + "+vec4Offset};var bSnippetFromOffset=function(vec4Offset,indexVar){return transposeB?"batch, bCol, "+indexVar+" + "+vec4Offset:"batch, "+indexVar+" + "+vec4Offset+", bCol"};var sharedDimNearestVec4=Math.floor(sharedDim/4)*4;var sharedDimVec4Remainder=sharedDim%4;this.userCode=" float dotARowBCol(int batch, int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < "+sharedDimNearestVec4+"; i += 4) {\n        vec4 a = vec4(\n          getMatrixA("+aSnippetFromOffset(0,"i")+"),\n          getMatrixA("+aSnippetFromOffset(1,"i")+"),\n          getMatrixA("+aSnippetFromOffset(2,"i")+"),\n          getMatrixA("+aSnippetFromOffset(3,"i")+")\n        );\n        vec4 b = vec4(\n          getMatrixB("+bSnippetFromOffset(0,"i")+"),\n          getMatrixB("+bSnippetFromOffset(1,"i")+"),\n          getMatrixB("+bSnippetFromOffset(2,"i")+"),\n          getMatrixB("+bSnippetFromOffset(3,"i")+")\n        );\n\n        result += dot(a, b);\n      }\n\n      if ("+(sharedDimVec4Remainder===1)+") {\n        result += getMatrixA("+aSnippetFromOffset(0,sharedDimNearestVec4)+") *\n          getMatrixB("+bSnippetFromOffset(0,sharedDimNearestVec4)+");\n      } else if ("+(sharedDimVec4Remainder===2)+") {\n        vec2 a = vec2(\n          getMatrixA("+aSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixA("+aSnippetFromOffset(1,sharedDimNearestVec4)+")\n        );\n        vec2 b = vec2(\n          getMatrixB("+bSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixB("+bSnippetFromOffset(1,sharedDimNearestVec4)+")\n        );\n        result += dot(a, b);\n      } else if ("+(sharedDimVec4Remainder===3)+") {\n        vec3 a = vec3(\n          getMatrixA("+aSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixA("+aSnippetFromOffset(1,sharedDimNearestVec4)+"),\n          getMatrixA("+aSnippetFromOffset(2,sharedDimNearestVec4)+")\n        );\n        vec3 b = vec3(\n          getMatrixB("+bSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixB("+bSnippetFromOffset(1,sharedDimNearestVec4)+"),\n          getMatrixB("+bSnippetFromOffset(2,sharedDimNearestVec4)+")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec3 resBRC = getOutputCoords();\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\n    }\n    "}return MatMulProgram}();exports.MatMulProgram=MatMulProgram},{}],99:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MatMulPackedProgram=function(){function MatMulPackedProgram(aShape,bShape,outputShape,transposeA,transposeB){if(transposeA===void 0){transposeA=false}if(transposeB===void 0){transposeB=false}this.variableNames=["matrixA","matrixB"];this.outputShape=outputShape;var sharedDim=transposeA?aShape[0]:aShape[1];var sharedDimensionPacked=Math.ceil(sharedDim/2);var aSample=transposeA?"resultUV.t, center":"center, resultUV.t";var bSample=transposeB?"center, resultUV.s":"resultUV.s, center";var aSwizzle=transposeA?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"];var bSwizzle=transposeB?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];this.userCode="\n      const float sharedDimension = "+sharedDimensionPacked+".0;\n\n      vec4 dot2x2ARowBCol() {\n        vec4 result = vec4(0);\n        for (int ii = 0; ii < "+sharedDimensionPacked+"; ii++) {\n          float i = float(ii);\n          float center = (i + 0.5) / sharedDimension;\n          vec4 a = texture2D(matrixA, vec2("+aSample+"));\n          vec4 b = texture2D(matrixB, vec2("+bSample+"));\n\n          result += ("+aSwizzle[0]+" * "+bSwizzle[0]+") + ("+aSwizzle[1]+" * "+bSwizzle[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        gl_FragColor = dot2x2ARowBCol();\n      }\n    "}return MatMulPackedProgram}();exports.MatMulPackedProgram=MatMulPackedProgram},{}],100:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MultinomialProgram=function(){function MultinomialProgram(batchSize,numOutcomes,numSamples){this.variableNames=["probs"];this.outputShape=[batchSize,numSamples];this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(numOutcomes-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(numOutcomes-1)+"));\n      }\n    "}MultinomialProgram.prototype.getCustomSetupFunc=function(seed){var _this=this;return function(gpgpu,webGLProgram){if(_this.seedLoc==null){_this.seedLoc=gpgpu.getUniformLocation(webGLProgram,"seed")}gpgpu.gl.uniform1f(_this.seedLoc,seed)}};return MultinomialProgram}();exports.MultinomialProgram=MultinomialProgram},{}],101:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var OneHotProgram=function(){function OneHotProgram(numIndices,depth,onValue,offValue){this.variableNames=["indices"];this.outputShape=[numIndices,depth];this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+offValue+"), float("+onValue+"),\n                      float(index == coords.y)));\n      }\n    "}return OneHotProgram}();exports.OneHotProgram=OneHotProgram},{}],102:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var PackProgram=function(){function PackProgram(outputShape){this.variableNames=["A"];this.outputShape=outputShape;this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        int r = rc.x;\n        int c = rc.y;\n        int rp1 = r + 1;\n        int cp1 = c + 1;\n\n        bool cEdge = cp1 >= "+outputShape[1]+";\n        bool rEdge = rp1 >= "+outputShape[0]+";\n\n        gl_FragColor = vec4(\n            getA(r, c),\n            cEdge ? 0. : getA(r, cp1),\n            rEdge ? 0. : getA(rp1, c),\n            rEdge || cEdge ? 0. : getA(rp1, cp1)\n          );\n      }\n    "}return PackProgram}();exports.PackProgram=PackProgram},{}],103:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var PadProgram=function(){function PadProgram(xShape,paddings,constantValue){this.variableNames=["x"];this.outputShape=paddings.map(function(p,i){return p[0]+xShape[i]+p[1]});var rank=xShape.length;var type=shader_compiler_1.getCoordsDataType(rank);var start=paddings.map(function(p){return p[0]}).join(",");var end=paddings.map(function(p,i){return p[0]+xShape[i]}).join(",");var unpackedCoords=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,rank);if(rank===1){this.userCode="\n        int start = "+start+";\n        int end = "+end+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+constantValue+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";return}this.userCode="\n      "+type+" start = "+type+"("+start+");\n      "+type+" end = "+type+"("+end+");\n\n      void main() {\n        "+type+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+constantValue+"));\n        } else {\n          "+type+" coords = outC - start;\n          setOutput(getX("+unpackedCoords+"));\n        }\n      }\n    "}return PadProgram}();exports.PadProgram=PadProgram},{"./shader_compiler":113}],104:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Pool2DProgram=function(){function Pool2DProgram(convInfo,poolType,computePositions){this.variableNames=["x"];if(poolType==="avg"&&computePositions){throw new Error("Cannot compute positions for average pool.")}var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;this.outputShape=convInfo.outShape;var isAvgPool=poolType==="avg";var initializationValue="0.0";if(!isAvgPool){initializationValue="-1.0 / 0.0"}if(computePositions){var compareOp_1=">=";this.userCode="\n        const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n        const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+filterHeight+"; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+filterWidth+"; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value "+compareOp_1+" currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+filterWidth+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";return}var compareOp="max";var returnValue=poolType+"("+poolType+"("+poolType+"("+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(poolType==="avg"){returnValue="avgValue / count"}var filterWidthNearestVec4=Math.floor(filterWidth/4)*4;var filterWidthVec4Remainder=filterWidth%4;var updateSnippet="\n      if ("+isAvgPool+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = "+compareOp+"(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n      const float initializationValue = "+initializationValue+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+convInfo.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+initializationValue+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+convInfo.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidthNearestVec4+"; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            "+updateSnippet+"\n          }\n\n          int xC = xCCorner + "+filterWidthNearestVec4+";\n          if ("+(filterWidthVec4Remainder===1)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          } else if ("+(filterWidthVec4Remainder===2)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          } else if ("+(filterWidthVec4Remainder===3)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          }\n        }\n        setOutput("+returnValue+");\n      }\n    "}return Pool2DProgram}();exports.Pool2DProgram=Pool2DProgram},{}],105:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ReduceProgram=function(){function ReduceProgram(reduceInfo,reduceType){this.variableNames=["x"];var windowSize=reduceInfo.windowSize;var batchSize=reduceInfo.batchSize;var inSize=reduceInfo.inSize;var outSize=Math.ceil(inSize/windowSize);this.outputShape=[batchSize,outSize];var initializationValue="0.0";var compareOp="";if(reduceType==="min"){initializationValue="1.0 / 0.0";compareOp="min"}else if(reduceType==="max"){initializationValue="-1.0 / 0.0";compareOp="max"}var returnValue=reduceType+"("+reduceType+"("+reduceType+"("+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(reduceType==="sum"){returnValue="sumValue"}else if(reduceType==="all"){returnValue="allValue"}else if(reduceType==="any"){returnValue="anyValue"}var windowSizeNearestVec4=Math.floor(windowSize/4)*4;var windowSizeVec4Remainder=windowSize%4;var updateSnippet="\n      if ("+(reduceType==="sum")+") {\n        sumValue += dot(values, ones);\n      } else {\n        minMaxValue = "+compareOp+"(values, minMaxValue);\n      }\n    ";var vecType="vec4";if(reduceType==="all"){initializationValue="1.0";updateSnippet="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ";vecType="bvec4"}else if(reduceType==="any"){initializationValue="0.0";updateSnippet="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ";vecType="bvec4"}var checkOutOfBounds="";if(inSize%windowSize>0){checkOutOfBounds="\n        if (inIdx < 0 || inIdx >= "+inSize+") {\n          return initializationValue;\n        }\n      "}this.userCode="\n      const float initializationValue = "+initializationValue+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+checkOutOfBounds+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+windowSize+";\n\n        vec4 minMaxValue = vec4("+initializationValue+");\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+windowSizeNearestVec4+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+updateSnippet+"\n        }\n\n        int inIdx = inOffset + "+windowSizeNearestVec4+";\n        if ("+(windowSizeVec4Remainder===1)+") {\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+updateSnippet+"\n        } else if ("+(windowSizeVec4Remainder===2)+") {\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+updateSnippet+"\n        } else if ("+(windowSizeVec4Remainder===3)+") {\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+updateSnippet+"\n        }\n        setOutput("+returnValue+");\n      }\n    "}return ReduceProgram}();exports.ReduceProgram=ReduceProgram},{}],106:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ResizeBilinearBackpropProgram=function(){function ResizeBilinearBackpropProgram(dy,x,alignCorners){this.variableNames=["dy"];this.outputShape=[];this.outputShape=x.shape;var _a=x.shape,xHeight=_a[1],xWidth=_a[2];var _b=dy.shape,yHeight=_b[1],yWidth=_b[2];var effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth];var effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth];var heightScale=effectiveXSize[0]/effectiveYSize[0];var widthScale=effectiveXSize[1]/effectiveYSize[1];var invHeightScale=1/heightScale;var invWidthScale=1/widthScale;var winHeight=Math.ceil(invHeightScale)*2+2;var winWidth=Math.ceil(invWidthScale)*2+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+heightScale+");\n        const float widthScale = float("+widthScale+");\n\n        const float invHeightScale = float("+invHeightScale+");\n        const float invWidthScale = float("+invWidthScale+");\n\n        const int winHeight = int("+winHeight+");\n        const int winWidth = int("+winWidth+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+yHeight+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+yWidth+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(xHeight-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(xWidth-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}return ResizeBilinearBackpropProgram}();exports.ResizeBilinearBackpropProgram=ResizeBilinearBackpropProgram},{}],107:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ResizeBilinearProgram=function(){function ResizeBilinearProgram(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"];this.outputShape=[];var batch=inputShape[0],oldHeight=inputShape[1],oldWidth=inputShape[2],depth=inputShape[3];this.outputShape=[batch,newHeight,newWidth,depth];var effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth];var effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+effectiveInSize[0]/effectiveOutSize[0]+",\n          "+effectiveInSize[1]/effectiveOutSize[1]+");\n      const vec2 inputShapeRC = vec2("+oldHeight+".0, "+oldWidth+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}return ResizeBilinearProgram}();exports.ResizeBilinearProgram=ResizeBilinearProgram},{}],108:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ResizeNearestNeigborBackpropProgram=function(){function ResizeNearestNeigborBackpropProgram(dy,x,alignCorners){this.variableNames=["dy"];this.outputShape=[];this.outputShape=x.shape;var _a=x.shape,xHeight=_a[1],xWidth=_a[2];var _b=dy.shape,yHeight=_b[1],yWidth=_b[2];var effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth];var effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth];var heightScale=effectiveXSize[0]/effectiveYSize[0];var widthScale=effectiveXSize[1]/effectiveYSize[1];var invHeightScale=1/heightScale;var invWidthScale=1/widthScale;var winHeight=Math.ceil(invHeightScale)*2+2;var winWidth=Math.ceil(invWidthScale)*2+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+heightScale+");\n        const float widthScale = float("+widthScale+");\n\n        const float invHeightScale = float("+invHeightScale+");\n        const float invWidthScale = float("+invWidthScale+");\n\n        const int winHeight = int("+winHeight+");\n        const int winWidth = int("+winWidth+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+yHeight+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+yWidth+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+effectiveXSize[0]+") *\n                (float(dyR) / float("+effectiveYSize[0]+"));\n\n            float sourceFracCol =\n                float("+effectiveXSize[1]+") *\n                  (float(dyC) / float("+effectiveYSize[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+xHeight+") - 1),\n                "+alignCorners+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+xWidth+") - 1),\n                "+alignCorners+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}return ResizeNearestNeigborBackpropProgram}();exports.ResizeNearestNeigborBackpropProgram=ResizeNearestNeigborBackpropProgram},{}],109:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ResizeNearestNeighborProgram=function(){function ResizeNearestNeighborProgram(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"];this.outputShape=[];var batch=inputShape[0],oldHeight=inputShape[1],oldWidth=inputShape[2],depth=inputShape[3];this.outputShape=[batch,newHeight,newWidth,depth];var effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth];var effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];var roundBase=alignCorners?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+effectiveInSize[0]/effectiveOutSize[0]+",\n          "+effectiveInSize[1]/effectiveOutSize[1]+");\n      const vec2 inputShapeRC = vec2("+oldHeight+".0, "+oldWidth+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+roundBase+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}return ResizeNearestNeighborProgram}();exports.ResizeNearestNeighborProgram=ResizeNearestNeighborProgram},{}],110:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var ReverseProgram=function(){function ReverseProgram(xShape,axis){this.variableNames=["x"];var rank=xShape.length;if(rank>4){throw new Error("WebGL backend: Reverse of rank-"+rank+" tensor is not yet supported")}this.outputShape=xShape;if(rank===1){this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+xShape[0]+" - coord - 1));\n        }\n      ";return}var getInCoord=function(i){if(axis.indexOf(i)!==-1&&xShape[i]!==1){return xShape[i]+" - coords["+i+"] - 1"}return"coords["+i+"]"};var inCoords=xShape.map(function(_,i){return getInCoord(i)}).join(",");var type=shader_compiler_1.getCoordsDataType(rank);this.userCode="\n      void main() {\n        "+type+" coords = getOutputCoords();\n        setOutput(getX("+inCoords+"));\n      }\n    "}return ReverseProgram}();exports.ReverseProgram=ReverseProgram},{"./shader_compiler":113}],111:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var SegmentOpProgram=function(){function SegmentOpProgram(segOpInfo,segOpType){this.variableNames=["x","segmentIds"];var windowSize=segOpInfo.windowSize;var batchSize=segOpInfo.batchSize;var inSize=segOpInfo.inSize;var numSegments=segOpInfo.numSegments;var outSize=numSegments*Math.ceil(inSize/windowSize);this.outputShape=[batchSize,outSize];var initializationValue="0.0";var returnValue="sumValue";var windowSizeNearestVec4=Math.floor(windowSize/4)*4;var windowSizeVec4Remainder=windowSize%4;var updateSnippet="\n        sumValue += dot(values, filter);\n    ";var checkValueOutOfBounds="";if(inSize%windowSize>0){checkValueOutOfBounds="\n        if (inIdx < 0 || inIdx >= "+inSize+") {\n          return initializationValue;\n        }\n      "}var checkSegmentIdOutOfBounds="";if(inSize%windowSize>0){checkSegmentIdOutOfBounds="\n        if (inIdx < 0 || inIdx >= "+inSize+") {\n          return -1.0;\n        }\n      "}this.userCode="\n      const float initializationValue = "+initializationValue+";\n\n      float getValue(int batch, int inIdx) {\n        "+checkValueOutOfBounds+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+checkSegmentIdOutOfBounds+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+numSegments+")) * float("+windowSize+"));\n        int currentSeg = int(mod(float(outIdx), float("+numSegments+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+windowSizeNearestVec4+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+updateSnippet+"\n        }\n\n        int inIdx = inOffset + "+windowSizeNearestVec4+";\n        if ("+(windowSizeVec4Remainder===1)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+updateSnippet+"\n        } else if ("+(windowSizeVec4Remainder===2)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+updateSnippet+"\n        } else if ("+(windowSizeVec4Remainder===3)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+updateSnippet+"\n        }\n        setOutput("+returnValue+");\n      }\n    "}return SegmentOpProgram}();exports.SegmentOpProgram=SegmentOpProgram},{}],112:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var SelectProgram=function(){function SelectProgram(cRank,shape,rank){this.variableNames=["c","a","b"];this.outputShape=shape;var cCoords;var abCoords;if(rank>4){throw Error("Where for rank "+rank+" is not yet supported")}if(rank===1){abCoords="resRC";cCoords="resRC"}else{var currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w"];var cCoordVars=[];var abCoordVars=[];for(var i=0;i<shape.length;i++){abCoordVars.push(""+currentCoords[i]);if(i<cRank){cCoordVars.push(""+currentCoords[i])}}cCoords=cCoordVars.join();abCoords=abCoordVars.join()}var dtype=shader_compiler_1.getCoordsDataType(rank);this.userCode="\n      void main() {\n        "+dtype+" resRC = getOutputCoords();\n        float cVal = getC("+cCoords+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+abCoords+"));\n        } else {\n          setOutput(getB("+abCoords+"));\n        }\n      }\n    "}return SelectProgram}();exports.SelectProgram=SelectProgram},{"./shader_compiler":113}],113:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../../ops/broadcast_util");var util=require("../../util");function makeShader(inputsInfo,outputShape,userCode,broadcast){var inputPrefixSnippet=inputsInfo.map(function(x){var size=util.sizeFromShape(x.shapeInfo.logicalShape);if(x.shapeInfo.isUniform){return"uniform float "+x.name+(size>1?"["+size+"]":"")+";"}return"uniform sampler2D "+x.name+";"});inputPrefixSnippet=inputPrefixSnippet.join("\n");var inputSamplingSnippet=inputsInfo.map(function(x){return getInputSamplingSnippet(x,outputShape,broadcast)}).join("\n");var outTexShape=outputShape.texShape;var outputSamplingSnippet;if(outputShape.isPacked){outputSamplingSnippet=getPackedOutputSamplingSnippet(outputShape.logicalShape,outTexShape)}else{outputSamplingSnippet=getOutputSamplingSnippet(outputShape.logicalShape,outTexShape)}var source=[SHADER_PREFIX,FLOAT_TEXTURE_SAMPLE_SNIPPET,FLOAT_TEXTURE_SETOUTPUT_SNIPPET,inputPrefixSnippet,outputSamplingSnippet,inputSamplingSnippet,userCode].join("\n");return source}exports.makeShader=makeShader;function getSamplerFromInInfo(inInfo){var shape=inInfo.shapeInfo.logicalShape;switch(shape.length){case 0:return getSamplerScalar(inInfo);case 1:return getSampler1D(inInfo);case 2:return getSampler2D(inInfo);case 3:return getSampler3D(inInfo);case 4:return getSampler4D(inInfo);case 5:return getSampler5D(inInfo);case 6:return getSampler6D(inInfo);default:throw new Error(shape.length+"-D input sampling"+" is not yet supported")}}function getInputSamplingSnippet(inInfo,outShapeInfo,broadcast){var res=getSamplerFlat(inInfo);res+=getSamplerFromInInfo(inInfo);if(broadcast||util.arraysEqual(inInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape)){res+=getSamplerAtOutputCoords(inInfo,outShapeInfo,broadcast)}return res}function getPackedOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return getOutputScalarCoords();case 2:return getOutputPacked2DCoords(outShape,outTexShape);default:throw new Error(outShape.length+"-D output packed sampling is not yet supported")}}function getOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(outShape,outTexShape);case 2:return getOutput2DCoords(outShape,outTexShape);case 3:return getOutput3DCoords(outShape,outTexShape);case 4:return getOutput4DCoords(outShape,outTexShape);case 5:return getOutput5DCoords(outShape,outTexShape);case 6:return getOutput6DCoords(outShape,outTexShape);default:throw new Error(outShape.length+"-D output sampling is not yet supported")}}var SAMPLE_1D_SNIPPET="\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_2D_SNIPPET="\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_3D_SNIPPET="\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_4D_SNIPPET="\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_5D_SNIPPET="\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 +\n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_6D_SNIPPET="\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int stride4,\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\n    stride3 + depth3 * stride4 + depth4;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var FLOAT_TEXTURE_SAMPLE_SNIPPET="\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n";var FLOAT_TEXTURE_SETOUTPUT_SNIPPET="\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";var SHADER_PREFIX="\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  struct ivec6\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n    int v;\n  };\n\n  bool isNaN(float val) {\n    return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  "+SAMPLE_1D_SNIPPET+"\n  "+SAMPLE_2D_SNIPPET+"\n  "+SAMPLE_3D_SNIPPET+"\n  "+SAMPLE_4D_SNIPPET+"\n  "+SAMPLE_5D_SNIPPET+"\n  "+SAMPLE_6D_SNIPPET+"\n";function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getOutput1DCoords(shape,texShape){if(texShape[0]===1){return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+texShape[1]+".0);\n      }\n    "}if(texShape[1]===1){return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+texShape[0]+".0);\n      }\n    "}return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      return resTexRC.x * "+texShape[1]+" + resTexRC.y;\n    }\n  "}function getOutput3DCoords(shape,texShape){var stride0=shape[1]*shape[2];var stride1=shape[2];return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      int r = index / "+stride0+";\n      index -= r * "+stride0+";\n      int c = index / "+stride1+";\n      int d = index - c * "+stride1+";\n      return ivec3(r, c, d);\n    }\n  "}function getOutput4DCoords(shape,texShape){var stride2=shape[3];var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n\n      int r = index / "+stride0+";\n      index -= r * "+stride0+";\n\n      int c = index / "+stride1+";\n      index -= c * "+stride1+";\n\n      int d = index / "+stride2+";\n      int d2 = index - d * "+stride2+";\n\n      return ivec4(r, c, d, d2);\n    }\n  "}function getOutput5DCoords(shape,texShape){var stride3=shape[4];var stride2=shape[3]*stride3;var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+texShape[0]+",\n                             "+texShape[1]+"));\n\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n\n      int r = index / "+stride0+";\n      index -= r * "+stride0+";\n\n      int c = index / "+stride1+";\n      index -= c * "+stride1+";\n\n      int d = index / "+stride2+";\n      index -= d * "+stride2+";\n\n      int d2 = index  / "+stride3+";\n      int d3 = index - d2 * "+stride3+";\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}function getOutput6DCoords(shape,texShape){var stride4=shape[5];var stride3=shape[4]*stride4;var stride2=shape[3]*stride3;var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n\n      int r = index / "+stride0+";\n      index -= r * "+stride0+";\n\n      int c = index / "+stride1+";\n      index -= c * "+stride1+";\n\n      int d = index / "+stride2+";\n      index -= d * "+stride2+";\n\n      int d2 = index / "+stride3+";\n      index -= d2 * "+stride3+";\n\n      int d3 = index / "+stride4+";\n      int d4 = index - d3 * "+stride4+";\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}function getOutputPacked2DCoords(shape,texShape){return"\n    ivec2 getOutputCoords() {\n      return 2 * ivec2(resultUV.yx * vec2("+Math.ceil(texShape[0]/2)+", "+Math.ceil(texShape[1]/2)+"));\n    }\n  "}function getOutput2DCoords(shape,texShape){if(util.arraysEqual(shape,texShape)){return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+texShape[0]+", "+texShape[1]+"));\n      }\n    "}if(shape[1]===1){return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "}if(shape[0]===1){return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "}return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      int r = index / "+shape[1]+";\n      int c = index - r * "+shape[1]+";\n      return ivec2(r, c);\n    }\n  "}function getSamplerScalar(inputInfo){var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);if(inputInfo.shapeInfo.isUniform){return"float "+funcName+"() {return "+texName+";}"}return"\n    float "+funcName+"() {\n      return sampleTexture("+texName+", halfCR);\n    }\n  "}function getSampler1D(inputInfo){var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);return"\n    float "+funcName+"(int index) {\n      return "+funcName+"Flat(index);\n    }\n  "}function getSampler2D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);var texShape=inputInfo.shapeInfo.texShape;if(texShape!=null&&util.arraysEqual(shape,texShape)){var texNumR_1=texShape[0];var texNumC_1=texShape[1];return"\n    float "+funcName+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+texNumC_1+".0, "+texNumR_1+".0);\n      return sampleTexture("+texName+", uv);\n    }\n  "}var _a=util.squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;var squeezedShape=newShape;if(squeezedShape.length<shape.length){var newInputInfo=squeezeInputInfo(inputInfo,squeezedShape);var params=["row","col"];return"\n      "+getSamplerFromInInfo(newInputInfo)+"\n      float "+funcName+"(int row, int col) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform){return"\n      float "+funcName+"(int row, int col) {\n        int index = row * "+shape[1]+" + col;\n        return "+funcName+"Flat(index);\n      }\n    "}var texNumR=texShape[0];var texNumC=texShape[1];if(texNumC===1){return"\n    float "+funcName+"(int row, int col) {\n      int index = row * "+shape[1]+" + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / "+texNumR+".0);\n      return sampleTexture("+texName+", uv);\n    }\n  "}if(texNumR===1){return"\n    float "+funcName+"(int row, int col) {\n      int index = row * "+shape[1]+" + col;\n      vec2 uv = vec2((float(index) + 0.5) / "+texNumC+".0, 0.5);\n      return sampleTexture("+texName+", uv);\n    }\n  "}return"\n  float "+funcName+"(int row, int col) {\n    vec2 uv = UVfrom2D("+texNumR+", "+texNumC+", "+shape[1]+", row, col);\n    return sampleTexture("+texName+", uv);\n  }\n"}function getSampler3D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);var stride0=shape[1]*shape[2];var stride1=shape[2];var _a=util.squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;var squeezedShape=newShape;if(squeezedShape.length<shape.length){var newInputInfo=squeezeInputInfo(inputInfo,squeezedShape);var params=["row","col","depth"];return"\n        "+getSamplerFromInInfo(newInputInfo)+"\n        float "+funcName+"(int row, int col, int depth) {\n          return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n        }\n      "}if(inputInfo.shapeInfo.isUniform){return"\n      float "+funcName+"(int row, int col, int depth) {\n        int index = row * "+stride0+" + col * "+stride1+" + depth;\n        return "+funcName+"Flat(index);\n      }\n    "}var texShape=inputInfo.shapeInfo.texShape;var texNumR=texShape[0];var texNumC=texShape[1];if(texNumC===stride0){return"\n        float "+funcName+"(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * "+stride1+" + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+texNumC+".0, "+texNumR+".0);\n          return sampleTexture("+texName+", uv);\n        }\n      "}if(texNumC===stride1){return"\n    float "+funcName+"(int row, int col, int depth) {\n      int texR = row * "+shape[1]+" + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+texNumC+".0, "+texNumR+".0);\n      return sampleTexture("+texName+", uv);\n    }\n  "}return"\n      float "+funcName+"(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            "+texNumR+", "+texNumC+", "+stride0+", "+stride1+", row, col, depth);\n        return sampleTexture("+texName+", uv);\n      }\n  "}function getSampler4D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);var stride2=shape[3];var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;var _a=util.squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;if(newShape.length<shape.length){var newInputInfo=squeezeInputInfo(inputInfo,newShape);var params=["row","col","depth","depth2"];return"\n      "+getSamplerFromInInfo(newInputInfo)+"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform){return"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        int index = row * "+stride0+" + col * "+stride1+" +\n            depth * "+stride2+" + depth2;\n        return "+funcName+"Flat(index);\n      }\n    "}var texShape=inputInfo.shapeInfo.texShape;var texNumR=texShape[0];var texNumC=texShape[1];if(texNumC===stride0){return"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * "+stride1+" + depth * "+stride2+" + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}if(texNumC===stride2){return"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        int texR = row * "+shape[1]*shape[2]+" + col * "+shape[2]+" + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}return"\n    float "+funcName+"(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D("+texNumR+", "+texNumC+", "+stride0+", "+stride1+",\n          "+stride2+", row, col, depth, depth2);\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getSampler5D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);var stride3=shape[4];var stride2=shape[3]*stride3;var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;var _a=util.squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;if(newShape.length<shape.length){var newInputInfo=squeezeInputInfo(inputInfo,newShape);var params=["row","col","depth","depth2","depth3"];return"\n      "+getSamplerFromInInfo(newInputInfo)+"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform){return"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        int index = row * "+stride0+" + col * "+stride1+" +\n            depth * "+stride2+" + depth2 * "+stride3+" + depth3;\n        return "+funcName+"Flat(index);\n      }\n    "}var texShape=inputInfo.shapeInfo.texShape;var texNumR=texShape[0];var texNumC=texShape[1];if(texNumC===stride0){return"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        int texC = col * "+stride1+" + depth * "+stride2+" +\n                   depth2 * "+stride3+" + depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}if(texNumC===stride3){return"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row * "+shape[1]*shape[2]+" + col * "+shape[2]+" +\n                   depth * "+shape[3]+" + depth2;\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}return"\n    float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D("+texNumR+", "+texNumC+", "+stride0+", "+stride1+",\n          "+stride2+", "+stride3+", row, col, depth, depth2, depth3);\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getSampler6D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);var stride4=shape[5];var stride3=shape[4]*stride4;var stride2=shape[3]*stride3;var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;var _a=util.squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;if(newShape.length<shape.length){var newInputInfo=squeezeInputInfo(inputInfo,newShape);var params=["row","col","depth","depth2","depth3","depth4"];return"\n      "+getSamplerFromInInfo(newInputInfo)+"\n      float "+funcName+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform){return"\n      float "+funcName+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = row * "+stride0+" + col * "+stride1+" +\n            depth * "+stride2+" + depth2 * "+stride3+" + depth3 * "+stride3+"\n            + depth4\n        return "+funcName+"Flat(index);\n      }\n    "}var texShape=inputInfo.shapeInfo.texShape;var texNumR=texShape[0];var texNumC=texShape[1];if(texNumC===stride0){return"\n      float "+funcName+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        int texC = col * "+stride1+" + depth * "+stride2+" + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}if(texNumC===stride4){return"\n      float "+funcName+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row * "+shape[1]*shape[2]+" + col * "+shape[2]+" + depth;\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}return"\n    float "+funcName+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      vec2 uv = UVfrom6D("+texNumR+", "+texNumC+", "+stride0+", "+stride1+",\n          "+stride2+", "+stride3+", "+stride4+"\n          ,row, col, depth, depth2, depth3, depth4);\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getSamplerFlat(inputInfo){var texName=inputInfo.name;var funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1)+"Flat";var inSize=util.sizeFromShape(inputInfo.shapeInfo.logicalShape);if(inputInfo.shapeInfo.isUniform){if(inSize===1){return"float "+funcName+"(int index) {return "+texName+";}"}return"\n      float "+funcName+"(int index) {\n        for (int i = 0; i < "+inSize+"; i++) {\n          if (i == index) {\n            return "+texName+"[i];\n          }\n        }\n      }\n    "}var texShape=inputInfo.shapeInfo.texShape;var tNumR=texShape[0];var tNumC=texShape[1];if(tNumC===1&&tNumR===1){return"\n      float "+funcName+"(int index) {\n        return sampleTexture("+texName+", halfCR);\n      }\n    "}if(tNumC===1){return"\n      float "+funcName+"(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / "+tNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    "}if(tNumR===1){return"\n      float "+funcName+"(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / "+tNumC+".0, 0.5);\n        return sampleTexture("+texName+", uv);\n      }\n    "}return"\n    float "+funcName+"(int index) {\n      vec2 uv = UVfrom1D("+tNumR+", "+tNumC+", index);\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getBroadcastOutputCoordsSampler(inputInfo,outShapeInfo,texFuncSnippet,funcName){var inRank=inputInfo.shapeInfo.logicalShape.length;var outRank=outShapeInfo.logicalShape.length;var type="int";if(outRank===2){type="ivec2"}else if(outRank===3){type="ivec3"}else if(outRank===4){type="ivec4"}var broadcastDims=broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape);var rankDiff=outRank-inRank;var coordsSnippet;if(inRank===0){coordsSnippet=""}else if(outRank<2&&broadcastDims.length>=1){coordsSnippet="coords = 0;"}else{coordsSnippet=broadcastDims.map(function(d){return"coords["+(d+rankDiff)+"] = 0;"}).join("\n")}var unpackedCoordsSnippet="";if(outRank<2&&inRank>0){unpackedCoordsSnippet="coords"}else{unpackedCoordsSnippet=inputInfo.shapeInfo.logicalShape.map(function(s,i){return"coords["+(i+rankDiff)+"]"}).join(", ")}return"\n    float "+funcName+"() {\n      "+type+" coords = getOutputCoords();\n      "+coordsSnippet+"\n      return get"+texFuncSnippet+"("+unpackedCoordsSnippet+");\n    }\n  "}function getSamplerAtOutputCoords(inputInfo,outShapeInfo,supportsBroadcasting){var texName=inputInfo.name;var texFuncSnippet=texName.charAt(0).toUpperCase()+texName.slice(1);var funcName="get"+texFuncSnippet+"AtOutCoords";var broadcastDims=broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape);var inRank=inputInfo.shapeInfo.logicalShape.length;var outRank=outShapeInfo.logicalShape.length;var doBroadcast=supportsBroadcasting&&(outRank>inRank||broadcastDims.length>0);var broadcastOverOuter=broadcast_util.broadcastDimsAreOuter(broadcastDims);var isUniform=inputInfo.shapeInfo.isUniform;if(doBroadcast&&!broadcastOverOuter){return getBroadcastOutputCoordsSampler(inputInfo,outShapeInfo,texFuncSnippet,funcName)}var inSize=util.sizeFromShape(inputInfo.shapeInfo.logicalShape);var broadcastSnippet="";if(doBroadcast&&broadcastOverOuter){broadcastSnippet="\n        int mainPart = index / "+inSize+";\n        index -= mainPart * "+inSize+";\n      "}var outTexShape=outShapeInfo.texShape;if(isUniform){if(inSize===1){return"float "+funcName+"() {return "+texName+";}"}return"\n      float "+funcName+"() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                              vec2("+outTexShape[0]+", "+outTexShape[1]+"));\n        int index = resTexRC.x * "+outTexShape[1]+" + resTexRC.y;\n        "+broadcastSnippet+"\n        return get"+texFuncSnippet+"Flat(index);\n      }\n    "}var inTexShape=inputInfo.shapeInfo.texShape;if(util.arraysEqual(inTexShape,outTexShape)){return"\n      float "+funcName+"() {\n        return sampleTexture("+texName+", resultUV);\n      }\n    "}return"\n    float "+funcName+"() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+outTexShape[0]+", "+outTexShape[1]+"));\n      int index = resTexRC.x * "+outTexShape[1]+" + resTexRC.y;\n      "+broadcastSnippet+"\n      int texR = index / "+inTexShape[1]+";\n      int texC = index - texR * "+inTexShape[1]+";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2("+inTexShape[1]+".0, "+inTexShape[0]+".0);\n\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getCoordsDataType(rank){if(rank<=1){return"int"}else if(rank===2){return"ivec2"}else if(rank===3){return"ivec3"}else if(rank===4){return"ivec4"}else if(rank===5){return"ivec5"}else if(rank===6){return"ivec6"}else{throw Error("GPU for rank "+rank+" is not yet supported")}}exports.getCoordsDataType=getCoordsDataType;function squeezeInputInfo(inInfo,squeezedShape){var newInputInfo=JSON.parse(JSON.stringify(inInfo));newInputInfo.shapeInfo.logicalShape=squeezedShape;return newInputInfo}function getSqueezedParams(params,keptDims){return keptDims.map(function(d){return params[d]}).join(", ")}},{"../../ops/broadcast_util":130,"../../util":185}],114:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var SliceProgram=function(){function SliceProgram(destSize){this.variableNames=["source"];this.outputShape=destSize;this.rank=destSize.length;var dtype=shader_compiler_1.getCoordsDataType(this.rank);var sourceCoords=getCoords(this.rank);this.userCode="\n      uniform "+dtype+" start;\n\n      void main() {\n        "+dtype+" sourceLoc = start + getOutputCoords();\n        setOutput(getSource("+sourceCoords+"));\n      }\n    "}SliceProgram.prototype.getCustomSetupFunc=function(start){var _this=this;if(start.length!==this.rank){throw Error("The rank ("+this.rank+") of the program must match the "+("length of start ("+start.length+")"))}return function(gpgpu,webGLProgram){if(_this.startLoc==null){_this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"start");if(_this.startLoc==null){return}}if(_this.rank===1){gpgpu.gl.uniform1i(_this.startLoc,start[0])}else if(_this.rank===2){gpgpu.gl.uniform2i(_this.startLoc,start[0],start[1])}else if(_this.rank===3){gpgpu.gl.uniform3i(_this.startLoc,start[0],start[1],start[2])}else if(_this.rank===4){gpgpu.gl.uniform4i(_this.startLoc,start[0],start[1],start[2],start[3])}else{throw Error("Slicing for rank "+_this.rank+" is not yet supported")}}};return SliceProgram}();exports.SliceProgram=SliceProgram;function getCoords(rank){if(rank===1){return"sourceLoc"}else if(rank===2){return"sourceLoc.x, sourceLoc.y"}else if(rank===3){return"sourceLoc.x, sourceLoc.y, sourceLoc.z"}else if(rank===4){return"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w"}else{throw Error("Slicing for rank "+rank+" is not yet supported")}}},{"./shader_compiler":113}],115:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var StridedSliceProgram=function(){function StridedSliceProgram(begin,strides,size,shrinkAxis){this.variableNames=["x"];var shape=size.filter(function(v,index){return shrinkAxis.indexOf(index)===-1});this.outputShape=shape;var rank=size.length;var inputDtype=shader_compiler_1.getCoordsDataType(size.length);var dtype=shader_compiler_1.getCoordsDataType(shape.length);var newCoords="";if(rank===1){newCoords="coords * strides + begin"}else{var outputAxis_1=0;newCoords=size.map(function(_,i){if(shrinkAxis.indexOf(i)===-1){outputAxis_1++;return shape.length===1?"coords * strides["+i+"] + begin["+i+"]":"coords["+(outputAxis_1-1)+"] * strides["+i+"] + begin["+i+"]"}else{return"begin["+i+"]"}}).join(",")}this.userCode="\n      "+inputDtype+" begin = "+inputDtype+"("+begin+");\n      "+inputDtype+" strides = "+inputDtype+"("+strides+");\n\n      void main() {\n        "+dtype+" coords = getOutputCoords();\n        setOutput(getX("+newCoords+"));\n      }\n    "}return StridedSliceProgram}();exports.StridedSliceProgram=StridedSliceProgram},{"./shader_compiler":113}],116:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var TextureUsage;(function(TextureUsage){TextureUsage[TextureUsage["RENDER"]=0]="RENDER";TextureUsage[TextureUsage["UPLOAD"]=1]="UPLOAD";TextureUsage[TextureUsage["PIXELS"]=2]="PIXELS";TextureUsage[TextureUsage["DOWNLOAD"]=3]="DOWNLOAD";TextureUsage[TextureUsage["PACK"]=4]="PACK"})(TextureUsage=exports.TextureUsage||(exports.TextureUsage={}));var PhysicalTextureType;(function(PhysicalTextureType){PhysicalTextureType[PhysicalTextureType["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16";PhysicalTextureType[PhysicalTextureType["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32";PhysicalTextureType[PhysicalTextureType["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE";PhysicalTextureType[PhysicalTextureType["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32"})(PhysicalTextureType=exports.PhysicalTextureType||(exports.PhysicalTextureType={}));function getUnpackedMatrixTextureShapeWidthHeight(rows,columns){return[columns,rows]}exports.getUnpackedMatrixTextureShapeWidthHeight=getUnpackedMatrixTextureShapeWidthHeight;function getUnpackedArraySizeFromMatrixSize(matrixSize,channelsPerTexture){return matrixSize*channelsPerTexture}exports.getUnpackedArraySizeFromMatrixSize=getUnpackedArraySizeFromMatrixSize;function getColorMatrixTextureShapeWidthHeight(rows,columns){return[columns*4,rows]}exports.getColorMatrixTextureShapeWidthHeight=getColorMatrixTextureShapeWidthHeight;function getMatrixSizeFromUnpackedArraySize(unpackedSize,channelsPerTexture){if(unpackedSize%channelsPerTexture!==0){throw new Error("unpackedSize ("+unpackedSize+") must be a multiple of "+(""+channelsPerTexture))}return unpackedSize/channelsPerTexture}exports.getMatrixSizeFromUnpackedArraySize=getMatrixSizeFromUnpackedArraySize;function encodeMatrixToUnpackedArray(matrix,unpackedArray,channelsPerTexture){var requiredSize=getUnpackedArraySizeFromMatrixSize(matrix.length,channelsPerTexture);if(unpackedArray.length<requiredSize){throw new Error("unpackedArray length ("+unpackedArray.length+") must be >= "+(""+requiredSize))}var dst=0;for(var src=0;src<matrix.length;++src){unpackedArray[dst]=matrix[src];dst+=channelsPerTexture}}exports.encodeMatrixToUnpackedArray=encodeMatrixToUnpackedArray;function decodeMatrixFromUnpackedArray(unpackedArray,matrix,channelsPerTexture){var requiredSize=getMatrixSizeFromUnpackedArraySize(unpackedArray.length,channelsPerTexture);if(matrix.length<requiredSize){throw new Error("matrix length ("+matrix.length+") must be >= "+requiredSize)}var dst=0;for(var src=0;src<unpackedArray.length;src+=channelsPerTexture){matrix[dst++]=unpackedArray[src]}}exports.decodeMatrixFromUnpackedArray=decodeMatrixFromUnpackedArray;function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray,matrix,channels){var requiredSize=unpackedArray.length*channels/4;if(matrix.length<requiredSize){throw new Error("matrix length ("+matrix.length+") must be >= "+requiredSize)}var dst=0;for(var src=0;src<unpackedArray.length;src+=4){for(var c=0;c<channels;c++){matrix[dst++]=unpackedArray[src+c]}}}exports.decodeMatrixFromUnpackedColorRGBAArray=decodeMatrixFromUnpackedColorRGBAArray;function getPackedMatrixTextureShapeWidthHeight(rows,columns){return[Math.ceil(columns/2),Math.ceil(rows/2)]}exports.getPackedMatrixTextureShapeWidthHeight=getPackedMatrixTextureShapeWidthHeight;function getPackedRGBAArraySizeFromMatrixShape(rows,columns){var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];return w*h*4}exports.getPackedRGBAArraySizeFromMatrixShape=getPackedRGBAArraySizeFromMatrixShape;function encodeMatrixToPackedRGBA(matrix,rows,columns,packedRGBA){var requiredSize=getPackedRGBAArraySizeFromMatrixShape(rows,columns);if(packedRGBA.length<requiredSize){throw new Error("packedRGBA length ("+packedRGBA.length+") must be >= "+requiredSize)}var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),textureWidth=_a[0],textureHeight=_a[1];var oddWidth=columns%2===1;var oddHeight=rows%2===1;var widthInFullBlocks=Math.floor(columns/2);var heightInFullBlocks=Math.floor(rows/2);{var dstStride=oddWidth?4:0;var oneRow=columns;var dst=0;for(var blockY=0;blockY<heightInFullBlocks;++blockY){var matrixSrcRow=blockY*2*columns;for(var blockX=0;blockX<widthInFullBlocks;++blockX){var matrixSrcCol=blockX*2;var src=matrixSrcRow+matrixSrcCol;packedRGBA[dst]=matrix[src];packedRGBA[dst+1]=matrix[src+1];packedRGBA[dst+2]=matrix[src+oneRow];packedRGBA[dst+3]=matrix[src+oneRow+1];dst+=4}dst+=dstStride}}if(oddWidth){var src=columns-1;var dst=(textureWidth-1)*4;var srcStride=2*columns;var dstStride=textureWidth*4;for(var blockY=0;blockY<heightInFullBlocks;++blockY){packedRGBA[dst]=matrix[src];packedRGBA[dst+2]=matrix[src+columns];src+=srcStride;dst+=dstStride}}if(oddHeight){var src=(rows-1)*columns;var dst=(textureHeight-1)*textureWidth*4;for(var blockX=0;blockX<widthInFullBlocks;++blockX){packedRGBA[dst++]=matrix[src++];packedRGBA[dst++]=matrix[src++];dst+=2}}if(oddWidth&&oddHeight){packedRGBA[packedRGBA.length-4]=matrix[matrix.length-1]}return packedRGBA}exports.encodeMatrixToPackedRGBA=encodeMatrixToPackedRGBA;function decodeMatrixFromPackedRGBA(packedRGBA,rows,columns,matrix){var requiredSize=rows*columns;if(requiredSize<matrix.length){throw new Error("matrix length ("+matrix.length+") must be >= "+requiredSize)}var oddWidth=columns%2===1;var oddHeight=rows%2===1;var widthInFullBlocks=Math.floor(columns/2);var heightInFullBlocks=Math.floor(rows/2);var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),textureWidth=_a[0],textureHeight=_a[1];{var srcStride=oddWidth?4:0;var dstStride=columns+(oddWidth?1:0);var src=0;var dstRow1=0;var dstRow2=columns;for(var blockY=0;blockY<heightInFullBlocks;++blockY){for(var blockX=0;blockX<widthInFullBlocks;++blockX){matrix[dstRow1++]=packedRGBA[src++];matrix[dstRow1++]=packedRGBA[src++];matrix[dstRow2++]=packedRGBA[src++];matrix[dstRow2++]=packedRGBA[src++]}src+=srcStride;dstRow1+=dstStride;dstRow2+=dstStride}}if(oddWidth){var src=(textureWidth-1)*4;var dst=columns-1;var srcStride=textureWidth*4;var dstStride=2*columns;for(var blockY=0;blockY<heightInFullBlocks;++blockY){matrix[dst]=packedRGBA[src];matrix[dst+columns]=packedRGBA[src+2];src+=srcStride;dst+=dstStride}}if(oddHeight){var src=(textureHeight-1)*textureWidth*4;var dst=(rows-1)*columns;for(var blockX=0;blockX<widthInFullBlocks;++blockX){matrix[dst++]=packedRGBA[src++];matrix[dst++]=packedRGBA[src++];src+=2}}if(oddWidth&&oddHeight){matrix[matrix.length-1]=packedRGBA[packedRGBA.length-4]}return matrix}exports.decodeMatrixFromPackedRGBA=decodeMatrixFromPackedRGBA},{}],117:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var tex_util_1=require("./tex_util");var TextureManager=function(){function TextureManager(gpgpu){this.gpgpu=gpgpu;this.numUsedTextures=0;this.numFreeTextures=0;this.freeTextures={};this.logEnabled=false;this.usedTextures={}}TextureManager.prototype.acquireTexture=function(shapeRC,usage){var physicalTexType=getPhysicalFromLogicalTextureType(usage);var shapeKey=getKeyFromTextureShape(shapeRC,physicalTexType);if(!(shapeKey in this.freeTextures)){this.freeTextures[shapeKey]=[]}if(!(shapeKey in this.usedTextures)){this.usedTextures[shapeKey]=[]}if(this.freeTextures[shapeKey].length>0){this.numFreeTextures--;this.numUsedTextures++;this.log();var newTexture_1=this.freeTextures[shapeKey].shift();this.usedTextures[shapeKey].push(newTexture_1);return newTexture_1}this.numUsedTextures++;this.log();var newTexture;if(physicalTexType===tex_util_1.PhysicalTextureType.PACKED_2X2_FLOAT32){newTexture=this.gpgpu.createPackedMatrixTexture(shapeRC[0],shapeRC[1])}else if(physicalTexType===tex_util_1.PhysicalTextureType.UNPACKED_FLOAT32){newTexture=this.gpgpu.createFloat32MatrixTexture(shapeRC[0],shapeRC[1])}else if(physicalTexType===tex_util_1.PhysicalTextureType.UNPACKED_FLOAT16){newTexture=this.gpgpu.createFloat16MatrixTexture(shapeRC[0],shapeRC[1])}else if(physicalTexType===tex_util_1.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE){newTexture=this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0],shapeRC[1])}this.usedTextures[shapeKey].push(newTexture);return newTexture};TextureManager.prototype.releaseTexture=function(texture,shape,logicalTexType){if(this.freeTextures==null){return}var physicalTexType=getPhysicalFromLogicalTextureType(logicalTexType);var shapeKey=getKeyFromTextureShape(shape,physicalTexType);if(!(shapeKey in this.freeTextures)){this.freeTextures[shapeKey]=[]}this.freeTextures[shapeKey].push(texture);this.numFreeTextures++;this.numUsedTextures--;var texList=this.usedTextures[shapeKey];var texIndex=texList.indexOf(texture);if(texIndex<0){throw new Error("Cannot release a texture that was never provided by this "+"texture manager")}texList.splice(texIndex,1);this.log()};TextureManager.prototype.log=function(){if(!this.logEnabled){return}var total=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+total+")")};TextureManager.prototype.getNumUsedTextures=function(){return this.numUsedTextures};TextureManager.prototype.getNumFreeTextures=function(){return this.numFreeTextures};TextureManager.prototype.dispose=function(){var _this=this;if(this.freeTextures==null){return}for(var texShape in this.freeTextures){this.freeTextures[texShape].forEach(function(tex){_this.gpgpu.deleteMatrixTexture(tex)})}for(var texShape in this.usedTextures){this.usedTextures[texShape].forEach(function(tex){_this.gpgpu.deleteMatrixTexture(tex)})}this.freeTextures=null;this.usedTextures=null;this.numUsedTextures=0;this.numFreeTextures=0};return TextureManager}();exports.TextureManager=TextureManager;function getPhysicalFromLogicalTextureType(logicalTexType){if(logicalTexType===tex_util_1.TextureUsage.DOWNLOAD||logicalTexType===tex_util_1.TextureUsage.PIXELS){return tex_util_1.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE}else if(logicalTexType===tex_util_1.TextureUsage.UPLOAD){return tex_util_1.PhysicalTextureType.UNPACKED_FLOAT32}else if(logicalTexType===tex_util_1.TextureUsage.RENDER){return environment_1.ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")?tex_util_1.PhysicalTextureType.UNPACKED_FLOAT32:tex_util_1.PhysicalTextureType.UNPACKED_FLOAT16}else if(logicalTexType===tex_util_1.TextureUsage.PACK){return tex_util_1.PhysicalTextureType.PACKED_2X2_FLOAT32}throw new Error("Unknown logical texture type "+logicalTexType)}function getKeyFromTextureShape(shapeRowsCol,physicalTexType){return shapeRowsCol[0]+"_"+shapeRowsCol[1]+"_"+physicalTexType}},{"../../environment":51,"./tex_util":116}],118:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var TileProgram=function(){function TileProgram(aShape,reps){this.variableNames=["A"];var outputShape=new Array(aShape.length);for(var i=0;i<outputShape.length;i++){outputShape[i]=aShape[i]*reps[i]}this.outputShape=outputShape;this.rank=outputShape.length;var dtype=shader_compiler_1.getCoordsDataType(this.rank);var sourceCoords=getSourceCoords(aShape);this.userCode="\n      void main() {\n        "+dtype+" resRC = getOutputCoords();\n        setOutput(getA("+sourceCoords+"));\n      }\n    "}return TileProgram}();exports.TileProgram=TileProgram;function getSourceCoords(aShape){var rank=aShape.length;if(rank>5){throw Error("Tile for rank "+rank+" is not yet supported")}if(rank===1){return"imod(resRC, "+aShape[0]+")"}var currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"];var sourceCoords=[];for(var i=0;i<aShape.length;i++){sourceCoords.push("imod("+currentCoords[i]+", "+aShape[i]+")")}return sourceCoords.join()}},{"./shader_compiler":113}],119:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var shader_compiler_1=require("./shader_compiler");var TransposeProgram=function(){function TransposeProgram(aShape,newDim){this.variableNames=["A"];var outputShape=new Array(aShape.length);for(var i=0;i<outputShape.length;i++){outputShape[i]=aShape[newDim[i]]}this.outputShape=outputShape;this.rank=outputShape.length;var dtype=shader_compiler_1.getCoordsDataType(this.rank);var switched=getSwitchedCoords(newDim);this.userCode="\n    void main() {\n      "+dtype+" resRC = getOutputCoords();\n      setOutput(getA("+switched+"));\n    }\n    "}return TransposeProgram}();exports.TransposeProgram=TransposeProgram;function getSwitchedCoords(newDim){var rank=newDim.length;if(rank>6){throw Error("Transpose for rank "+rank+" is not yet supported")}var originalOrder=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"];var switchedCoords=new Array(rank);for(var i=0;i<newDim.length;i++){switchedCoords[newDim[i]]=originalOrder[i]}return switchedCoords.join()}},{"./shader_compiler":113}],120:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var erf_util=require("../../ops/erf_util");var selu_util=require("../../ops/selu_util");var UnaryOpProgram=function(){function UnaryOpProgram(aShape,opSnippet){this.variableNames=["A"];this.outputShape=aShape;this.userCode="\n      uniform float NAN;\n      float unaryOperation(float x) {\n        "+opSnippet+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}UnaryOpProgram.prototype.getCustomSetupFunc=function(){var _this=this;return function(gpgpu,webGLProgram){if(_this.startLoc==null){_this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"NAN");if(_this.startLoc==null){return}}gpgpu.gl.uniform1f(_this.startLoc,NaN)}};return UnaryOpProgram}();exports.UnaryOpProgram=UnaryOpProgram;var CHECK_NAN_SNIPPET="if (isNaN(x)) return x;";exports.ABS="return abs(x);";exports.RELU=CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : x;\n";exports.ELU="return (x >= 0.0) ? x : (exp(x) - 1.0);";exports.SELU="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+selu_util.SELU_SCALEALPHA+";\n  float scale = "+selu_util.SELU_SCALE+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";function STEP(alpha){if(alpha===void 0){alpha=0}return CHECK_NAN_SNIPPET+("\n    return x > 0.0 ? 1.0 : float("+alpha+");\n  ")}exports.STEP=STEP;exports.NEG="return -x;";exports.CEIL="return ceil(x);";exports.FLOOR="return floor(x);";exports.SIGN="\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n";exports.ROUND="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n";exports.EXP="return exp(x);";exports.EXPM1="return exp(x) - 1.0;";exports.LOG="if (x < 0.0) return NAN;\n  return log(x);";exports.LOG1P="return log(1.0 + x);";exports.SQRT="return sqrt(x);";exports.RSQRT="return inversesqrt(x);";exports.SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));";exports.SOFTPLUS="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n";exports.SIN=CHECK_NAN_SNIPPET+"\n  return sin(x);\n";exports.COS=CHECK_NAN_SNIPPET+"\n  return cos(x);\n";exports.TAN="return tan(x);";exports.ASIN="return asin(x);";exports.ACOS="return acos(x);";exports.ATAN=CHECK_NAN_SNIPPET+"\n  return atan(x);\n";exports.SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";exports.COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";exports.TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";exports.ASINH="return log(x + sqrt(x * x + 1.0));";exports.ACOSH=CHECK_NAN_SNIPPET+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";exports.ATANH=CHECK_NAN_SNIPPET+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";exports.ERF='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '+erf_util.ERF_P+";\n  float a1 = "+erf_util.ERF_A1+";\n  float a2 = "+erf_util.ERF_A2+";\n  float a3 = "+erf_util.ERF_A3+";\n  float a4 = "+erf_util.ERF_A4+";\n  float a5 = "+erf_util.ERF_A5+";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n";exports.SQUARE="return x * x;";exports.RECIPROCAL="return 1.0 / x;";exports.LOGICAL_NOT="return float(!(x >= 1.0));";exports.TO_INT="return float(int(x));"},{"../../ops/erf_util":137,"../../ops/selu_util":157}],121:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var UnpackProgram=function(){function UnpackProgram(outputShape){this.variableNames=["A"];this.outputShape=outputShape;this.userCode="\n      const vec2 onePixel = 1. / vec2("+outputShape[1]+", "+outputShape[0]+");\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n        vec2 modCoord = mod(vec2(rc.y, rc.x), 2.);\n\n        vec4 packedInput = texture2D(A,\n          resultUV - step(1., modCoord) * onePixel);\n\n        setOutput(\n          modCoord.x == 0. ?\n            (modCoord.y == 0. ? packedInput.r : packedInput.b) :\n            (modCoord.y == 0. ? packedInput.g : packedInput.a)\n        );\n      }\n    "}return UnpackProgram}();exports.UnpackProgram=UnpackProgram},{}],122:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MAX_TEXTURE_SIZE=null;var util=require("../../util");var environment_1=require("../../environment");function createWebGLRenderingContext(attributes){var canvas=document.createElement("canvas");canvas.width=1;canvas.height=1;return createWebGLRenderingContextFromCanvas(canvas,attributes)}exports.createWebGLRenderingContext=createWebGLRenderingContext;function createWebGLRenderingContextFromCanvas(canvas,attributes){var gl;var webglVersion=environment_1.ENV.get("WEBGL_VERSION");if(webglVersion===2){gl=canvas.getContext("webgl2",attributes)}else if(webglVersion===1){gl=canvas.getContext("webgl",attributes)||canvas.getContext("experimental-webgl",attributes)}if(webglVersion===0||gl==null){throw new Error("This browser does not support WebGL.")}return gl}exports.createWebGLRenderingContextFromCanvas=createWebGLRenderingContextFromCanvas;function callAndCheck(gl,func){var returnValue=func();checkWebGLError(gl);return returnValue}exports.callAndCheck=callAndCheck;var webGLDebugErrorCheckingEnabled=false;function enableDebugWebGLErrorChecking(enabled){webGLDebugErrorCheckingEnabled=enabled}exports.enableDebugWebGLErrorChecking=enableDebugWebGLErrorChecking;function checkWebGLError(gl){if(webGLDebugErrorCheckingEnabled){var error=gl.getError();if(error!==gl.NO_ERROR){throw new Error("WebGL Error: "+getWebGLErrorMessage(gl,error))}}}exports.checkWebGLError=checkWebGLError;function getWebGLErrorMessage(gl,status){switch(status){case gl.NO_ERROR:return"NO_ERROR";case gl.INVALID_ENUM:return"INVALID_ENUM";case gl.INVALID_VALUE:return"INVALID_VALUE";case gl.INVALID_OPERATION:return"INVALID_OPERATION";case gl.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case gl.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case gl.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+status}}exports.getWebGLErrorMessage=getWebGLErrorMessage;function getExtensionOrThrow(gl,extensionName){return throwIfNull(gl,function(){return gl.getExtension(extensionName)},'Extension "'+extensionName+'" not supported on this browser.')}exports.getExtensionOrThrow=getExtensionOrThrow;function createVertexShader(gl,vertexShaderSource){var vertexShader=throwIfNull(gl,function(){return gl.createShader(gl.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");callAndCheck(gl,function(){return gl.shaderSource(vertexShader,vertexShaderSource)});callAndCheck(gl,function(){return gl.compileShader(vertexShader)});if(gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS)===false){console.log(gl.getShaderInfoLog(vertexShader));throw new Error("Failed to compile vertex shader.")}return vertexShader}exports.createVertexShader=createVertexShader;function createFragmentShader(gl,fragmentShaderSource){var fragmentShader=throwIfNull(gl,function(){return gl.createShader(gl.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");callAndCheck(gl,function(){return gl.shaderSource(fragmentShader,fragmentShaderSource)});callAndCheck(gl,function(){return gl.compileShader(fragmentShader)});if(gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS)===false){logShaderSourceAndInfoLog(fragmentShaderSource,gl.getShaderInfoLog(fragmentShader));throw new Error("Failed to compile fragment shader.")}return fragmentShader}exports.createFragmentShader=createFragmentShader;var lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(shaderSource,shaderInfoLog){var lineNumberRegexResult=lineNumberRegex.exec(shaderInfoLog);if(lineNumberRegexResult==null){console.log("Couldn't parse line number in error: "+shaderInfoLog);console.log(shaderSource);return}var lineNumber=+lineNumberRegexResult[1];var shaderLines=shaderSource.split("\n");var pad=shaderLines.length.toString().length+2;var linesWithLineNumbers=shaderLines.map(function(line,lineNumber){return util.rightPad((lineNumber+1).toString(),pad)+line});var maxLineLength=0;for(var i=0;i<linesWithLineNumbers.length;i++){maxLineLength=Math.max(linesWithLineNumbers[i].length,maxLineLength)}var beforeErrorLines=linesWithLineNumbers.slice(0,lineNumber-1);var errorLine=linesWithLineNumbers.slice(lineNumber-1,lineNumber);var afterErrorLines=linesWithLineNumbers.slice(lineNumber);console.log(beforeErrorLines.join("\n"));console.log(shaderInfoLog.split("\n")[0]);console.log("%c "+util.rightPad(errorLine[0],maxLineLength),"border:1px solid red; background-color:#e3d2d2; color:#a61717");console.log(afterErrorLines.join("\n"))}function createProgram(gl){return throwIfNull(gl,function(){return gl.createProgram()},"Unable to create WebGLProgram.")}exports.createProgram=createProgram;function linkProgram(gl,program){callAndCheck(gl,function(){return gl.linkProgram(program)});if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){console.log(gl.getProgramInfoLog(program));throw new Error("Failed to link vertex and fragment shaders.")}}exports.linkProgram=linkProgram;function validateProgram(gl,program){callAndCheck(gl,function(){return gl.validateProgram(program)});if(gl.getProgramParameter(program,gl.VALIDATE_STATUS)===false){console.log(gl.getProgramInfoLog(program));throw new Error("Shader program validation failed.")}}exports.validateProgram=validateProgram;function createStaticVertexBuffer(gl,data){var buffer=throwIfNull(gl,function(){return gl.createBuffer()},"Unable to create WebGLBuffer");callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,buffer)});callAndCheck(gl,function(){return gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW)});return buffer}exports.createStaticVertexBuffer=createStaticVertexBuffer;function createStaticIndexBuffer(gl,data){var buffer=throwIfNull(gl,function(){return gl.createBuffer()},"Unable to create WebGLBuffer");callAndCheck(gl,function(){return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffer)});callAndCheck(gl,function(){return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,data,gl.STATIC_DRAW)});return buffer}exports.createStaticIndexBuffer=createStaticIndexBuffer;function queryMaxTextureSize(gl){if(MAX_TEXTURE_SIZE!=null){return MAX_TEXTURE_SIZE}MAX_TEXTURE_SIZE=callAndCheck(gl,function(){return gl.getParameter(gl.MAX_TEXTURE_SIZE)});return MAX_TEXTURE_SIZE}exports.queryMaxTextureSize=queryMaxTextureSize;function getNumChannels(){if(environment_1.ENV.get("WEBGL_VERSION")===2){return 1}return 4}exports.getNumChannels=getNumChannels;function createTexture(gl){return throwIfNull(gl,function(){return gl.createTexture()},"Unable to create WebGLTexture.")}exports.createTexture=createTexture;function validateTextureSize(gl,width,height){var maxTextureSize=queryMaxTextureSize(gl);if(width<=0||height<=0){var requested="["+width+"x"+height+"]";throw new Error("Requested texture size "+requested+" is invalid.")}if(width>maxTextureSize||height>maxTextureSize){var requested="["+width+"x"+height+"]";var max="["+maxTextureSize+"x"+maxTextureSize+"]";throw new Error("Requested texture size "+requested+" greater than WebGL maximum on this browser / GPU "+max+".")}}exports.validateTextureSize=validateTextureSize;function createFramebuffer(gl){return throwIfNull(gl,function(){return gl.createFramebuffer()},"Unable to create WebGLFramebuffer.")}exports.createFramebuffer=createFramebuffer;function bindVertexBufferToProgramAttribute(gl,program,attribute,buffer,arrayEntriesPerItem,itemStrideInBytes,itemOffsetInBytes){var loc=gl.getAttribLocation(program,attribute);if(loc===-1){return false}callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,buffer)});callAndCheck(gl,function(){return gl.vertexAttribPointer(loc,arrayEntriesPerItem,gl.FLOAT,false,itemStrideInBytes,itemOffsetInBytes)});callAndCheck(gl,function(){return gl.enableVertexAttribArray(loc)});return true}exports.bindVertexBufferToProgramAttribute=bindVertexBufferToProgramAttribute;function bindTextureUnit(gl,texture,textureUnit){validateTextureUnit(gl,textureUnit);callAndCheck(gl,function(){return gl.activeTexture(gl.TEXTURE0+textureUnit)});callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,texture)})}exports.bindTextureUnit=bindTextureUnit;function unbindTextureUnit(gl,textureUnit){validateTextureUnit(gl,textureUnit);callAndCheck(gl,function(){return gl.activeTexture(gl.TEXTURE0+textureUnit)});callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null)})}exports.unbindTextureUnit=unbindTextureUnit;function getProgramUniformLocationOrThrow(gl,program,uniformName){return throwIfNull(gl,function(){return gl.getUniformLocation(program,uniformName)},'uniform "'+uniformName+'" not present in program.')}exports.getProgramUniformLocationOrThrow=getProgramUniformLocationOrThrow;function getProgramUniformLocation(gl,program,uniformName){return gl.getUniformLocation(program,uniformName)}exports.getProgramUniformLocation=getProgramUniformLocation;function bindTextureToProgramUniformSampler(gl,program,texture,uniformSamplerLocation,textureUnit){callAndCheck(gl,function(){return bindTextureUnit(gl,texture,textureUnit)});callAndCheck(gl,function(){return gl.uniform1i(uniformSamplerLocation,textureUnit)})}exports.bindTextureToProgramUniformSampler=bindTextureToProgramUniformSampler;function bindCanvasToFramebuffer(gl){callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,null)});callAndCheck(gl,function(){return gl.viewport(0,0,gl.canvas.width,gl.canvas.height)});callAndCheck(gl,function(){return gl.scissor(0,0,gl.canvas.width,gl.canvas.height)})}exports.bindCanvasToFramebuffer=bindCanvasToFramebuffer;function bindColorTextureToFramebuffer(gl,texture,framebuffer){callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)});callAndCheck(gl,function(){return gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0)})}exports.bindColorTextureToFramebuffer=bindColorTextureToFramebuffer;function unbindColorTextureFromFramebuffer(gl,framebuffer){callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)});callAndCheck(gl,function(){return gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,null,0)})}exports.unbindColorTextureFromFramebuffer=unbindColorTextureFromFramebuffer;function validateFramebuffer(gl){var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE){throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(gl,status))}}exports.validateFramebuffer=validateFramebuffer;function getFramebufferErrorMessage(gl,status){switch(status){case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case gl.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+status}}exports.getFramebufferErrorMessage=getFramebufferErrorMessage;function throwIfNull(gl,returnTOrNull,failureMessage){var tOrNull=callAndCheck(gl,function(){return returnTOrNull()});if(tOrNull==null){throw new Error(failureMessage)}return tOrNull}function validateTextureUnit(gl,textureUnit){var maxTextureUnit=gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;var glTextureUnit=textureUnit+gl.TEXTURE0;if(glTextureUnit<gl.TEXTURE0||glTextureUnit>maxTextureUnit){var textureUnitRange="[gl.TEXTURE0, gl.TEXTURE"+maxTextureUnit+"]";throw new Error("textureUnit must be in "+textureUnitRange+".")}}function getTextureShapeFromLogicalShape(gl,logShape){if(logShape.length!==2){var squeezeResult=util.squeezeShape(logShape);logShape=squeezeResult.newShape}var maxTexSize=queryMaxTextureSize(gl);var size=util.sizeFromShape(logShape);if(logShape.length<=1&&size<=maxTexSize){return[size,1]}else if(logShape.length===2&&logShape[0]<=maxTexSize&&logShape[1]<=maxTexSize){return logShape}else if(logShape.length===3&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]<=maxTexSize){return[logShape[0],logShape[1]*logShape[2]]}else if(logShape.length===4&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]*logShape[3]<=maxTexSize){return[logShape[0],logShape[1]*logShape[2]*logShape[3]]}else{return util.sizeToSquarishShape(size)}}exports.getTextureShapeFromLogicalShape=getTextureShapeFromLogicalShape},{"../../environment":51,"../../util":185}],123:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var array_ops_1=require("../ops/array_ops");function whereImpl(condShape,condVals){var indices=[];for(var i=0;i<condVals.length;i++){if(condVals[i]){indices.push(i)}}var inBuffer=array_ops_1.buffer(condShape,"int32");var out=array_ops_1.buffer([indices.length,condShape.length],"int32");for(var i=0;i<indices.length;i++){var loc=inBuffer.indexToLoc(indices[i]);var offset=i*condShape.length;out.values.set(loc,offset)}return out.toTensor()}exports.whereImpl=whereImpl},{"../ops/array_ops":125}],124:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("./environment");function warn(){var msg=[];for(var _i=0;_i<arguments.length;_i++){msg[_i]=arguments[_i]}if(!environment_1.ENV.get("IS_TEST")){console.warn.apply(console,msg)}}exports.warn=warn;function log(){var msg=[];for(var _i=0;_i<arguments.length;_i++){msg[_i]=arguments[_i]}if(!environment_1.ENV.get("IS_TEST")){console.log.apply(console,msg)}}exports.log=log},{"./environment":51}],125:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_1=require("../tensor");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var axis_util_1=require("./axis_util");var concat_split_1=require("./concat_split");var operation_1=require("./operation");var rand_1=require("./rand");var tensor_ops_1=require("./tensor_ops");function clone_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","clone");var der=function(dy){return{$x:function(){return dy.toFloat()}}};return environment_1.ENV.engine.runKernel(function(backend){return tensor_1.Tensor.make($x.shape,{dataId:$x.dataId},$x.dtype)},{$x:$x},der)}function eye_(numRows,numColumns,batchShape,dtype){if(dtype===void 0){dtype="float32"}if(numColumns==null){numColumns=numRows}var buff=buffer([numRows,numColumns],dtype);var n=numRows<=numColumns?numRows:numColumns;for(var i=0;i<n;++i){buff.set(1,i,i)}var out=buff.toTensor().as2D(numRows,numColumns);if(batchShape==null){return out}else{if(batchShape.length===1){return exports.tile(exports.expandDims(out,0),[batchShape[0],1,1])}else if(batchShape.length===2){return exports.tile(exports.expandDims(exports.expandDims(out,0),0),[batchShape[0],batchShape[1],1,1])}else if(batchShape.length===3){return exports.tile(exports.expandDims(exports.expandDims(exports.expandDims(out,0),0),0),[batchShape[0],batchShape[1],batchShape[2],1,1])}else{throw new Error("eye() currently supports only 1D and 2D "+("batchShapes, but received "+batchShape.length+"D."))}}}function randomNormal_(shape,mean,stdDev,dtype,seed){if(mean===void 0){mean=0}if(stdDev===void 0){stdDev=1}if(dtype!=null&&dtype==="bool"){throw new Error("Unsupported data type "+dtype)}var randGauss=new rand_1.MPRandGauss(mean,stdDev,dtype,false,seed);var res=buffer(shape,dtype);for(var i=0;i<res.values.length;i++){res.values[i]=randGauss.nextValue()}return res.toTensor()}function truncatedNormal_(shape,mean,stdDev,dtype,seed){if(mean===void 0){mean=0}if(stdDev===void 0){stdDev=1}if(dtype!=null&&dtype==="bool"){throw new Error("Unsupported data type "+dtype)}var randGauss=new rand_1.MPRandGauss(mean,stdDev,dtype,true,seed);var res=buffer(shape,dtype);for(var i=0;i<res.values.length;i++){res.values[i]=randGauss.nextValue()}return res.toTensor()}function randomUniform_(shape,minval,maxval,dtype){if(minval===void 0){minval=0}if(maxval===void 0){maxval=1}if(dtype===void 0){dtype="float32"}var res=buffer(shape,dtype);for(var i=0;i<res.values.length;i++){res.values[i]=util.randUniform(minval,maxval)}return res.toTensor()}function rand_(shape,randFunction,dtype){var size=util.sizeFromShape(shape);var values=null;if(dtype==null||dtype==="float32"){values=new Float32Array(size)}else if(dtype==="int32"){values=new Int32Array(size)}else if(dtype==="bool"){values=new Uint8Array(size)}else{throw new Error("Unknown data type "+dtype)}for(var i=0;i<size;i++){values[i]=randFunction()}return tensor_1.Tensor.make(shape,{values:values},dtype)}function multinomial_(logits,numSamples,seed,normalized){if(normalized===void 0){normalized=false}var $logits=tensor_util_env_1.convertToTensor(logits,"logits","multinomial");var numOutcomes=$logits.size;var origRank=$logits.rank;if(numOutcomes<2){throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+(numOutcomes+"."))}if(origRank>2){throw new Error("Rank of probabilities must be 1 or 2, but is "+origRank)}seed=seed||Math.random();var logits2D=origRank===1?$logits.as2D(1,-1):$logits;var res=environment_1.ENV.engine.runKernel(function(backend){return backend.multinomial(logits2D,normalized,numSamples,seed)},{logits2D:logits2D});return origRank===1?res.as1D():res}function oneHot_(indices,depth,onValue,offValue){if(onValue===void 0){onValue=1}if(offValue===void 0){offValue=0}var $indices=tensor_util_env_1.convertToTensor(indices,"indices","oneHot","int32");util.assert($indices.dtype==="int32","Indices must be of dtype `int32`");if(depth<2){throw new Error("Error in oneHot: depth must be >=2, but it is "+depth)}var grad=function(dy){return{$indices:function(){return tensor_ops_1.zerosLike($indices)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.oneHot($indices,depth,onValue,offValue)},{$indices:$indices},grad)}function fromPixels_(pixels,numChannels){if(numChannels===void 0){numChannels=3}if(numChannels>4){throw new Error("Cannot construct Tensor with more than 4 channels from pixels.")}return environment_1.ENV.engine.fromPixels(pixels,numChannels)}function toPixels(img,canvas){return __awaiter(this,void 0,void 0,function(){var $img,_a,height,width,depth,minTensor,maxTensor,min,max,data,multiplier,bytes,i,r,g,b,a,j,ctx,imageData;return __generator(this,function(_b){switch(_b.label){case 0:$img=tensor_util_env_1.convertToTensor(img,"img","toPixels","int32");if($img.rank!==2&&$img.rank!==3){throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+$img.rank+".")}_a=$img.shape.slice(0,2),height=_a[0],width=_a[1];depth=$img.rank===2?1:$img.shape[2];if(depth>4||depth===2){throw new Error("toPixels only supports depth of size "+("1, 3 or 4 but got "+depth))}minTensor=$img.min();maxTensor=$img.max();return[4,minTensor.data()];case 1:min=_b.sent()[0];return[4,maxTensor.data()];case 2:max=_b.sent()[0];minTensor.dispose();maxTensor.dispose();if($img.dtype==="float32"){if(min<0||max>1){throw new Error("Tensor values for a float32 Tensor must be in the "+("range [0 - 1] but got range ["+min+" - "+max+"]."))}}else if($img.dtype==="int32"){if(min<0||max>255){throw new Error("Tensor values for a int32 Tensor must be in the "+("range [0 - 255] but got range ["+min+" - "+max+"]."))}}else{throw new Error("Unsupported type for toPixels: "+$img.dtype+"."+" Please use float32 or int32 tensors.")}return[4,$img.data()];case 3:data=_b.sent();multiplier=$img.dtype==="float32"?255:1;bytes=new Uint8ClampedArray(width*height*4);for(i=0;i<height*width;++i){r=void 0,g=void 0,b=void 0,a=void 0;if(depth===1){r=data[i]*multiplier;g=data[i]*multiplier;b=data[i]*multiplier;a=255}else if(depth===3){r=data[i*3]*multiplier;g=data[i*3+1]*multiplier;b=data[i*3+2]*multiplier;a=255}else if(depth===4){r=data[i*4]*multiplier;g=data[i*4+1]*multiplier;b=data[i*4+2]*multiplier;a=data[i*4+3]*multiplier}j=i*4;bytes[j+0]=Math.round(r);bytes[j+1]=Math.round(g);bytes[j+2]=Math.round(b);bytes[j+3]=Math.round(a)}if(canvas!=null){canvas.width=width;canvas.height=height;ctx=canvas.getContext("2d");imageData=new ImageData(bytes,width,height);ctx.putImageData(imageData,0,0)}if($img!==img){$img.dispose()}return[2,bytes]}})})}exports.toPixels=toPixels;function reshape_(x,shape){var $x=tensor_util_env_1.convertToTensor(x,"x","reshape");shape=util.inferFromImplicitShape(shape,$x.size);util.assert($x.size===util.sizeFromShape(shape),"new shape and old shape must have the same number of elements.");var grad=function(dy){return{$x:function(){return dy.reshape($x.shape)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.reshape($x,shape)},{$x:$x},grad)}function squeeze_(x,axis){var $x=tensor_util_env_1.convertToTensor(x,"x","squeeze");return exports.reshape($x,util.squeezeShape($x.shape,axis).newShape)}function cast_(x,dtype){var $x=tensor_util_env_1.convertToTensor(x,"x","cast");var grad=function(dy){return{$x:function(){return dy.clone()}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.cast($x,dtype)},{$x:$x},grad)}function tile_(x,reps){var $x=tensor_util_env_1.convertToTensor(x,"x","tile");util.assert($x.rank===reps.length,"Error in transpose: rank of input "+$x.rank+" "+("must match length of reps "+reps+"."));var grad=function(dy){var derX=function(){var xGrad=tensor_ops_1.zerosLike($x);if($x.rank===1){for(var i=0;i<reps[0];++i){xGrad=xGrad.add(dy.slice([i*$x.shape[0]],[$x.shape[0]]))}}else if($x.rank===2){for(var i=0;i<reps[0];++i){for(var j=0;j<reps[1];++j){xGrad=xGrad.add(dy.slice([i*$x.shape[0],j*$x.shape[1]],[$x.shape[0],$x.shape[1]]))}}}else if($x.rank===3){for(var i=0;i<reps[0];++i){for(var j=0;j<reps[1];++j){for(var k=0;k<reps[2];++k){xGrad=xGrad.add(dy.slice([i*$x.shape[0],j*$x.shape[1],k*$x.shape[2]],[$x.shape[0],$x.shape[1],$x.shape[2]]))}}}}else if($x.rank===4){for(var i=0;i<reps[0];++i){for(var j=0;j<reps[1];++j){for(var k=0;k<reps[2];++k){for(var l=0;l<reps[3];++l){xGrad=xGrad.add(dy.slice([i*$x.shape[0],j*$x.shape[1],k*$x.shape[2],l*$x.shape[3]],[$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3]]))}}}}}else{throw new Error("Gradient for tile operation is not implemented for rank-"+($x.rank+" tensors yet."))}return xGrad};return{$x:derX}};return environment_1.ENV.engine.runKernel(function(backend){return backend.tile($x,reps)},{$x:$x},grad)}function pad1d_(x,paddings,constantValue){if(constantValue===void 0){constantValue=0}util.assert(paddings.length===2,"Invalid number of paddings. Must be length of 2.");return exports.pad(x,[paddings],constantValue)}function pad2d_(x,paddings,constantValue){if(constantValue===void 0){constantValue=0}util.assert(paddings.length===2&&paddings[0].length===2&&paddings[1].length===2,"Invalid number of paddings. Must be length of 2 each.");return exports.pad(x,paddings,constantValue)}function pad3d_(x,paddings,constantValue){if(constantValue===void 0){constantValue=0}util.assert(paddings.length===3&&paddings[0].length===2&&paddings[1].length===2&&paddings[2].length===2,"Invalid number of paddings. Must be length of 2 each.");return exports.pad(x,paddings,constantValue)}function pad4d_(x,paddings,constantValue){if(constantValue===void 0){constantValue=0}util.assert(paddings.length===4&&paddings[0].length===2&&paddings[1].length===2&&paddings[2].length===2&&paddings[3].length===2,"Invalid number of paddings. Must be length of 2 each.");return exports.pad(x,paddings,constantValue)}function pad_(x,paddings,constantValue){if(constantValue===void 0){constantValue=0}var $x=tensor_util_env_1.convertToTensor(x,"x","pad");if($x.rank===0){throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")}var begin=paddings.map(function(p){return p[0]});var grad=function(dy){return{$x:function(){return dy.slice(begin,$x.shape)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.pad($x,paddings,constantValue)},{$x:$x},grad)}function stack_(tensors,axis){if(axis===void 0){axis=0}var $tensors=tensor_util_env_1.convertToTensorArray(tensors,"tensors","stack");util.assert($tensors.length>=1,"Pass at least one tensor to tf.stack");if($tensors.length===1){return $tensors[0].expandDims(axis)}var rank=$tensors[0].rank;var shape=$tensors[0].shape;var dtype=$tensors[0].dtype;util.assert(axis<=rank,"Axis must be <= rank of the tensor");$tensors.forEach(function(t){util.assertShapesMatch(shape,t.shape,"All tensors passed to stack must have matching shapes")});$tensors.forEach(function(t){util.assert(dtype===t.dtype,"All tensors passed to stack must have matching dtypes")});var expandedTensors=$tensors.map(function(t){return t.expandDims(axis)});return concat_split_1.concat(expandedTensors,axis)}function batchToSpaceND_(x,blockShape,crops){var $x=tensor_util_env_1.convertToTensor(x,"x","batchToSpaceND");var prod=blockShape.reduce(function(a,b){return a*b});util.assert($x.rank>=1+blockShape.length,"input rank should be > than [blockShape] but got "+$x.rank);util.assert(crops.length===blockShape.length,"crops.shape[0] must be equal to [blockShape] but got "+crops.length);util.assert($x.shape[0]%prod===0,"input tensor batch must be divisible by prod( blockShape )");var grad=function(dy){return{$x:function(){return dy.spaceToBatchND(blockShape,crops)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.batchToSpaceND($x,blockShape,crops)},{$x:$x},grad)}function spaceToBatchND_(x,blockShape,paddings){var $x=tensor_util_env_1.convertToTensor(x,"x","spaceToBatchND");util.assert($x.rank>=1+blockShape.length,"input rank "+$x.rank+" should be > than [blockShape] "+blockShape.length);util.assert(paddings.length===blockShape.length,"paddings.shape[0] "+paddings.length+" must be equal to [blockShape] "+blockShape.length);util.assert($x.shape.reduce(function(a,b,i){if(i>0&&i<=blockShape.length){return a&&(b+paddings[i-1][0]+paddings[i-1][1])%blockShape[i-1]===0}return a},true),"input spatial dimensions "+$x.shape.slice(1)+" with paddings "+paddings.toString()+" must be divisible by blockShapes "+blockShape.toString());var grad=function(dy){return{$x:function(){return dy.batchToSpaceND(blockShape,paddings)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.spaceToBatchND($x,blockShape,paddings)},{$x:$x},grad)}function unstack_(x,axis){if(axis===void 0){axis=0}var $x=tensor_util_env_1.convertToTensor(x,"x","unstack");var num=$x.shape[axis];var outputShape=Array($x.rank-1).fill(0);var outIndex=0;for(var i=0;i<$x.rank;i++){if(i!==axis){outputShape[outIndex]=$x.shape[i];outIndex++}}var splitSizes;splitSizes=Array(num).fill(1);var begin=Array($x.rank).fill(0);var size=$x.shape.slice();return splitSizes.map(function(s){size[axis]=s;var slice=$x.slice(begin,size);begin[axis]+=s;return slice.reshape(outputShape)})}function cumsum_(x,axis,exclusive,reverse){if(axis===void 0){axis=0}if(exclusive===void 0){exclusive=false}if(reverse===void 0){reverse=false}var $x=tensor_util_env_1.convertToTensor(x,"x","cumsum");axis=axis|0;var permutation=axis_util_1.getAxesPermutation([axis],$x.rank);var permutedX=$x;if(permutation!=null){permutedX=$x.transpose(permutation)}var permutedAxis=axis_util_1.getInnerMostAxes(1,$x.rank)[0];var grad=function(dy){return{permutedX:function(){return dy.cumsum(axis,exclusive,!reverse)}}};var value=environment_1.ENV.engine.runKernel(function(backend){return backend.cumsum(permutedX,permutedAxis,exclusive,reverse)},{permutedX:permutedX},grad);if(permutation!=null){value=value.transpose(permutation)}return value}function expandDims_(x,axis){if(axis===void 0){axis=0}var $x=tensor_util_env_1.convertToTensor(x,"x","expandDims");util.assert(axis<=$x.rank,"Axis must be <= rank of the tensor");var newShape=$x.shape.slice();if(axis<0){util.assert(-($x.rank+1)<=axis,"Axis must be in the interval ["+-($x.rank+1)+", "+$x.rank+"]");axis=$x.rank+axis+1}newShape.splice(axis,0,1);return exports.reshape($x,newShape)}function depthToSpace_(x,blockSize,dataFormat){if(dataFormat===void 0){dataFormat="NHWC"}var $x=tensor_util_env_1.convertToTensor(x,"x","depthToSpace");var inputHeight=dataFormat==="NHWC"?$x.shape[1]:$x.shape[2];var inputWidth=dataFormat==="NHWC"?$x.shape[2]:$x.shape[3];var inputDepth=dataFormat==="NHWC"?$x.shape[3]:$x.shape[1];util.assert(inputHeight*blockSize>=0,"Negative dimension size caused by overflow when multiplying\n      "+inputHeight+" and "+blockSize+"  for depthToSpace with input shape\n      "+$x.shape);util.assert(inputWidth*blockSize>=0,"Negative dimension size caused by overflow when multiplying\n      "+inputWidth+" and "+blockSize+" for depthToSpace with input shape\n          "+$x.shape);util.assert(inputDepth%(blockSize*blockSize)===0,"Dimension size must be evenly divisible by "+blockSize*blockSize+" but is "+inputDepth+" for depthToSpace with input shape "+$x.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.depthToSpace($x,blockSize,dataFormat)},{$x:$x})}function buffer(shape,dtype,values){if(dtype===void 0){dtype="float32"}return new tensor_1.TensorBuffer(shape,dtype,values)}exports.buffer=buffer;function print(x,verbose){if(verbose===void 0){verbose=false}console.log(x.toString(verbose))}exports.print=print;exports.batchToSpaceND=operation_1.op({batchToSpaceND_:batchToSpaceND_});exports.cast=operation_1.op({cast_:cast_});exports.clone=operation_1.op({clone_:clone_});exports.cumsum=operation_1.op({cumsum_:cumsum_});exports.depthToSpace=operation_1.op({depthToSpace_:depthToSpace_});exports.expandDims=operation_1.op({expandDims_:expandDims_});exports.eye=operation_1.op({eye_:eye_});exports.fromPixels=operation_1.op({fromPixels_:fromPixels_});exports.multinomial=operation_1.op({multinomial_:multinomial_});exports.oneHot=operation_1.op({oneHot_:oneHot_});exports.pad=operation_1.op({pad_:pad_});exports.pad1d=operation_1.op({pad1d_:pad1d_});exports.pad2d=operation_1.op({pad2d_:pad2d_});exports.pad3d=operation_1.op({pad3d_:pad3d_});exports.pad4d=operation_1.op({pad4d_:pad4d_});exports.rand=operation_1.op({rand_:rand_});exports.randomNormal=operation_1.op({randomNormal_:randomNormal_});exports.randomUniform=operation_1.op({randomUniform_:randomUniform_});exports.reshape=operation_1.op({reshape_:reshape_});exports.spaceToBatchND=operation_1.op({spaceToBatchND_:spaceToBatchND_});exports.squeeze=operation_1.op({squeeze_:squeeze_});exports.stack=operation_1.op({stack_:stack_});exports.tile=operation_1.op({tile_:tile_});exports.truncatedNormal=operation_1.op({truncatedNormal_:truncatedNormal_});exports.unstack=operation_1.op({unstack_:unstack_})},{"../environment":51,"../tensor":178,"../tensor_util_env":181,"../util":185,"./axis_util":127,"./concat_split":133,"./operation":147,"./rand":150,"./tensor_ops":162}],126:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function getReshaped(inputShape,blockShape,prod,batchToSpace){if(batchToSpace===void 0){batchToSpace=true}var reshaped=[];if(batchToSpace){reshaped=reshaped.concat(blockShape.slice(0));reshaped.push(inputShape[0]/prod);reshaped=reshaped.concat(inputShape.slice(1))}else{reshaped=reshaped.concat(inputShape[0]);var spatialLength=blockShape.length;for(var i=0;i<spatialLength;++i){reshaped=reshaped.concat([inputShape[i+1]/blockShape[i],blockShape[i]])}reshaped=reshaped.concat(inputShape.slice(spatialLength+1))}return reshaped}exports.getReshaped=getReshaped;function getPermuted(reshapedRank,blockShapeRank,batchToSpace){if(batchToSpace===void 0){batchToSpace=true}var permuted=[];if(batchToSpace){permuted.push(blockShapeRank);for(var i=blockShapeRank+1;i<reshapedRank;++i){if(i<=2*blockShapeRank){permuted.push(i);permuted.push(i-(blockShapeRank+1))}else{permuted.push(i)}}}else{var permutedBeforeBatch=[];var permutedAfterBatch=[];for(var i=1;i<reshapedRank;++i){if(i>=blockShapeRank*2+1||i%2===1){permutedAfterBatch.push(i)}else{permutedBeforeBatch.push(i)}}permuted.push.apply(permuted,permutedBeforeBatch);permuted.push(0);permuted.push.apply(permuted,permutedAfterBatch)}return permuted}exports.getPermuted=getPermuted;function getReshapedPermuted(inputShape,blockShape,prod,batchToSpace){if(batchToSpace===void 0){batchToSpace=true}var reshapedPermuted=[];if(batchToSpace){reshapedPermuted.push(inputShape[0]/prod)}else{reshapedPermuted.push(inputShape[0]*prod)}for(var i=1;i<inputShape.length;++i){if(i<=blockShape.length){if(batchToSpace){reshapedPermuted.push(blockShape[i-1]*inputShape[i])}else{reshapedPermuted.push(inputShape[i]/blockShape[i-1])}}else{reshapedPermuted.push(inputShape[i])}}return reshapedPermuted}exports.getReshapedPermuted=getReshapedPermuted;function getSliceBeginCoords(crops,blockShape){var sliceBeginCoords=[0];for(var i=0;i<blockShape;++i){sliceBeginCoords.push(crops[i][0])}return sliceBeginCoords}exports.getSliceBeginCoords=getSliceBeginCoords;function getSliceSize(uncroppedShape,crops,blockShape){var sliceSize=uncroppedShape.slice(0,1);for(var i=0;i<blockShape;++i){sliceSize.push(uncroppedShape[i+1]-crops[i][0]-crops[i][1])}return sliceSize}exports.getSliceSize=getSliceSize},{}],127:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function axesAreInnerMostDims(axes,rank){for(var i=0;i<axes.length;++i){if(axes[axes.length-i-1]!==rank-1-i){return false}}return true}exports.axesAreInnerMostDims=axesAreInnerMostDims;function combineLocations(outputLoc,reduceLoc,axes){var rank=outputLoc.length+reduceLoc.length;var loc=[];var outIdx=0;var reduceIdx=0;for(var dim=0;dim<rank;dim++){if(axes.indexOf(dim)===-1){loc.push(outputLoc[outIdx++])}else{loc.push(reduceLoc[reduceIdx++])}}return loc}exports.combineLocations=combineLocations;function computeOutAndReduceShapes(aShape,axes){var outShape=[];var rank=aShape.length;for(var dim=0;dim<rank;dim++){if(axes.indexOf(dim)===-1){outShape.push(aShape[dim])}}var reduceShape=axes.map(function(dim){return aShape[dim]});return[outShape,reduceShape]}exports.computeOutAndReduceShapes=computeOutAndReduceShapes;function expandShapeToKeepDim(shape,axes){var reduceSubShape=axes.map(function(x){return 1});return combineLocations(shape,reduceSubShape,axes)}exports.expandShapeToKeepDim=expandShapeToKeepDim;function parseAxisParam(axis,shape){var rank=shape.length;axis=axis==null?shape.map(function(s,i){return i}):[].concat(axis);util.assert(axis.every(function(ax){return ax>=-rank&&ax<rank}),"All values in axis param must be in range [-"+rank+", "+rank+") but "+("got axis "+axis));util.assert(axis.every(function(ax){return util.isInt(ax)}),"All values in axis param must be integers but "+("got axis "+axis));return axis.map(function(a){return a<0?rank+a:a})}exports.parseAxisParam=parseAxisParam;function assertAxesAreInnerMostDims(msg,axes,rank){util.assert(axesAreInnerMostDims(axes,rank),msg+" supports only inner-most axes for now. "+("Got axes "+axes+" and rank-"+rank+" input."))}exports.assertAxesAreInnerMostDims=assertAxesAreInnerMostDims;function getAxesPermutation(axes,rank){if(axesAreInnerMostDims(axes,rank)){return null}var result=[];for(var i=0;i<rank;++i){if(axes.indexOf(i)===-1){result.push(i)}}axes.forEach(function(axis){return result.push(axis)});return result}exports.getAxesPermutation=getAxesPermutation;function getUndoAxesPermutation(axes){return axes.map(function(axis,i){return[i,axis]}).sort(function(a,b){return a[1]-b[1]}).map(function(x){return x[0]})}exports.getUndoAxesPermutation=getUndoAxesPermutation;function getInnerMostAxes(numAxes,rank){var res=[];for(var i=rank-numAxes;i<rank;++i){res.push(i)}return res}exports.getInnerMostAxes=getInnerMostAxes},{"../util":185}],128:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var array_ops_1=require("./array_ops");var broadcast_util_1=require("./broadcast_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");var unary_ops_1=require("./unary_ops");function batchNormalization2d_(x,mean,variance,varianceEpsilon,scale,offset){if(varianceEpsilon===void 0){varianceEpsilon=.001}var $x=tensor_util_env_1.convertToTensor(x,"x","batchNormalization");var $mean=tensor_util_env_1.convertToTensor(mean,"mean","batchNormalization");var $variance=tensor_util_env_1.convertToTensor(variance,"variance","batchNormalization");var $scale;if(scale!=null){$scale=tensor_util_env_1.convertToTensor(scale,"scale","batchNormalization")}var $offset;if(offset!=null){$offset=tensor_util_env_1.convertToTensor(offset,"offset","batchNormalization")}util.assert($x.rank===2,"Error in batchNormalization3D: x must be rank 3 but got rank "+($x.rank+"."));util.assert($mean.rank===2||$mean.rank===1,"Error in batchNormalization2D: mean must be rank 2 or rank 1 but "+("got rank "+$mean.rank+"."));util.assert($variance.rank===2||$variance.rank===1,"Error in batchNormalization2D: variance must be rank 2 or rank 1 "+("but got rank "+$variance.rank+"."));if($scale!=null){util.assert($scale.rank===2||$scale.rank===1,"Error in batchNormalization2D: scale must be rank 2 or rank 1 "+("but got rank "+$scale.rank+"."))}if($offset!=null){util.assert($offset.rank===2||$offset.rank===1,"Error in batchNormalization2D: offset must be rank 2 or rank 1 "+("but got rank "+$offset.rank+"."))}return exports.batchNormalization($x,$mean,$variance,varianceEpsilon,$scale,$offset)}function batchNormalization3d_(x,mean,variance,varianceEpsilon,scale,offset){if(varianceEpsilon===void 0){varianceEpsilon=.001}var $x=tensor_util_env_1.convertToTensor(x,"x","batchNormalization");var $mean=tensor_util_env_1.convertToTensor(mean,"mean","batchNormalization");var $variance=tensor_util_env_1.convertToTensor(variance,"variance","batchNormalization");var $scale;if(scale!=null){$scale=tensor_util_env_1.convertToTensor(scale,"scale","batchNormalization")}var $offset;if(offset!=null){$offset=tensor_util_env_1.convertToTensor(offset,"offset","batchNormalization")}util.assert($x.rank===3,"Error in batchNormalization3D: x must be rank 3 but got rank "+($x.rank+"."));util.assert($mean.rank===3||$mean.rank===1,"Error in batchNormalization3D: mean must be rank 3 or rank 1 but "+("got rank "+$mean.rank+"."));util.assert($variance.rank===3||$variance.rank===1,"Error in batchNormalization3D: variance must be rank 3 or rank 1 "+("but got rank "+$variance.rank+"."));if($scale!=null){util.assert($scale.rank===3||$scale.rank===1,"Error in batchNormalization3D: scale must be rank 3 or rank 1 "+("but got rank "+$scale.rank+"."))}if($offset!=null){util.assert($offset.rank===3||$offset.rank===1,"Error in batchNormalization3D: offset must be rank 3 or rank 1 "+("but got rank "+$offset.rank+"."))}return exports.batchNormalization($x,$mean,$variance,varianceEpsilon,$scale,$offset)}function batchNormalization4d_(x,mean,variance,varianceEpsilon,scale,offset){if(varianceEpsilon===void 0){varianceEpsilon=.001}var $x=tensor_util_env_1.convertToTensor(x,"x","batchNormalization");var $mean=tensor_util_env_1.convertToTensor(mean,"mean","batchNormalization");var $variance=tensor_util_env_1.convertToTensor(variance,"variance","batchNormalization");var $scale;if(scale!=null){$scale=tensor_util_env_1.convertToTensor(scale,"scale","batchNormalization")}var $offset;if(offset!=null){$offset=tensor_util_env_1.convertToTensor(offset,"offset","batchNormalization")}util.assert($x.rank===4,"Error in batchNormalization4D: x must be rank 4 but got rank "+($x.rank+"."));util.assert($mean.rank===4||$mean.rank===1,"Error in batchNormalization4D: mean must be rank 4 or rank 1 but "+("got rank "+$mean.rank+"."));util.assert($variance.rank===4||$variance.rank===1,"Error in batchNormalization4D: variance must be rank 4 or rank 1 "+("but got rank "+$variance.rank+"."));if($scale!=null){util.assert($scale.rank===4||$scale.rank===1,"Error in batchNormalization4D: scale must be rank 4 or rank 1 "+("but got rank "+$scale.rank+"."))}if($offset!=null){util.assert($offset.rank===4||$offset.rank===1,"Error in batchNormalization4D: offset must be rank 4 or rank 1 "+("but got rank "+$offset.rank+"."))}return exports.batchNormalization($x,$mean,$variance,varianceEpsilon,$scale,$offset)}function batchNormalization_(x,mean,variance,varianceEpsilon,scale,offset){if(varianceEpsilon===void 0){varianceEpsilon=.001}var $x=tensor_util_env_1.convertToTensor(x,"x","batchNormalization");var $mean=tensor_util_env_1.convertToTensor(mean,"mean","batchNormalization");var $variance=tensor_util_env_1.convertToTensor(variance,"variance","batchNormalization");var $scale;if(scale!=null){$scale=tensor_util_env_1.convertToTensor(scale,"scale","batchNormalization")}var $offset;if(offset!=null){$offset=tensor_util_env_1.convertToTensor(offset,"offset","batchNormalization")}util.assert($mean.rank===$variance.rank,"Batch normalization gradient requires mean and variance to have "+"equal ranks.");util.assert($offset==null||$mean.rank===$offset.rank,"Batch normalization gradient requires mean and offset to have "+"equal ranks.");util.assert($scale==null||$mean.rank===$scale.rank,"Batch normalization gradient requires mean and scale to have "+"equal ranks.");var x4D;if($x.rank===0||$x.rank===1){x4D=$x.as4D(1,1,1,$x.size)}else if($x.rank===2){x4D=$x.as4D(1,1,$x.shape[0],$x.shape[1])}else if($x.rank===3){x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}else{x4D=$x}var der=function(dy){var scaleValue=$scale==null?tensor_ops_1.scalar(1):$scale;var reductionAxes=broadcast_util_1.getReductionAxes($mean.shape,x4D.shape);var tileShape=[];if($mean.rank===1){for(var i=0;i<x4D.shape.length-1;++i){tileShape.push(x4D.shape[i])}tileShape.push(1)}var xMinusMean=$x.sub($mean);var dyTimesScaleValue=dy.mul(scaleValue);var oneOverSqrtVariance=unary_ops_1.rsqrt($variance.add(tensor_ops_1.scalar(varianceEpsilon)));var minusHalfRCube=oneOverSqrtVariance.mul(oneOverSqrtVariance).mul(oneOverSqrtVariance).mul(tensor_ops_1.scalar(-.5));var derX=function(){if($mean.rank===1){return dy.mul(array_ops_1.tile(oneOverSqrtVariance.as4D(1,1,1,$mean.shape[0]),tileShape)).mul(scaleValue).reshape($x.shape)}else{return dy.mul(oneOverSqrtVariance).mul(scaleValue).reshape($x.shape)}};var derMean=function(){var meanDer=oneOverSqrtVariance.mul(tensor_ops_1.scalar(-1)).mul(dyTimesScaleValue);if($mean.rank===1){meanDer=meanDer.sum(reductionAxes)}return meanDer.reshape($mean.shape)};var derVariance=function(){var varianceDer=minusHalfRCube.mul(xMinusMean).mul(dyTimesScaleValue);if($mean.rank===1){varianceDer=varianceDer.sum(reductionAxes)}return varianceDer.reshape($mean.shape)};var derScale=function(){var xMinusMean2TimesRsqrt=xMinusMean.mul(oneOverSqrtVariance);var scaleDer=dy.mul(xMinusMean2TimesRsqrt);if($mean.rank===1){scaleDer=scaleDer.sum(reductionAxes)}return scaleDer.reshape($mean.shape)};var derOffset=function(){var offsetDer=dy;if($mean.rank===1){offsetDer=offsetDer.sum(reductionAxes)}return offsetDer.reshape($mean.shape)};return{$x:derX,$mean:derMean,$variance:derVariance,$scale:derScale,$offset:derOffset}};var res=environment_1.ENV.engine.runKernel(function(backend){return backend.batchNormalization(x4D,batchnormReshape4D($mean),batchnormReshape4D($variance),varianceEpsilon,batchnormReshape4D($scale),batchnormReshape4D($offset))},{$x:$x,$mean:$mean,$variance:$variance,$scale:$scale,$offset:$offset},der);return res.reshape($x.shape)}function batchnormReshape4D(x){if(x==null){return null}if(x.rank===0){return x.as1D()}else if(x.rank===1){return x}else if(x.rank===2){return x.as4D(1,1,x.shape[0],x.shape[1])}else if(x.rank===3){return x.as4D(1,x.shape[0],x.shape[1],x.shape[2])}return x}exports.batchNormalization2d=operation_1.op({batchNormalization2d_:batchNormalization2d_});exports.batchNormalization3d=operation_1.op({batchNormalization3d_:batchNormalization3d_});exports.batchNormalization4d=operation_1.op({batchNormalization4d_:batchNormalization4d_});exports.batchNormalization=operation_1.op({batchNormalization_:batchNormalization_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./array_ops":125,"./broadcast_util":130,"./operation":147,"./tensor_ops":162,"./unary_ops":165}],129:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_1=require("../tensor_util");var tensor_util_env_1=require("../tensor_util_env");var types_1=require("../types");var util=require("../util");var broadcast_util=require("./broadcast_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");var unary_ops_1=require("./unary_ops");function add_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","add");var $b=tensor_util_env_1.convertToTensor(b,"b","add");tensor_util_1.assertTypesMatch($a,$b);var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var res=dy;var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($a.shape)};var derB=function(){var res=dy;var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($b.shape)};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.add($a,$b)},{$a:$a,$b:$b},der)}function addN_(tensors){util.assert(Array.isArray(tensors),function(){return"The argument passed to tf.addN() must be a list of tensors"});util.assert(tensors.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+(""+tensors.length)});var $tensors=tensors.map(function(t,i){return tensor_util_env_1.convertToTensor(t,"tensors"+i,"addN")});var firstTensor=$tensors[0];$tensors.forEach(function(t){if(t.dtype!==firstTensor.dtype){throw new Error("All tensors passed to tf.addN() must have the same dtype")}});$tensors.forEach(function(t){if(!util.arraysEqual(t.shape,firstTensor.shape)){throw new Error("All tensors passed to tf.addN() must have the same shape")}});var der=function(dy){var ders={};$tensors.forEach(function(t,i){ders[i]=function(){return dy.clone()}});return ders};var inputs=$tensors;return environment_1.ENV.engine.runKernel(function(backend){return backend.addN($tensors)},inputs,der)}function addStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in addStrict: ");return a.add(b)}function sub_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","sub");var $b=tensor_util_env_1.convertToTensor(b,"b","sub");tensor_util_1.assertTypesMatch($a,$b);var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var res=dy;var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($a.shape)};var derB=function(){var res=dy;var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.neg().reshape($b.shape)};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.subtract($a,$b)},{$a:$a,$b:$b},der)}function subStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in subStrict: ");return a.sub(b)}function pow_(base,exp){var $base=tensor_util_env_1.convertToTensor(base,"base","pow");var $exp=tensor_util_env_1.convertToTensor(exp,"exp","pow");var outShape=broadcast_util.assertAndGetBroadcastShape($base.shape,$exp.shape);base=$base.cast(types_1.upcastType($base.dtype,$exp.dtype));exp=$exp.cast(types_1.upcastType($base.dtype,$exp.dtype));var grad=function(dy,saved){var y=saved[0];var derBase=function(){var res=dy.mul($exp.toFloat().mul(y.div($base)));var reduceAxes=broadcast_util.getReductionAxes($base.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($base.shape)};var derExp=function(){var res=dy.mul(y.mul($base.log()).toFloat());var reduceAxes=broadcast_util.getReductionAxes($exp.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($exp.shape)};return{$base:derBase,$exp:derExp}};return environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.pow($base,$exp))},{$base:$base,$exp:$exp},grad)}function powStrict_(base,exp){util.assertShapesMatch(base.shape,exp.shape,"Error in powStrict: ");return base.pow(exp)}function mul_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","mul");var $b=tensor_util_env_1.convertToTensor(b,"b","mul");tensor_util_1.assertTypesMatch($a,$b);var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var res=dy.mul($b.toFloat());var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){return res.sum(reduceAxes).reshape($a.shape)}return res};var derB=function(){var res=dy.mul($a.toFloat());var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){return res.sum(reduceAxes).reshape($b.shape)}return res};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.multiply($a,$b)},{$a:$a,$b:$b},der)}function mulStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in multiplyStrict: ");return a.mul(b)}function div_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","div");var $b=tensor_util_env_1.convertToTensor(b,"b","div");tensor_util_1.assertTypesMatch($a,$b);var forwardFunc;if($a.dtype==="int32"&&$b.dtype==="int32"){return exports.floorDiv($a,$b)}else{forwardFunc=function(backend){return backend.realDivide($a,$b)}}var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var res=dy.div($b.toFloat());var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){return res.sum(reduceAxes).reshape($a.shape)}return res};var derB=function(){var res=dy.mul($a.toFloat());var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes).reshape($b.shape)}var tmp=$b.square();return res.div(tmp.toFloat()).neg()};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(forwardFunc,{$a:$a,$b:$b},der)}function floorDiv_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","floorDiv");var $b=tensor_util_env_1.convertToTensor(b,"b","floorDiv");tensor_util_1.assertTypesMatch($a,$b);var forwardFunc=function(backend){return backend.floorDiv($a,$b)};var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var res=dy.div($b.toFloat());var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){return res.sum(reduceAxes).reshape($a.shape)}return res};var derB=function(){var res=dy.mul($a.toFloat());var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes).reshape($b.shape)}var tmp=$b.square();return res.div(tmp.toFloat()).neg()};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(forwardFunc,{$a:$a,$b:$b},der)}function divStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in divideStrict: ");return a.div(b)}function mod_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","mod");var $b=tensor_util_env_1.convertToTensor(b,"b","mod");tensor_util_1.assertTypesMatch($a,$b);var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){return dy.sum(reduceAxes).reshape($a.shape)}return dy};var derB=function(){var res=dy.mul($a.div($b).floor().neg());var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){return res.sum(reduceAxes).reshape($b.shape)}return res};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.mod($a,$b)},{$a:$a,$b:$b},der)}function modStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in modStrict: ");return a.mod(b)}function minimum_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","minimum");var $b=tensor_util_env_1.convertToTensor(b,"b","minimum");tensor_util_1.assertTypesMatch($a,$b);if($a.dtype==="bool"){$a=$a.toInt()}if($b.dtype==="bool"){$b=$b.toInt()}broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){return dy.mul($a.lessEqual($b).toFloat())};var derB=function(){return dy.mul($a.greater($b).toFloat())};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.minimum($a,$b)},{$a:$a,$b:$b},der)}function minimumStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in minimumStrict: ");return a.minimum(b)}function maximum_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","maximum");var $b=tensor_util_env_1.convertToTensor(b,"b","maximum");tensor_util_1.assertTypesMatch($a,$b);if($a.dtype==="bool"){$a=$a.toInt()}if($b.dtype==="bool"){$b=$b.toInt()}broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){return dy.mul($a.greaterEqual($b).toFloat())};var derB=function(){return dy.mul($a.less($b).toFloat())};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.maximum($a,$b)},{$a:$a,$b:$b},der)}function maximumStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in maximumStrict: ");return a.maximum(b)}function squaredDifference_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","squaredDifference");var $b=tensor_util_env_1.convertToTensor(b,"b","squaredDifference");tensor_util_1.assertTypesMatch($a,$b);broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var two=tensor_ops_1.scalar(2);var derA=function(){return dy.mul($a.sub($b).mul(two))};var derB=function(){return dy.mul($b.sub($a).mul(two))};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.squaredDifference($a,$b)},{$a:$a,$b:$b},der)}function squaredDifferenceStrict_(a,b){util.assertShapesMatch(a.shape,b.shape,"Error in squaredDifferenceStrict: ");return a.squaredDifference(b)}function atan2_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","atan2");var $b=tensor_util_env_1.convertToTensor(b,"b","atan2");tensor_util_1.assertTypesMatch($a,$b);var outShape=broadcast_util.assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy){var derA=function(){var d=exports.add($a.square(),$b.square());var res=dy.mul($b.div(d));var reduceAxes=broadcast_util.getReductionAxes($a.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($a.shape)};var derB=function(){var d=exports.add($a.square(),$b.square());var res=unary_ops_1.neg(dy.mul($a.div(d)));var reduceAxes=broadcast_util.getReductionAxes($b.shape,outShape);if(reduceAxes.length>0){res=res.sum(reduceAxes)}return res.reshape($b.shape)};return{$a:derA,$b:derB}};return environment_1.ENV.engine.runKernel(function(backend){return backend.atan2($a,$b)},{$a:$a,$b:$b},der)}exports.add=operation_1.op({add_:add_});exports.addN=operation_1.op({addN_:addN_});exports.addStrict=operation_1.op({addStrict_:addStrict_});exports.atan2=operation_1.op({atan2_:atan2_});exports.div=operation_1.op({div_:div_});exports.divStrict=operation_1.op({divStrict_:divStrict_});exports.floorDiv=operation_1.op({floorDiv_:floorDiv_});exports.maximum=operation_1.op({maximum_:maximum_});exports.maximumStrict=operation_1.op({maximumStrict_:maximumStrict_});exports.minimum=operation_1.op({minimum_:minimum_});exports.minimumStrict=operation_1.op({minimumStrict_:minimumStrict_});exports.mod=operation_1.op({mod_:mod_});exports.modStrict=operation_1.op({modStrict_:modStrict_});exports.mul=operation_1.op({mul_:mul_});exports.mulStrict=operation_1.op({mulStrict_:mulStrict_});exports.pow=operation_1.op({pow_:pow_});exports.powStrict=operation_1.op({powStrict_:powStrict_});exports.squaredDifference=operation_1.op({squaredDifference_:squaredDifference_});exports.squaredDifferenceStrict=operation_1.op({squaredDifferenceStrict_:squaredDifferenceStrict_});exports.sub=operation_1.op({sub_:sub_});exports.subStrict=operation_1.op({subStrict_:subStrict_})},{"../environment":51,"../tensor_util":180,"../tensor_util_env":181,"../types":184,"../util":185,"./broadcast_util":130,"./operation":147,"./tensor_ops":162,"./unary_ops":165}],130:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function getBroadcastDims(inShape,outShape){var inRank=inShape.length;var dims=[];for(var i=0;i<inRank;i++){var dim=inRank-1-i;var a=inShape[dim]||1;var b=outShape[outShape.length-1-i]||1;if(b>1&&a===1){dims.unshift(dim)}}return dims}exports.getBroadcastDims=getBroadcastDims;function getReductionAxes(inShape,outShape){var result=[];for(var i=0;i<outShape.length;i++){var inDim=inShape[inShape.length-i-1];var outAxis=outShape.length-i-1;var outDim=outShape[outAxis];if(inDim==null||inDim===1&&outDim>1){result.unshift(outAxis)}}return result}exports.getReductionAxes=getReductionAxes;function broadcastDimsAreOuter(dims){for(var i=0;i<dims.length;i++){if(dims[i]!==i){return false}}return true}exports.broadcastDimsAreOuter=broadcastDimsAreOuter;function assertAndGetBroadcastShape(shapeA,shapeB){var result=[];var l=Math.max(shapeA.length,shapeB.length);for(var i=0;i<l;i++){var a=shapeA[shapeA.length-i-1];if(a==null){a=1}var b=shapeB[shapeB.length-i-1];if(b==null){b=1}if(a===1){result.unshift(b)}else if(b===1){result.unshift(a)}else if(a!==b){var errMsg="Operands could not be broadcast together with shapes "+(shapeA+" and "+shapeB+".");throw Error(errMsg)}else{result.unshift(a)}}return result}exports.assertAndGetBroadcastShape=assertAndGetBroadcastShape},{}],131:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_1=require("../tensor_util");var tensor_util_env_1=require("../tensor_util_env");var util_1=require("../util");var broadcast_util_1=require("./broadcast_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function notEqual_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","notEqual");var $b=tensor_util_env_1.convertToTensor(b,"b","notEqual");tensor_util_1.assertTypesMatch($a,$b);broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.notEqual($a,$b)},{$a:$a,$b:$b})}function notEqualStrict_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","notEqualStrict");var $b=tensor_util_env_1.convertToTensor(b,"b","notEqualStrict");util_1.assertShapesMatch($a.shape,$b.shape,"Error in notEqualStrict: ");return $a.notEqual($b)}function less_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","less");var $b=tensor_util_env_1.convertToTensor(b,"b","less");tensor_util_1.assertTypesMatch($a,$b);broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.less($a,$b)},{$a:$a,$b:$b})}function lessStrict_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","lessStrict");var $b=tensor_util_env_1.convertToTensor(b,"b","lessStrict");util_1.assertShapesMatch($a.shape,$b.shape,"Error in lessStrict: ");return $a.less($b)}function equal_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","equal");var $b=tensor_util_env_1.convertToTensor(b,"b","equal");tensor_util_1.assertTypesMatch($a,$b);broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.equal($a,$b)},{$a:$a,$b:$b})}function equalStrict_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","equalStrict");var $b=tensor_util_env_1.convertToTensor(b,"b","equalStrict");util_1.assertShapesMatch($a.shape,$b.shape,"Error in equalStrict: ");return $a.equal($b)}function lessEqual_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","lessEqual");var $b=tensor_util_env_1.convertToTensor(b,"b","lessEqual");tensor_util_1.assertTypesMatch($a,$b);broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.lessEqual($a,$b)},{$a:$a,$b:$b})}function lessEqualStrict_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","lessEqualStrict");var $b=tensor_util_env_1.convertToTensor(b,"b","lessEqualStrict");util_1.assertShapesMatch($a.shape,$b.shape,"Error in lessEqualStrict: ");return $a.lessEqual($b)}function greater_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","greater");var $b=tensor_util_env_1.convertToTensor(b,"b","greater");tensor_util_1.assertTypesMatch($a,$b);broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.greater($a,$b)},{$a:$a,$b:$b})}function greaterStrict_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","greaterStrict");var $b=tensor_util_env_1.convertToTensor(b,"b","greaterStrict");util_1.assertShapesMatch($a.shape,$b.shape,"Error in greaterStrict: ");return $a.greater($b)}function greaterEqual_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","greaterEqual");var $b=tensor_util_env_1.convertToTensor(b,"b","greaterEqual");tensor_util_1.assertTypesMatch($a,$b);broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);var grad=function(dy){return{$a:function(){return tensor_ops_1.zerosLike($a)},$b:function(){return tensor_ops_1.zerosLike($b)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.greaterEqual($a,$b)},{$a:$a,$b:$b},grad)}function greaterEqualStrict_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","greaterEqualStrict");var $b=tensor_util_env_1.convertToTensor(b,"b","greaterEqualStrict");util_1.assertShapesMatch($a.shape,$b.shape,"Error in greaterEqualStrict: ");return $a.greaterEqual($b)}exports.equal=operation_1.op({equal_:equal_});exports.equalStrict=operation_1.op({equalStrict_:equalStrict_});exports.greater=operation_1.op({greater_:greater_});exports.greaterEqual=operation_1.op({greaterEqual_:greaterEqual_});exports.greaterEqualStrict=operation_1.op({greaterEqualStrict_:greaterEqualStrict_});exports.greaterStrict=operation_1.op({greaterStrict_:greaterStrict_});exports.less=operation_1.op({less_:less_});exports.lessEqual=operation_1.op({lessEqual_:lessEqual_});exports.lessEqualStrict=operation_1.op({lessEqualStrict_:lessEqualStrict_});exports.lessStrict=operation_1.op({lessStrict_:lessStrict_});exports.notEqual=operation_1.op({notEqual_:notEqual_});exports.notEqualStrict=operation_1.op({notEqualStrict_:notEqualStrict_})},{"../environment":51,"../tensor_util":180,"../tensor_util_env":181,"../util":185,"./broadcast_util":130,"./operation":147,"./tensor_ops":162}],132:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var operation_1=require("./operation");function complex_(real,imag){var $real=tensor_util_env_1.convertToTensor(real,"real","complex");var $imag=tensor_util_env_1.convertToTensor(imag,"imag","complex");util.assertShapesMatch($real.shape,$imag.shape,"real and imag shapes, "+$real.shape+" and "+$imag.shape+", "+"must match in call to tf.complex().");return environment_1.ENV.engine.runKernel(function(backend){return backend.complex($real,$imag)},{$real:$real,$imag:$imag})}function real_(input){var $input=tensor_util_env_1.convertToTensor(input,"input","real");return environment_1.ENV.engine.runKernel(function(backend){return backend.real($input)},{$input:$input})}function imag_(input){var $input=tensor_util_env_1.convertToTensor(input,"input","imag");return environment_1.ENV.engine.runKernel(function(backend){return backend.imag($input)},{$input:$input})}exports.complex=operation_1.op({complex_:complex_});exports.real=operation_1.op({real_:real_});exports.imag=operation_1.op({imag_:imag_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./operation":147}],133:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util_1=require("../util");var axis_util_1=require("./axis_util");var concat_util_1=require("./concat_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function concat1d_(tensors){return exports.concat(tensors,0)}function concat2d_(tensors,axis){return exports.concat(tensors,axis)}function concat3d_(tensors,axis){return exports.concat(tensors,axis)}function concat4d_(tensors,axis){return exports.concat(tensors,axis)}function concat_(tensors,axis){if(axis===void 0){axis=0}util_1.assert(tensors.length>=1,"Pass at least one tensor to concat");var $tensors=tensor_util_env_1.convertToTensorArray(tensors,"tensors","concat");axis=axis_util_1.parseAxisParam(axis,$tensors[0].shape)[0];var outShape=concat_util_1.computeOutShape($tensors.map(function(t){return t.shape}),axis);if(util_1.sizeFromShape(outShape)===0){return tensor_ops_1.tensor([],outShape)}$tensors=$tensors.filter(function(t){return t.size>0});if($tensors.length===1){return $tensors[0]}var shapes=$tensors.map(function(t){return t.shape});concat_util_1.assertParamsConsistent(shapes,axis);var der=function(dy){var sizeSplits=shapes.map(function(s){return s[axis]});var derTensors=exports.split(dy,sizeSplits,axis);return derTensors.map(function(t){return function(){return t}})};var inputs=$tensors;return environment_1.ENV.engine.runKernel(function(backend){return backend.concat($tensors,axis)},inputs,der)}function split_(x,numOrSizeSplits,axis){if(axis===void 0){axis=0}var $x=tensor_util_env_1.convertToTensor(x,"x","split");axis=axis_util_1.parseAxisParam(axis,$x.shape)[0];var splitSizes;if(typeof numOrSizeSplits==="number"){util_1.assert($x.shape[axis]%numOrSizeSplits===0,"Number of splits must evenly divide the axis.");splitSizes=Array(numOrSizeSplits).fill($x.shape[axis]/numOrSizeSplits)}else{util_1.assert($x.shape[axis]===numOrSizeSplits.reduce(function(a,b){return a+b}),"The sum of sizes must match the size of the axis dimension.");splitSizes=numOrSizeSplits}var der=function(dy){return{$x:function(){return exports.concat(dy,axis)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.split($x,splitSizes,axis)},{$x:$x},der)}exports.concat=operation_1.op({concat_:concat_});exports.concat1d=operation_1.op({concat1d_:concat1d_});exports.concat2d=operation_1.op({concat2d_:concat2d_});exports.concat3d=operation_1.op({concat3d_:concat3d_});exports.concat4d=operation_1.op({concat4d_:concat4d_});exports.split=operation_1.op({split_:split_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./axis_util":127,"./concat_util":134,"./operation":147,"./tensor_ops":162}],134:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function assertParamsConsistent(shapes,axis){var rank=shapes[0].length;shapes.forEach(function(shape,i){util.assert(shape.length===rank,"Error in concat"+rank+"D: rank of tensors["+i+"] must be the same "+("as the rank of the rest ("+rank+")"))});util.assert(axis>=0&&axis<rank,"Error in concat"+rank+"D: axis must be between 0 and "+(rank-1)+".");var firstShape=shapes[0];shapes.forEach(function(shape,i){for(var r=0;r<rank;r++){util.assert(r===axis||shape[r]===firstShape[r],"Error in concat"+rank+"D: Shape of tensors["+i+"] ("+shape+") "+("does not match the shape of the rest ("+firstShape+") ")+("along the non-concatenated axis "+i+"."))}})}exports.assertParamsConsistent=assertParamsConsistent;function computeOutShape(shapes,axis){var outputShape=shapes[0].slice();for(var i=1;i<shapes.length;i++){outputShape[axis]+=shapes[i][axis]}return outputShape}exports.computeOutShape=computeOutShape},{"../util":185}],135:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var conv_util=require("./conv_util");var matmul_1=require("./matmul");var operation_1=require("./operation");function conv1d_(x,filter,stride,pad,dataFormat,dilation,dimRoundingMode){if(dataFormat===void 0){dataFormat="NWC"}if(dilation===void 0){dilation=1}var $x=tensor_util_env_1.convertToTensor(x,"x","conv1d");var $filter=tensor_util_env_1.convertToTensor(filter,"filter","conv1d");var x3D=$x;var reshapedTo3D=false;if($x.rank===2){reshapedTo3D=true;x3D=$x.as3D(1,$x.shape[0],$x.shape[1])}util.assert(x3D.rank===3,"Error in conv1d: input must be rank 3, but got rank "+x3D.rank+".");util.assert($filter.rank===3,"Error in conv1d: filter must be rank 3, but got rank "+($filter.rank+"."));if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in conv1d: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}util.assert(x3D.shape[2]===$filter.shape[1],"Error in conv1d: depth of input ("+x3D.shape[2]+") must match "+("input depth for filter "+$filter.shape[1]+"."));util.assert(eitherStridesOrDilationsAreOne(stride,dilation),"Error in conv1D: Either stride or dilation must be 1. "+("Got stride "+stride+" and dilation '"+dilation+"'"));util.assert(dataFormat==="NWC","Error in conv1d: got dataFormat of "+dataFormat+" but only NWC is currently supported.");var filter4D=$filter.as4D(1,$filter.shape[0],$filter.shape[1],$filter.shape[2]);var input4D=x3D.as4D(x3D.shape[0],1,x3D.shape[1],x3D.shape[2]);var strides=[1,stride];var dilations=[1,dilation];var conv2dDataFormat="NHWC";var res=exports.conv2d(input4D,filter4D,strides,pad,conv2dDataFormat,dilations,dimRoundingMode);if(reshapedTo3D){return res.as2D(res.shape[2],res.shape[3])}return res.as3D(res.shape[0],res.shape[2],res.shape[3])}function conv2d_(x,filter,strides,pad,dataFormat,dilations,dimRoundingMode){if(dataFormat===void 0){dataFormat="NHWC"}if(dilations===void 0){dilations=[1,1]}var $x=tensor_util_env_1.convertToTensor(x,"x","conv2d");var $filter=tensor_util_env_1.convertToTensor(filter,"filter","conv2d");var x4D=$x;var reshapedTo4D=false;if($x.rank===3){reshapedTo4D=true;x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}util.assert(x4D.rank===4,"Error in conv2d: input must be rank 4, but got rank "+x4D.rank+".");util.assert($filter.rank===4,"Error in conv2d: filter must be rank 4, but got rank "+($filter.rank+"."));if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in conv2d: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}util.assert(x4D.shape[3]===$filter.shape[2],"Error in conv2d: depth of input ("+x4D.shape[3]+") must match "+("input depth for filter "+$filter.shape[2]+"."));util.assert(eitherStridesOrDilationsAreOne(strides,dilations),"Error in conv2D: Either strides or dilations must be 1. "+("Got strides "+strides+" and dilations '"+dilations+"'"));util.assert(dataFormat==="NHWC","Error in conv2d: got dataFormat of "+dataFormat+" but only NHWC is currently supported.");var convInfo=conv_util.computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad,dimRoundingMode);var res;if(convInfo.filterHeight===1&&convInfo.filterWidth===1&&convInfo.dilationHeight===1&&convInfo.dilationWidth===1&&convInfo.strideHeight===1&&convInfo.strideWidth===1&&convInfo.padInfo.type==="SAME"){var x2d=x4D.reshape([-1,convInfo.inChannels]);var w2d=$filter.reshape([convInfo.inChannels,convInfo.outChannels]);res=matmul_1.matMul(x2d,w2d).reshape(convInfo.outShape)}else{var grad=function(dy){util.assert(tupleValuesAreOne(dilations),"Error in gradient of conv2D: dilation rates greater than 1 are not"+("yet supported in gradients. Got dilations '"+dilations+"'"));return{x:function(){return conv2dDerInput_(x4D.shape,dy,$filter,strides,pad)},$filter:function(){return conv2dDerFilter_(x4D,dy,$filter.shape,strides,pad)}}};res=environment_1.ENV.engine.runKernel(function(backend){return backend.conv2d(x4D,$filter,convInfo)},{x:x4D,$filter:$filter},grad)}if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function conv2dDerInput_(xShape,dy,filter,strides,pad,dimRoundingMode){util.assert(xShape.length===dy.rank,"Length of inShape "+("("+xShape.length+") and rank of dy ("+dy.rank+") must match"));var xShape4D=xShape;var dy4D=dy;var reshapedTo4D=false;if(dy.rank===3){reshapedTo4D=true;dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2]);xShape4D=[1,xShape[0],xShape[1],xShape[2]]}var inDepth=xShape4D[3];var outDepth=dy4D.shape[3];util.assert(xShape4D.length===4,"Error in conv2dDerInput: inShape must be length 4, but got length "+(xShape4D.length+"."));util.assert(dy4D.rank===4,"Error in conv2dDerInput: dy must be rank 4, but got "+("rank "+dy4D.rank));util.assert(filter.rank===4,"Error in conv2dDerInput: filter must be rank 4, but got "+("rank "+filter.rank));util.assert(inDepth===filter.shape[2],"Error in conv2dDerInput: depth of input ("+inDepth+") must "+("match input depth for filter "+filter.shape[2]+"."));util.assert(outDepth===filter.shape[3],"Error in conv2dDerInput: depth of output ("+outDepth+") must "+("match output depth for filter "+filter.shape[3]+"."));if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in conv2dDerInput: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}var dilations=1;var convInfo=conv_util.computeConv2DInfo(xShape4D,filter.shape,strides,dilations,pad,dimRoundingMode);var res=environment_1.ENV.engine.runKernel(function(backend){return backend.conv2dDerInput(dy4D,filter,convInfo)},{dy4D:dy4D});if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function conv2dDerFilter_(x,dy,filterShape,strides,pad,dimRoundingMode){var x4D=x;if(x.rank===3){x4D=x.as4D(1,x.shape[0],x.shape[1],x.shape[2])}var dy4D=dy;if(dy4D.rank===3){dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2])}util.assert(x4D.rank===4,"Error in conv2dDerFilter: input must be rank 4, but got shape "+(x4D.shape+"."));util.assert(dy4D.rank===4,"Error in conv2dDerFilter: dy must be rank 4, but got shape "+(dy4D.shape+"."));util.assert(filterShape.length===4,"Error in conv2dDerFilter: filterShape must be length 4, but got "+(filterShape+"."));util.assert(x4D.shape[3]===filterShape[2],"Error in conv2dDerFilter: depth of input "+x4D.shape[3]+") must "+("match input depth in filter ("+filterShape[2]+"."));util.assert(dy4D.shape[3]===filterShape[3],"Error in conv2dDerFilter: depth of dy ("+dy4D.shape[3]+") must "+("match output depth for filter ("+filterShape[3]+")."));if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in conv2dDerFilter: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}var dilations=1;var convInfo=conv_util.computeConv2DInfo(x4D.shape,filterShape,strides,dilations,pad,dimRoundingMode);return environment_1.ENV.engine.runKernel(function(backend){return backend.conv2dDerFilter(x4D,dy4D,convInfo)},{x4D:x4D,dy4D:dy4D})}function conv2dTranspose_(x,filter,outputShape,strides,pad,dimRoundingMode){var $x=tensor_util_env_1.convertToTensor(x,"x","conv2dTranspose");var $filter=tensor_util_env_1.convertToTensor(filter,"filter","conv2dTranspose");return conv2dDerInput_(outputShape,$x,$filter,strides,pad,dimRoundingMode)}function depthwiseConv2d_(x,filter,strides,pad,dataFormat,dilations,dimRoundingMode){if(dataFormat===void 0){dataFormat="NHWC"}if(dilations===void 0){dilations=[1,1]}var $x=tensor_util_env_1.convertToTensor(x,"x","depthwiseConv2d");var $filter=tensor_util_env_1.convertToTensor(filter,"filter","depthwiseConv2d");var x4D=$x;var reshapedTo4D=false;if($x.rank===3){reshapedTo4D=true;x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}util.assert(x4D.rank===4,"Error in depthwiseConv2d: input must be rank 4, but got "+("rank "+x4D.rank+"."));util.assert($filter.rank===4,"Error in depthwiseConv2d: filter must be rank 4, but got rank "+($filter.rank+"."));util.assert(x4D.shape[3]===$filter.shape[2],"Error in depthwiseConv2d: number of input channels "+("("+x4D.shape[3]+") must match the inChannels dimension in ")+("filter "+$filter.shape[2]+"."));if(dilations==null){dilations=[1,1]}util.assert(eitherStridesOrDilationsAreOne(strides,dilations),"Error in depthwiseConv2d: Either strides or dilations must be 1. "+("Got strides "+strides+" and dilations '"+dilations+"'"));if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in depthwiseConv2d: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}var convInfo=conv_util.computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad,dimRoundingMode,true);var grad=function(dy){util.assert(tupleValuesAreOne(dilations),"Error in gradient of depthwiseConv2d: dilation rates greater than "+("1 are not yet supported. Got dilations '"+dilations+"'"));return{x:function(){return depthwiseConv2dDerInput(x4D.shape,dy,$filter,convInfo)},$filter:function(){return depthwiseConv2dDerFilter(x4D,dy,$filter.shape,convInfo)}}};var res=environment_1.ENV.engine.runKernel(function(backend){return backend.depthwiseConv2D(x4D,$filter,convInfo)},{x:x4D,$filter:$filter},grad);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function separableConv2d_(x,depthwiseFilter,pointwiseFilter,strides,pad,dilation,dataFormat){if(dilation===void 0){dilation=[1,1]}if(dataFormat===void 0){dataFormat="NHWC"}var $x=tensor_util_env_1.convertToTensor(x,"x","separableConv2d");var $depthwiseFilter=tensor_util_env_1.convertToTensor(depthwiseFilter,"depthwiseFilter","separableConv2d");var $pointwiseFilter=tensor_util_env_1.convertToTensor(pointwiseFilter,"pointwiseFilter","separableConv2d");var x4D=$x;var reshapedTo4D=false;if($x.rank===3){reshapedTo4D=true;x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}if(dataFormat==="NCHW"){throw new Error("separableConv2d currently does not support dataFormat NCHW; only "+"NHWC is supported")}util.assert(x4D.rank===4,"Error in separableConv2d: input must be rank 4, but got "+("rank "+x4D.rank+"."));util.assert($depthwiseFilter.rank===4,"Error in separableConv2d: depthwise filter must be rank 4, but got "+("rank "+$depthwiseFilter.rank+"."));util.assert($pointwiseFilter.rank===4,"Error in separableConv2d: pointwise filter must be rank 4, but got "+("rank "+$depthwiseFilter.rank+"."));util.assert($pointwiseFilter.shape[0]===1,"Error in separableConv2d: the first dimension of pointwise filter "+(" must be 1, but got "+$pointwiseFilter.shape[0]+"."));util.assert($pointwiseFilter.shape[1]===1,"Error in separableConv2d: the second dimension of pointwise filter "+(" must be 1, but got "+$pointwiseFilter.shape[1]+"."));var inChannels=$depthwiseFilter.shape[2];var channelMultiplier=$depthwiseFilter.shape[3];util.assert($pointwiseFilter.shape[2]===inChannels*channelMultiplier,"Error in separableConv2d: the third dimension of pointwise filter "+("must be "+inChannels*channelMultiplier+", ")+("but got "+$pointwiseFilter.shape[2]+"."));var depthwise=exports.depthwiseConv2d(x4D,$depthwiseFilter,strides,pad,dataFormat,dilation);var pointwiseStride=1;var res=exports.conv2d(depthwise,$pointwiseFilter,pointwiseStride,"valid",dataFormat);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function parseTupleParam(param){return typeof param==="number"?[param,param]:param}function tupleValuesAreOne(param){var _a=parseTupleParam(param),dimA=_a[0],dimB=_a[1];return dimA===1&&dimB===1}function eitherStridesOrDilationsAreOne(strides,dilations){return tupleValuesAreOne(strides)||tupleValuesAreOne(dilations)}function depthwiseConv2dDerInput(xShape,dy,filter,convInfo){var dy4D=dy;var reshapedTo4D=false;if(dy.rank===3){reshapedTo4D=true;dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2])}var res=environment_1.ENV.engine.runKernel(function(backend){return backend.depthwiseConv2DDerInput(dy4D,filter,convInfo)},{dy4D:dy4D});if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function depthwiseConv2dDerFilter(x,dy,filterShape,convInfo){var x4D=x;if(x.rank===3){x4D=x.as4D(1,x.shape[0],x.shape[1],x.shape[2])}var dy4D=dy;if(dy4D.rank===3){dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2])}return environment_1.ENV.engine.runKernel(function(backend){return backend.depthwiseConv2DDerFilter(x4D,dy4D,convInfo)},{x4D:x4D,dy4D:dy4D})}exports.conv1d=operation_1.op({conv1d_:conv1d_});exports.conv2d=operation_1.op({conv2d_:conv2d_});exports.depthwiseConv2d=operation_1.op({depthwiseConv2d_:depthwiseConv2d_});exports.separableConv2d=operation_1.op({separableConv2d_:separableConv2d_});exports.conv2dTranspose=operation_1.op({conv2dTranspose_:conv2dTranspose_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./conv_util":136,"./matmul":144,"./operation":147}],136:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function computePool2DInfo(inShape,filterSize,strides,pad,roundingMode,dataFormat){if(dataFormat===void 0){dataFormat="channelsLast"}var _a=parseTupleParam(filterSize),filterHeight=_a[0],filterWidth=_a[1];var filterShape;if(dataFormat==="channelsLast"){filterShape=[filterHeight,filterWidth,inShape[3],inShape[3]]}else if(dataFormat==="channelsFirst"){filterShape=[filterHeight,filterWidth,inShape[1],inShape[1]]}else{throw new Error("Unknown dataFormat "+dataFormat)}var dilations=1;return computeConv2DInfo(inShape,filterShape,strides,dilations,pad,roundingMode,false,dataFormat)}exports.computePool2DInfo=computePool2DInfo;function computeConv2DInfo(inShape,filterShape,strides,dilations,pad,roundingMode,depthwise,dataFormat){if(depthwise===void 0){depthwise=false}if(dataFormat===void 0){dataFormat="channelsLast"}var _a=[-1,-1,-1,-1],batchSize=_a[0],inHeight=_a[1],inWidth=_a[2],inChannels=_a[3];if(dataFormat==="channelsLast"){batchSize=inShape[0],inHeight=inShape[1],inWidth=inShape[2],inChannels=inShape[3]}else if(dataFormat==="channelsFirst"){batchSize=inShape[0],inChannels=inShape[1],inHeight=inShape[2],inWidth=inShape[3]}else{throw new Error("Unknown dataFormat "+dataFormat)}var filterHeight=filterShape[0],filterWidth=filterShape[1],filterChannels=filterShape[3];var _b=parseTupleParam(strides),strideHeight=_b[0],strideWidth=_b[1];var _c=parseTupleParam(dilations),dilationHeight=_c[0],dilationWidth=_c[1];var effectiveFilterHeight=getEffectiveFilterSize(filterHeight,dilationHeight);var effectiveFilterWidth=getEffectiveFilterSize(filterWidth,dilationWidth);var _d=getPadAndOutInfo(pad,inHeight,inWidth,strideHeight,strideWidth,effectiveFilterHeight,effectiveFilterWidth,roundingMode),padInfo=_d.padInfo,outHeight=_d.outHeight,outWidth=_d.outWidth;var outChannels=depthwise?filterChannels*inChannels:filterChannels;var outShape;if(dataFormat==="channelsFirst"){outShape=[batchSize,outChannels,outHeight,outWidth]}else if(dataFormat==="channelsLast"){outShape=[batchSize,outHeight,outWidth,outChannels]}return{batchSize:batchSize,dataFormat:dataFormat,inHeight:inHeight,inWidth:inWidth,inChannels:inChannels,outHeight:outHeight,outWidth:outWidth,outChannels:outChannels,padInfo:padInfo,strideHeight:strideHeight,strideWidth:strideWidth,filterHeight:filterHeight,filterWidth:filterWidth,dilationHeight:dilationHeight,dilationWidth:dilationWidth,inShape:inShape,outShape:outShape,filterShape:filterShape}}exports.computeConv2DInfo=computeConv2DInfo;function computeOutputShape3D(inShape,fieldSize,outDepth,stride,zeroPad,roundingMode){if(zeroPad==null){zeroPad=computeDefaultPad(inShape,fieldSize,stride)}var inputRows=inShape[0];var inputCols=inShape[1];var outputRows=conditionalRound((inputRows-fieldSize+2*zeroPad)/stride+1,roundingMode);util.assert(util.isInt(outputRows),"The output # of rows ("+outputRows+") must be an integer. Change the "+"stride and/or zero pad parameters");var outputCols=conditionalRound((inputCols-fieldSize+2*zeroPad)/stride+1,roundingMode);util.assert(util.isInt(outputCols),"The output # of columns ("+outputCols+") must be an integer. Change "+"the stride and/or zero pad parameters");return[outputRows,outputCols,outDepth]}function computeDefaultPad(inputShape,fieldSize,stride,dilation){if(dilation===void 0){dilation=1}var effectiveFieldSize=getEffectiveFilterSize(fieldSize,dilation);return Math.floor((inputShape[0]*(stride-1)-stride+effectiveFieldSize)/2)}exports.computeDefaultPad=computeDefaultPad;function parseTupleParam(param){return typeof param==="number"?[param,param]:param}function getEffectiveFilterSize(filterSize,dilation){if(dilation<=1){return filterSize}return filterSize+(filterSize-1)*(dilation-1)}function getPadAndOutInfo(pad,inHeight,inWidth,strideHeight,strideWidth,filterHeight,filterWidth,roundingMode){var padInfo;var outHeight;var outWidth;if(typeof pad==="number"){var padType=pad===0?"VALID":"NUMBER";padInfo={top:pad,bottom:pad,left:pad,right:pad,type:padType};var outShape=computeOutputShape3D([inHeight,inWidth,1],filterHeight,1,strideHeight,pad,roundingMode);outHeight=outShape[0];outWidth=outShape[1]}else if(pad==="same"){outHeight=Math.ceil(inHeight/strideHeight);outWidth=Math.ceil(inWidth/strideWidth);var padAlongHeight=(outHeight-1)*strideHeight+filterHeight-inHeight;var padAlongWidth=(outWidth-1)*strideWidth+filterWidth-inWidth;var top_1=Math.floor(padAlongHeight/2);var bottom=padAlongHeight-top_1;var left=Math.floor(padAlongWidth/2);var right=padAlongWidth-left;padInfo={top:top_1,bottom:bottom,left:left,right:right,type:"SAME"}}else if(pad==="valid"){padInfo={top:0,bottom:0,left:0,right:0,type:"VALID"};outHeight=Math.ceil((inHeight-filterHeight+1)/strideHeight);outWidth=Math.ceil((inWidth-filterWidth+1)/strideWidth)}else{throw Error("Unknown padding parameter: "+pad)}return{padInfo:padInfo,outHeight:outHeight,outWidth:outWidth}}function conditionalRound(value,roundingMode){if(!roundingMode){return value}switch(roundingMode){case"round":return Math.round(value);case"ceil":return Math.ceil(value);case"floor":return Math.floor(value);default:throw new Error("Unknown roundingMode "+roundingMode)}}},{"../util":185}],137:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ERF_P=.3275911;exports.ERF_A1=.254829592;exports.ERF_A2=-.284496736;exports.ERF_A3=1.421413741;exports.ERF_A4=-1.453152027;exports.ERF_A5=1.061405429},{}],138:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var non_max_suppression_impl_1=require("../kernels/non_max_suppression_impl");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var operation_1=require("./operation");function resizeBilinear_(images,size,alignCorners){if(alignCorners===void 0){alignCorners=false}var $images=tensor_util_env_1.convertToTensor(images,"images","resizeBilinear");util.assert($images.rank===3||$images.rank===4,"Error in resizeBilinear: x must be rank 3 or 4, but got "+("rank "+$images.rank+"."));util.assert(size.length===2,"Error in resizeBilinear: new shape must 2D, but got shape "+(size+"."));var batchImages=$images;var reshapedTo4D=false;if($images.rank===3){reshapedTo4D=true;batchImages=$images.as4D(1,$images.shape[0],$images.shape[1],$images.shape[2])}var newHeight=size[0],newWidth=size[1];var forward=function(backend,save){return backend.resizeBilinear(batchImages,newHeight,newWidth,alignCorners)};var backward=function(dy,saved){return{batchImages:function(){return environment_1.ENV.engine.runKernel(function(backend){return backend.resizeBilinearBackprop(dy,batchImages,alignCorners)},{})}}};var res=environment_1.ENV.engine.runKernel(forward,{batchImages:batchImages},backward);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function resizeNearestNeighbor_(images,size,alignCorners){if(alignCorners===void 0){alignCorners=false}var $images=tensor_util_env_1.convertToTensor(images,"images","resizeNearestNeighbor");util.assert($images.rank===3||$images.rank===4,"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+("rank "+$images.rank+"."));util.assert(size.length===2,"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+(size+"."));util.assert($images.dtype==="float32"||$images.dtype==="int32","`images` must have `int32` or `float32` as dtype");var batchImages=$images;var reshapedTo4D=false;if($images.rank===3){reshapedTo4D=true;batchImages=$images.as4D(1,$images.shape[0],$images.shape[1],$images.shape[2])}var newHeight=size[0],newWidth=size[1];var forward=function(backend,save){return backend.resizeNearestNeighbor(batchImages,newHeight,newWidth,alignCorners)};var backward=function(dy,saved){return{batchImages:function(){return environment_1.ENV.engine.runKernel(function(backend){return backend.resizeNearestNeighborBackprop(dy,batchImages,alignCorners)},{})}}};var res=environment_1.ENV.engine.runKernel(forward,{batchImages:batchImages},backward);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function nonMaxSuppression_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){if(iouThreshold===void 0){iouThreshold=.5}if(scoreThreshold===void 0){scoreThreshold=Number.NEGATIVE_INFINITY}var $boxes=tensor_util_env_1.convertToTensor(boxes,"boxes","nonMaxSuppression");var $scores=tensor_util_env_1.convertToTensor(scores,"scores","nonMaxSuppression");var inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold);maxOutputSize=inputs.maxOutputSize;iouThreshold=inputs.iouThreshold;scoreThreshold=inputs.scoreThreshold;return environment_1.ENV.engine.runKernel(function(b){return b.nonMaxSuppression($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold)},{$boxes:$boxes})}function nonMaxSuppressionAsync_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){if(iouThreshold===void 0){iouThreshold=.5}if(scoreThreshold===void 0){scoreThreshold=Number.NEGATIVE_INFINITY}return __awaiter(this,void 0,void 0,function(){var $boxes,$scores,inputs,boxesVals,scoresVals,res;return __generator(this,function(_a){switch(_a.label){case 0:$boxes=tensor_util_env_1.convertToTensor(boxes,"boxes","nonMaxSuppressionAsync");$scores=tensor_util_env_1.convertToTensor(scores,"scores","nonMaxSuppressionAsync");inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold);maxOutputSize=inputs.maxOutputSize;iouThreshold=inputs.iouThreshold;scoreThreshold=inputs.scoreThreshold;return[4,$boxes.data()];case 1:boxesVals=_a.sent();return[4,$scores.data()];case 2:scoresVals=_a.sent();res=non_max_suppression_impl_1.nonMaxSuppressionImpl(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold);if($boxes!==boxes){$boxes.dispose()}if($scores!==scores){$scores.dispose()}return[2,res]}})})}function nonMaxSuppSanityCheck(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){if(iouThreshold==null){iouThreshold=.5}if(scoreThreshold==null){scoreThreshold=Number.NEGATIVE_INFINITY}var numBoxes=boxes.shape[0];maxOutputSize=Math.min(maxOutputSize,numBoxes);util.assert(0<=iouThreshold&&iouThreshold<=1,"iouThreshold must be in [0, 1], but was '"+iouThreshold+"'");util.assert(boxes.rank===2,"boxes must be a 2D tensor, but was of rank '"+boxes.rank+"'");util.assert(boxes.shape[1]===4,"boxes must have 4 columns, but 2nd dimension was "+boxes.shape[1]);util.assert(scores.rank===1,"scores must be a 1D tensor");util.assert(scores.shape[0]===numBoxes,"scores has incompatible shape with boxes. Expected "+numBoxes+", "+("but was "+scores.shape[0]));return{maxOutputSize:maxOutputSize,iouThreshold:iouThreshold,scoreThreshold:scoreThreshold}}function cropAndResize_(image,boxes,boxInd,cropSize,method,extrapolationValue){var $image=tensor_util_env_1.convertToTensor(image,"image","cropAndResize","float32");var $boxes=tensor_util_env_1.convertToTensor(boxes,"boxes","cropAndResize","float32");var $boxInd=tensor_util_env_1.convertToTensor(boxInd,"boxInd","cropAndResize","int32");method=method||"bilinear";extrapolationValue=extrapolationValue||0;var numBoxes=$boxes.shape[0];util.assert($image.rank===4,"Error in cropAndResize: image must be rank 4,"+("but got rank "+$image.rank+"."));util.assert($boxes.rank===2&&$boxes.shape[1]===4,"Error in cropAndResize: boxes must be have size ["+numBoxes+",4] "+("but had shape "+$boxes.shape+"."));util.assert($boxInd.rank===1&&$boxInd.shape[0]===numBoxes,"Error in cropAndResize: boxInd must be have size ["+numBoxes+"] "+("but had shape "+$boxes.shape+"."));util.assert($boxInd.dtype==="int32","Error in cropAndResize: boxInd must be of dtype int32, but got dtype "+($boxInd.dtype+"."));util.assert(cropSize.length===2,"Error in cropAndResize: cropSize must be of length 2, but got length "+(cropSize.length+"."));util.assert(cropSize[0]>=1&&cropSize[1]>=1,"cropSize must be atleast [1,1], but was "+cropSize);util.assert(method==="bilinear"||method==="nearest","method must be bilinear or nearest, but was "+method);var forward=function(backend,save){return backend.cropAndResize($image,$boxes,$boxInd,cropSize,method,extrapolationValue)};var res=environment_1.ENV.engine.runKernel(forward,{$image:$image,$boxes:$boxes});return res}exports.resizeBilinear=operation_1.op({resizeBilinear_:resizeBilinear_});exports.resizeNearestNeighbor=operation_1.op({resizeNearestNeighbor_:resizeNearestNeighbor_});exports.nonMaxSuppression=operation_1.op({nonMaxSuppression_:nonMaxSuppression_});exports.nonMaxSuppressionAsync=nonMaxSuppressionAsync_;exports.cropAndResize=cropAndResize_},{"../environment":51,"../kernels/non_max_suppression_impl":72,"../tensor_util_env":181,"../util":185,"./operation":147}],139:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var util_1=require("../util");var array_ops_1=require("./array_ops");var concat_split_1=require("./concat_split");var norm_1=require("./norm");var operation_1=require("./operation");var reduction_ops_1=require("./reduction_ops");var tensor_ops_1=require("./tensor_ops");function gramSchmidt_(xs){var inputIsTensor2D;if(Array.isArray(xs)){inputIsTensor2D=false;util_1.assert(xs!=null&&xs.length>0,"Gram-Schmidt process: input must not be null, undefined, or empty");var dim=xs[0].shape[0];for(var i=1;i<xs.length;++i){util_1.assert(xs[i].shape[0]===dim,"Gram-Schmidt: Non-unique lengths found in the input vectors: "+("("+xs[i].shape[0]+" vs. "+dim+")"))}}else{inputIsTensor2D=true;xs=concat_split_1.split(xs,xs.shape[0],0).map(function(x){return array_ops_1.squeeze(x,[0])})}util_1.assert(xs.length<=xs[0].shape[0],"Gram-Schmidt: Number of vectors ("+xs.length+") exceeds "+("number of dimensions ("+xs[0].shape[0]+")."));var ys=[];var xs1d=xs;var _loop_1=function(i){ys.push(environment_1.ENV.engine.tidy(function(){var x=xs1d[i];if(i>0){for(var j=0;j<i;++j){var proj=reduction_ops_1.sum(ys[j].mulStrict(x)).mul(ys[j]);x=x.sub(proj)}}return x.div(norm_1.norm(x,"euclidean"))}))};for(var i=0;i<xs.length;++i){_loop_1(i)}if(inputIsTensor2D){return array_ops_1.stack(ys,0)}else{return ys}}function qr_(x,fullMatrices){if(fullMatrices===void 0){fullMatrices=false}if(x.rank<2){throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+x.rank)}else if(x.rank===2){return qr2d(x,fullMatrices)}else{var outerDimsProd=x.shape.slice(0,x.shape.length-2).reduce(function(value,prev){return value*prev});var x2ds=array_ops_1.unstack(x.reshape([outerDimsProd,x.shape[x.shape.length-2],x.shape[x.shape.length-1]]),0);var q2ds_1=[];var r2ds_1=[];x2ds.forEach(function(x2d){var _a=qr2d(x2d,fullMatrices),q2d=_a[0],r2d=_a[1];q2ds_1.push(q2d);r2ds_1.push(r2d)});var q=array_ops_1.stack(q2ds_1,0).reshape(x.shape);var r=array_ops_1.stack(r2ds_1,0).reshape(x.shape);return[q,r]}}function qr2d(x,fullMatrices){if(fullMatrices===void 0){fullMatrices=false}return environment_1.ENV.engine.tidy(function(){if(x.shape.length!==2){throw new Error("qr2d() requires a 2D Tensor, but got a "+x.shape.length+"D Tensor.")}var m=x.shape[0];var n=x.shape[1];var q=array_ops_1.eye(m);var r=x.clone();var one2D=tensor_ops_1.tensor2d([[1]],[1,1]);var w=one2D.clone();var iters=m>=n?n:m;var _loop_2=function(j){var _a;var rTemp=r;var wTemp=w;var qTemp=q;_a=environment_1.ENV.engine.tidy(function(){var rjEnd1=r.slice([j,j],[m-j,1]);var normX=rjEnd1.norm();var rjj=r.slice([j,j],[1,1]);var s=rjj.sign().neg();var u1=rjj.sub(s.mul(normX));var wPre=rjEnd1.div(u1);if(wPre.shape[0]===1){w=one2D.clone()}else{w=one2D.concat(wPre.slice([1,0],[wPre.shape[0]-1,wPre.shape[1]]),0)}var tau=s.matMul(u1).div(normX).neg();var rjEndAll=r.slice([j,0],[m-j,n]);var tauTimesW=tau.mul(w);if(j===0){r=rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)))}else{r=r.slice([0,0],[j,n]).concat(rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll))),0)}var qAllJEnd=q.slice([0,j],[m,q.shape[1]-j]);if(j===0){q=qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()))}else{q=q.slice([0,0],[m,j]).concat(qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose())),1)}return[w,r,q]}),w=_a[0],r=_a[1],q=_a[2];globals_1.dispose([rTemp,wTemp,qTemp])};for(var j=0;j<iters;++j){_loop_2(j)}if(!fullMatrices&&m>n){q=q.slice([0,0],[m,n]);r=r.slice([0,0],[n,n])}return[q,r]})}exports.gramSchmidt=operation_1.op({gramSchmidt_:gramSchmidt_});exports.qr=operation_1.op({qr_:qr_})},{"../environment":51,"../globals":53,"../util":185,"./array_ops":125,"./concat_split":133,"./norm":146,"./operation":147,"./reduction_ops":152,"./tensor_ops":162}],140:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var where_impl_1=require("../kernels/where_impl");var tensor_util_env_1=require("../tensor_util_env");var util_1=require("../util");var broadcast_util_1=require("./broadcast_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function logicalNot_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","logicalNot","bool");util_1.assert($x.dtype==="bool","Error Array must be of type bool.");return environment_1.ENV.engine.runKernel(function(backend){return backend.logicalNot($x)},{$x:$x})}function logicalAnd_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","logicalAnd","bool");var $b=tensor_util_env_1.convertToTensor(b,"b","logicalAnd","bool");util_1.assert($a.dtype==="bool"&&$b.dtype==="bool","Error Array must be of type bool.");broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.logicalAnd($a,$b)},{$a:$a,$b:$b})}function logicalOr_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","logicalOr","bool");var $b=tensor_util_env_1.convertToTensor(b,"b","logicalOr","bool");util_1.assert($a.dtype==="bool"&&$b.dtype==="bool","Error Array must be of type bool.");broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return environment_1.ENV.engine.runKernel(function(backend){return backend.logicalOr($a,$b)},{$a:$a,$b:$b})}function logicalXor_(a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","logicalXor","bool");var $b=tensor_util_env_1.convertToTensor(b,"b","logicalXor","bool");util_1.assert($a.dtype==="bool"&&$b.dtype==="bool","Error Array must be of type bool.");broadcast_util_1.assertAndGetBroadcastShape($a.shape,$b.shape);return exports.logicalOr(a,b).logicalAnd(exports.logicalAnd(a,b).logicalNot())}function where_(condition,a,b){var $a=tensor_util_env_1.convertToTensor(a,"a","where");var $b=tensor_util_env_1.convertToTensor(b,"b","where");var $condition=tensor_util_env_1.convertToTensor(condition,"condition","where","bool");util_1.assert($condition.dtype==="bool","Error Condition must be of type bool.");util_1.assertShapesMatch($a.shape,$b.shape,"Error in where: ");if($condition.rank===1){util_1.assert($condition.shape[0]===$a.shape[0],"The first dimension of `a` must match the size of `condition`.")}else{util_1.assertShapesMatch($condition.shape,$b.shape,"Error in where: ")}var grad=function(dy){return{$condition:function(){return tensor_ops_1.zerosLike($condition)},$a:function(){return dy.mul($condition.cast($a.dtype))},$b:function(){return dy.mul($condition.logicalNot().cast($b.dtype))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.select($condition,$a,$b)},{$condition:$condition,$a:$a,$b:$b},grad)}function whereAsync_(condition){return __awaiter(this,void 0,void 0,function(){var $condition,vals,res;return __generator(this,function(_a){switch(_a.label){case 0:$condition=tensor_util_env_1.convertToTensor(condition,"condition","where","bool");util_1.assert($condition.dtype==="bool","Condition must be of type bool.");return[4,$condition.data()];case 1:vals=_a.sent();res=where_impl_1.whereImpl($condition.shape,vals);if(condition!==$condition){$condition.dispose()}return[2,res]}})})}exports.logicalAnd=operation_1.op({logicalAnd_:logicalAnd_});exports.logicalNot=operation_1.op({logicalNot_:logicalNot_});exports.logicalOr=operation_1.op({logicalOr_:logicalOr_});exports.logicalXor=operation_1.op({logicalXor_:logicalXor_});exports.where=operation_1.op({where_:where_});exports.whereAsync=whereAsync_},{"../environment":51,"../kernels/where_impl":123,"../tensor_util_env":181,"../util":185,"./broadcast_util":130,"./operation":147,"./tensor_ops":162}],141:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var globals_1=require("../globals");var tensor_util_env_1=require("../tensor_util_env");var util_1=require("../util");var axis_util_1=require("./axis_util");var binary_ops_1=require("./binary_ops");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");var Reduction;(function(Reduction){Reduction[Reduction["NONE"]=0]="NONE";Reduction[Reduction["MEAN"]=1]="MEAN";Reduction[Reduction["SUM"]=2]="SUM";Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"]=3]="SUM_BY_NONZERO_WEIGHTS"})(Reduction=exports.Reduction||(exports.Reduction={}));function computeWeightedLoss_(losses,weights,reduction){if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $losses=tensor_util_env_1.convertToTensor(losses,"losses","computeWeightedLoss");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","computeWeightedLoss")}var weightedLoss=$weights==null?$losses:$losses.mul($weights);if(reduction===Reduction.NONE){return weightedLoss}if(reduction===Reduction.SUM){return weightedLoss.sum()}if(reduction===Reduction.MEAN){if($weights==null){return weightedLoss.mean()}else{var broadcastFactor=util_1.sizeFromShape($losses.shape)/util_1.sizeFromShape($weights.shape);var result=weightedLoss.sum().div($weights.sum());return broadcastFactor>1?result.div(tensor_ops_1.scalar(broadcastFactor)):result}}if(reduction===Reduction.SUM_BY_NONZERO_WEIGHTS){if($weights==null){return weightedLoss.sum().div(tensor_ops_1.scalar($losses.size))}else{var broadcastedWeights=$weights.mul(tensor_ops_1.ones($losses.shape));var numNonZeros=broadcastedWeights.notEqual(tensor_ops_1.scalar(0)).sum().toFloat();return weightedLoss.sum().div(numNonZeros)}}throw Error("Unknown reduction: "+reduction)}function absoluteDifference_(labels,predictions,weights,reduction){if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $labels=tensor_util_env_1.convertToTensor(labels,"labels","absoluteDifference");var $predictions=tensor_util_env_1.convertToTensor(predictions,"predictions","absoluteDifference");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","absoluteDifference")}util_1.assertShapesMatch($labels.shape,$predictions.shape,"Error in absoluteDifference: ");var losses=$labels.sub($predictions).abs();return exports.computeWeightedLoss(losses,$weights,reduction)}function meanSquaredError_(labels,predictions,weights,reduction){if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $labels=tensor_util_env_1.convertToTensor(labels,"labels","meanSquaredError");var $predictions=tensor_util_env_1.convertToTensor(predictions,"predictions","meanSquaredError");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","meanSquaredError")}util_1.assertShapesMatch($labels.shape,$predictions.shape,"Error in meanSquaredError: ");var losses=$labels.squaredDifference($predictions);return exports.computeWeightedLoss(losses,$weights,reduction)}function cosineDistance_(labels,predictions,axis,weights,reduction){if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $labels=tensor_util_env_1.convertToTensor(labels,"labels","cosineDistance");var $predictions=tensor_util_env_1.convertToTensor(predictions,"predictions","cosineDistance");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","cosineDistance")}util_1.assertShapesMatch($labels.shape,$predictions.shape,"Error in cosineDistance: ");var one=tensor_ops_1.scalar(1);var losses=one.sub($labels.mul($predictions).sum(axis,true));return exports.computeWeightedLoss(losses,$weights,reduction)}function hingeLoss_(labels,predictions,weights,reduction){if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $labels=tensor_util_env_1.convertToTensor(labels,"labels","hingeLoss");var $predictions=tensor_util_env_1.convertToTensor(predictions,"predictions","hingeLoss");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","hingeLoss")}util_1.assertShapesMatch($labels.shape,$predictions.shape,"Error in hingeLoss: ");var one=tensor_ops_1.scalar(1);$labels=tensor_ops_1.scalar(2).mul($labels).sub(one);var losses=one.sub($labels.mul($predictions)).relu();return exports.computeWeightedLoss(losses,$weights,reduction)}function logLoss_(labels,predictions,weights,epsilon,reduction){if(epsilon===void 0){epsilon=1e-7}if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $labels=tensor_util_env_1.convertToTensor(labels,"labels","logLoss");var $predictions=tensor_util_env_1.convertToTensor(predictions,"predictions","logLoss");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","logLoss")}util_1.assertShapesMatch($labels.shape,$predictions.shape,"Error in logLoss: ");var one=tensor_ops_1.scalar(1);var epsilonScalar=tensor_ops_1.scalar(epsilon);var losses=$labels.mul($predictions.add(epsilonScalar).log()).neg().sub(one.sub($labels).mul(one.sub($predictions).add(epsilonScalar).log()));return exports.computeWeightedLoss(losses,$weights,reduction)}function sigmoidCrossEntropyWithLogits_(labels,logits){var $labels=tensor_util_env_1.convertToTensor(labels,"labels","sigmoidCrossEntropyWithLogits");var $logits=tensor_util_env_1.convertToTensor(logits,"logits","sigmoidCrossEntropyWithLogits");util_1.assertShapesMatch($labels.shape,$logits.shape,"Error in sigmoidCrossEntropyWithLogits: ");var maxOutput=$logits.relu();var outputXTarget=$logits.mul($labels);var sigmoidOutput=$logits.abs().neg().exp().log1p();return maxOutput.sub(outputXTarget).add(sigmoidOutput)}function sigmoidCrossEntropy_(multiClassLabels,logits,weights,labelSmoothing,reduction){if(labelSmoothing===void 0){labelSmoothing=0}if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $multiClassLabels=tensor_util_env_1.convertToTensor(multiClassLabels,"multiClassLabels","sigmoidCrossEntropy");var $logits=tensor_util_env_1.convertToTensor(logits,"logits","sigmoidCrossEntropy");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","sigmoidCrossEntropy")}util_1.assertShapesMatch($multiClassLabels.shape,$logits.shape,"Error in sigmoidCrossEntropy: ");if(labelSmoothing>0){var labelSmoothingScalar=tensor_ops_1.scalar(labelSmoothing);var one=tensor_ops_1.scalar(1);var half=tensor_ops_1.scalar(.5);$multiClassLabels=$multiClassLabels.mul(one.sub(labelSmoothingScalar)).add(half.mul(labelSmoothingScalar))}var losses=sigmoidCrossEntropyWithLogits_($multiClassLabels,$logits);return exports.computeWeightedLoss(losses,$weights,reduction)}function huberLoss_(labels,predictions,weights,delta,reduction){if(delta===void 0){delta=1}if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $labels=tensor_util_env_1.convertToTensor(labels,"labels","huberLoss");var $predictions=tensor_util_env_1.convertToTensor(predictions,"predictions","huberLoss");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","huberLoss")}util_1.assertShapesMatch($labels.shape,$predictions.shape,"Error in huberLoss: ");var deltaScalar=tensor_ops_1.scalar(delta);var error=$predictions.sub($labels).abs();var quadratic=binary_ops_1.minimum(error,deltaScalar);var linear=error.sub(quadratic);var losses=tensor_ops_1.scalar(.5).mul(quadratic.square()).add(deltaScalar.mul(linear));return exports.computeWeightedLoss(losses,$weights,reduction)}function softmaxCrossEntropyWithLogits_(labels,logits,dim){if(dim===void 0){dim=-1}if(dim===-1){dim=logits.rank-1}if(dim!==logits.rank-1){throw Error("Softmax cross entropy along a non-last dimension is not yet "+("supported. Labels / logits was rank "+logits.rank+" ")+("and dim was "+dim))}var customOp=globals_1.customGrad(function(labels,logits){var keepDims=true;var lse=logits.logSumExp([dim],keepDims);var logResult=logits.toFloat().sub(lse);var costVector=logResult.mul(labels).neg();var value=costVector.sum([dim]);var gradFunc=function(dy){var dyShape=axis_util_1.expandShapeToKeepDim(dy.shape,[dim]);return[dy.reshape(dyShape).mul(labels.toFloat().sub(logResult.exp())),dy.reshape(dyShape).mul(logResult.exp().sub(labels.toFloat()))]};return{value:value,gradFunc:gradFunc}});return customOp(labels,logits)}function softmaxCrossEntropy_(onehotLabels,logits,weights,labelSmoothing,reduction){if(labelSmoothing===void 0){labelSmoothing=0}if(reduction===void 0){reduction=Reduction.SUM_BY_NONZERO_WEIGHTS}var $onehotLabels=tensor_util_env_1.convertToTensor(onehotLabels,"onehotLabels","softmaxCrossEntropy");var $logits=tensor_util_env_1.convertToTensor(logits,"logits","softmaxCrossEntropy");var $weights=null;if(weights!=null){$weights=tensor_util_env_1.convertToTensor(weights,"weights","softmaxCrossEntropy")}util_1.assertShapesMatch($onehotLabels.shape,$logits.shape,"Error in softmaxCrossEntropy: ");if(labelSmoothing>0){var labelSmoothingScalar=tensor_ops_1.scalar(labelSmoothing);var one=tensor_ops_1.scalar(1);var numClasses=tensor_ops_1.scalar($onehotLabels.shape[1]);$onehotLabels=$onehotLabels.mul(one.sub(labelSmoothingScalar)).add(labelSmoothingScalar.div(numClasses))}var losses=softmaxCrossEntropyWithLogits_($onehotLabels,$logits);return exports.computeWeightedLoss(losses,$weights,reduction)}exports.absoluteDifference=operation_1.op({absoluteDifference_:absoluteDifference_});exports.computeWeightedLoss=operation_1.op({computeWeightedLoss_:computeWeightedLoss_});exports.cosineDistance=operation_1.op({cosineDistance_:cosineDistance_});exports.hingeLoss=operation_1.op({hingeLoss_:hingeLoss_});exports.huberLoss=operation_1.op({huberLoss_:huberLoss_});exports.logLoss=operation_1.op({logLoss_:logLoss_});exports.meanSquaredError=operation_1.op({meanSquaredError_:meanSquaredError_});exports.sigmoidCrossEntropy=operation_1.op({sigmoidCrossEntropy_:sigmoidCrossEntropy_});exports.softmaxCrossEntropy=operation_1.op({softmaxCrossEntropy_:softmaxCrossEntropy_})},{"../globals":53,"../tensor_util_env":181,"../util":185,"./axis_util":127,"./binary_ops":129,"./operation":147,"./tensor_ops":162}],142:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var operation_1=require("./operation");function localResponseNormalization_(x,depthRadius,bias,alpha,beta){if(depthRadius===void 0){depthRadius=5}if(bias===void 0){bias=1}if(alpha===void 0){alpha=1}if(beta===void 0){beta=.5}var $x=tensor_util_env_1.convertToTensor(x,"x","localResponseNormalization");util.assert($x.rank===4||$x.rank===3,"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+$x.rank+".");util.assert(util.isInt(depthRadius),"Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius "+depthRadius+".");var x4D=$x;var reshapedTo4D=false;if($x.rank===3){reshapedTo4D=true;x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}var backward=function(dy,saved){var outputImage=saved[0];return{x4D:function(){return environment_1.ENV.engine.runKernel(function(backend){return backend.LRNGrad(dy,x4D,outputImage,depthRadius,bias,alpha,beta)},{})}}};var res=environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.localResponseNormalization4D(x4D,depthRadius,bias,alpha,beta))},{x4D:x4D},backward);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}else{return res}}exports.localResponseNormalization=operation_1.op({localResponseNormalization_:localResponseNormalization_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./operation":147}],143:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_util_env_1=require("../tensor_util_env");var operation_1=require("./operation");function multiRNNCell_(lstmCells,data,c,h){var $data=tensor_util_env_1.convertToTensor(data,"data","multiRNNCell");var $c=tensor_util_env_1.convertToTensorArray(c,"c","multiRNNCell");var $h=tensor_util_env_1.convertToTensorArray(h,"h","multiRNNCell");var input=$data;var newStates=[];for(var i=0;i<lstmCells.length;i++){var output=lstmCells[i](input,$c[i],$h[i]);newStates.push(output[0]);newStates.push(output[1]);input=output[1]}var newC=[];var newH=[];for(var i=0;i<newStates.length;i+=2){newC.push(newStates[i]);newH.push(newStates[i+1])}return[newC,newH]}function basicLSTMCell_(forgetBias,lstmKernel,lstmBias,data,c,h){var $forgetBias=tensor_util_env_1.convertToTensor(forgetBias,"forgetBias","basicLSTMCell");var $lstmKernel=tensor_util_env_1.convertToTensor(lstmKernel,"lstmKernel","basicLSTMCell");var $lstmBias=tensor_util_env_1.convertToTensor(lstmBias,"lstmBias","basicLSTMCell");var $data=tensor_util_env_1.convertToTensor(data,"data","basicLSTMCell");var $c=tensor_util_env_1.convertToTensor(c,"c","basicLSTMCell");var $h=tensor_util_env_1.convertToTensor(h,"h","basicLSTMCell");var combined=$data.concat($h,1);var weighted=combined.matMul($lstmKernel);var res=weighted.add($lstmBias);var batchSize=res.shape[0];var sliceCols=res.shape[1]/4;var sliceSize=[batchSize,sliceCols];var i=res.slice([0,0],sliceSize);var j=res.slice([0,sliceCols],sliceSize);var f=res.slice([0,sliceCols*2],sliceSize);var o=res.slice([0,sliceCols*3],sliceSize);var newC=i.sigmoid().mulStrict(j.tanh()).addStrict($c.mulStrict($forgetBias.add(f).sigmoid()));var newH=newC.tanh().mulStrict(o.sigmoid());return[newC,newH]}exports.basicLSTMCell=operation_1.op({basicLSTMCell_:basicLSTMCell_});exports.multiRNNCell=operation_1.op({multiRNNCell_:multiRNNCell_})},{"../tensor_util_env":181,"./operation":147}],144:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var operation_1=require("./operation");function matMul_(a,b,transposeA,transposeB){if(transposeA===void 0){transposeA=false}if(transposeB===void 0){transposeB=false}var $a=tensor_util_env_1.convertToTensor(a,"a","matMul");var $b=tensor_util_env_1.convertToTensor(b,"b","matMul");var innerShapeA=transposeA?$a.shape[$a.rank-2]:$a.shape[$a.rank-1];var innerShapeB=transposeB?$b.shape[$b.rank-1]:$b.shape[$b.rank-2];var outerShapeA=transposeA?$a.shape[$a.rank-1]:$a.shape[$a.rank-2];var outerShapeB=transposeB?$b.shape[$b.rank-2]:$b.shape[$b.rank-1];var outerDimsA=$a.shape.slice(0,-2);var outerDimsB=$b.shape.slice(0,-2);var batchDimA=util.sizeFromShape(outerDimsA);var batchDimB=util.sizeFromShape(outerDimsB);util.assert($a.rank>=2&&$b.rank>=2&&$a.rank===$b.rank,"Error in matMul: inputs must have the same rank of at least 2, "+("got ranks "+$a.rank+" and "+$b.rank+"."));util.assert(util.arraysEqual(outerDimsA,outerDimsB),"Error in matMul: outer dimensions ("+outerDimsA+") and ("+(outerDimsB+") of Tensors with shapes "+$a.shape+" and ")+($b.shape+" must match."));util.assert(innerShapeA===innerShapeB,"Error in matMul: inner shapes ("+innerShapeA+") and ("+(innerShapeB+") of Tensors with shapes "+$a.shape+" and ")+($b.shape+" and transposeA="+transposeA)+(" and transposeB="+transposeB+" must match."));var outShape=$a.shape.slice(0,-2).concat([outerShapeA,outerShapeB]);var a3D=transposeA?$a.as3D(batchDimA,innerShapeA,outerShapeA):$a.as3D(batchDimA,outerShapeA,innerShapeA);var b3D=transposeB?$b.as3D(batchDimB,outerShapeB,innerShapeB):$b.as3D(batchDimB,innerShapeB,outerShapeB);var grad=function(dy){if(!transposeA&&!transposeB){return{$a:function(){return dy.matMul(b3D.toFloat(),false,true)},$b:function(){return a3D.toFloat().matMul(dy,true,false)}}}else if(!transposeA&&transposeB){return{$a:function(){return dy.matMul(b3D.toFloat(),false,false)},$b:function(){return dy.matMul(a3D.toFloat(),true,false)}}}else if(transposeA&&!transposeB){return{$a:function(){return b3D.toFloat().matMul(dy,false,true)},$b:function(){return a3D.toFloat().matMul(dy,false,false)}}}else{return{$a:function(){return b3D.toFloat().matMul(dy,true,true)},$b:function(){return dy.matMul(a3D.toFloat(),true,true)}}}};var res=environment_1.ENV.engine.runKernel(function(backend){return backend.batchMatMul(a3D,b3D,transposeA,transposeB)},{$a:a3D,$b:b3D},grad);return res.reshape(outShape)}function outerProduct_(v1,v2){var $v1=tensor_util_env_1.convertToTensor(v1,"v1","outerProduct");var $v2=tensor_util_env_1.convertToTensor(v2,"v2","outerProduct");util.assert($v1.rank===1&&$v2.rank===1,"Error in outerProduct: inputs must be rank 1, but got ranks "+($v1.rank+" and "+$v2.rank+"."));return $v1.as2D(-1,1).matMul($v2.as2D(1,-1))}function dot_(t1,t2){var $t1=tensor_util_env_1.convertToTensor(t1,"t1","dot");var $t2=tensor_util_env_1.convertToTensor(t2,"t2","dot");util.assert(($t1.rank===1||$t1.rank===2)&&($t2.rank===1||$t2.rank===2),"Error in dot: inputs must all be rank 1 or 2, but got ranks "+($t1.rank+" and "+$t2.rank+"."));var t1Inner=$t1.rank===1?$t1.size:$t1.shape[1];var t2Inner=$t2.rank===1?$t2.size:$t2.shape[0];util.assert(t1Inner===t2Inner,"Error in dot: inner dimensions of inputs must match, but got "+(t1Inner+" and "+t2Inner+"."));if($t1.rank===1&&$t2.rank===1){return $t1.as2D(1,-1).matMul($t2.as2D(-1,1)).asScalar()}else if($t1.rank===1&&$t2.rank===2){return $t1.as2D(1,-1).matMul($t2.as2D($t2.shape[0],$t2.shape[1])).as1D()}else if($t1.rank===2&&$t2.rank===1){return $t1.matMul($t2.as2D(-1,1)).as1D()}else{return $t1.matMul($t2.as2D($t2.shape[0],$t2.shape[1]))}}exports.matMul=operation_1.op({matMul_:matMul_});exports.dot=operation_1.op({dot_:dot_});exports.outerProduct=operation_1.op({outerProduct_:outerProduct_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./operation":147}],145:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_util_1=require("../tensor_util");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var binary_ops_1=require("./binary_ops");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function movingAverage_(v,x,decay,step,zeroDebias){if(zeroDebias===void 0){zeroDebias=true}var $v=tensor_util_env_1.convertToTensor(v,"v","movingAverage");var $x=tensor_util_env_1.convertToTensor(x,"x","movingAverage");var $decay=tensor_util_env_1.convertToTensor(decay,"decay","movingAverage");tensor_util_1.assertTypesMatch($v,$x);util.assert(util.arraysEqual($v.shape,$x.shape),"Shape mismatch in v and x");var one=tensor_ops_1.scalar(1);var oneMinusDecay=one.sub($decay);var update=$x.sub($v).mul(oneMinusDecay);if(zeroDebias){util.assert(step!=null,"When using zeroDebias: true, step is required.");var $step=tensor_util_env_1.convertToTensor(step,"step","movingAverage");update=update.div(one.sub(binary_ops_1.pow($decay,$step)))}return $v.add(update)}exports.movingAverage=operation_1.op({movingAverage_:movingAverage_})},{"../tensor_util":180,"../tensor_util_env":181,"../util":185,"./binary_ops":129,"./operation":147,"./tensor_ops":162}],146:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_util_env_1=require("../tensor_util_env");var axis_util=require("./axis_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function norm_(x,ord,axis,keepDims){if(ord===void 0){ord="euclidean"}if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}x=tensor_util_env_1.convertToTensor(x,"x","norm");var norm=normImpl(x,ord,axis);var keepDimsShape=norm.shape;if(keepDims){var axes=axis_util.parseAxisParam(axis,x.shape);keepDimsShape=axis_util.expandShapeToKeepDim(norm.shape,axes)}return norm.reshape(keepDimsShape)}function normImpl(x,p,axis){if(axis===void 0){axis=null}if(x.rank===0){return x.abs()}if(x.rank!==1&&axis===null){return normImpl(x.reshape([-1]),p,axis)}if(x.rank===1||typeof axis==="number"||axis instanceof Array&&axis.length===1){if(p===1){return x.abs().sum(axis)}if(p===Infinity){return x.abs().max(axis)}if(p===-Infinity){return x.abs().min(axis)}if(p==="euclidean"||p===2){return x.abs().pow(tensor_ops_1.scalar(2,"int32")).sum(axis).sqrt()}throw new Error("Error in norm: invalid ord value: "+p)}if(axis instanceof Array&&axis.length===2){if(p===1){return x.abs().sum(axis[0]).max(axis[1]-1)}if(p===Infinity){return x.abs().sum(axis[1]).max(axis[0])}if(p===-Infinity){return x.abs().sum(axis[1]).min(axis[0])}if(p==="fro"||p==="euclidean"){return x.square().sum(axis).sqrt()}throw new Error("Error in norm: invalid ord value: "+p)}throw new Error("Error in norm: invalid axis: "+axis)}exports.norm=operation_1.op({norm_:norm_})},{"../tensor_util_env":181,"./axis_util":127,"./operation":147,"./tensor_ops":162}],147:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");function op(f){var keys=Object.keys(f);if(keys.length!==1){throw new Error("Please provide an object with a single key "+"(operation name) mapping to a function. Got an object with "+(keys.length+" keys."))}var opName=keys[0];var fn=f[opName];if(opName.endsWith("_")){opName=opName.substring(0,opName.length-1)}var f2=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i]}environment_1.ENV.engine.startScope(opName);try{var result=fn.apply(void 0,args);if(result instanceof Promise){console.error("Cannot return a Promise inside of tidy.")}environment_1.ENV.engine.endScope(result);return result}catch(ex){environment_1.ENV.engine.endScope(null);throw ex}};Object.defineProperty(f2,"name",{value:opName,configurable:true});return f2}exports.op=op},{"../environment":51}],148:[function(require,module,exports){"use strict";function __export(m){for(var p in m)if(!exports.hasOwnProperty(p))exports[p]=m[p]}Object.defineProperty(exports,"__esModule",{value:true});__export(require("./batchnorm"));__export(require("./complex_ops"));__export(require("./concat_split"));__export(require("./conv"));__export(require("./matmul"));__export(require("./reverse"));__export(require("./pool"));__export(require("./slice"));__export(require("./unary_ops"));__export(require("./reduction_ops"));__export(require("./compare"));__export(require("./binary_ops"));__export(require("./relu_ops"));__export(require("./logical_ops"));__export(require("./array_ops"));__export(require("./tensor_ops"));__export(require("./transpose"));__export(require("./softmax"));__export(require("./lrn"));__export(require("./norm"));__export(require("./segment_ops"));__export(require("./lstm"));__export(require("./moving_average"));__export(require("./strided_slice"));__export(require("./topk"));var operation_1=require("./operation");exports.op=operation_1.op;var losses=require("./loss_ops");exports.losses=losses;var linalg=require("./linalg_ops");exports.linalg=linalg;var image=require("./image_ops");exports.image=image},{"./array_ops":125,"./batchnorm":128,"./binary_ops":129,"./compare":131,"./complex_ops":132,"./concat_split":133,"./conv":135,"./image_ops":138,"./linalg_ops":139,"./logical_ops":140,"./loss_ops":141,"./lrn":142,"./lstm":143,"./matmul":144,"./moving_average":145,"./norm":146,"./operation":147,"./pool":149,"./reduction_ops":152,"./relu_ops":153,"./reverse":154,"./segment_ops":155,"./slice":158,"./softmax":160,"./strided_slice":161,"./tensor_ops":162,"./topk":163,"./transpose":164,"./unary_ops":165}],149:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var conv_util=require("./conv_util");var operation_1=require("./operation");function maxPool_(x,filterSize,strides,pad,dimRoundingMode){var $x=tensor_util_env_1.convertToTensor(x,"x","maxPool");var x4D=$x;var reshapedTo4D=false;if($x.rank===3){reshapedTo4D=true;x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}util.assert(x4D.rank===4,"Error in maxPool: input must be rank 4 but got rank "+x4D.rank+".");if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in maxPool: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}var convInfo=conv_util.computePool2DInfo(x4D.shape,filterSize,strides,pad,dimRoundingMode);var grad=function(dy,saved){var y4D=saved[0];return{x:function(){return maxPoolBackprop(dy,x4D,y4D,filterSize,strides,pad)}}};var res=environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.maxPool(x4D,convInfo))},{x:x4D},grad);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function avgPool_(x,filterSize,strides,pad,dimRoundingMode){var $x=tensor_util_env_1.convertToTensor(x,"x","avgPool");util.assert($x.dtype==="float32","The input dtype to avgPool must be float32");var x4D=$x;var reshapedTo4D=false;if($x.rank===3){reshapedTo4D=true;x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])}util.assert(x4D.rank===4,"Error in avgPool: x must be rank 4 but got rank "+x4D.rank+".");if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in avgPool: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}var convInfo=conv_util.computePool2DInfo(x4D.shape,filterSize,strides,pad);var grad=function(dy){return{x:function(){return avgPoolBackprop(dy,x4D,filterSize,strides,pad)}}};var res=environment_1.ENV.engine.runKernel(function(backend){return backend.avgPool(x4D,convInfo)},{x:x4D},grad);res=res.cast($x.dtype);if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}function maxPoolBackprop(dy,input,output,filterSize,strides,pad,dimRoundingMode){var $dy=tensor_util_env_1.convertToTensor(dy,"dy","maxPoolBackprop");var $input=tensor_util_env_1.convertToTensor(input,"input","maxPoolBackprop");var $output=tensor_util_env_1.convertToTensor(output,"output","maxPoolBackprop");util.assert($input.rank===$dy.rank,"Rank of input ("+$input.rank+") does not match rank of dy ("+$dy.rank+")");util.assert($dy.rank===4,"Error in maxPoolBackprop: dy must be rank 4 but got rank "+($dy.rank+"."));util.assert($input.rank===4,"Error in maxPoolBackprop: input must be rank 4 but got rank "+($input.rank+"."));if(dimRoundingMode!=null){util.assert(util.isInt(pad),"Error in maxPoolBackprop: pad must be an integer when using, "+("dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."))}var convInfo=conv_util.computePool2DInfo($input.shape,filterSize,strides,pad,dimRoundingMode);var res=environment_1.ENV.engine.runKernel(function(backend){return backend.maxPoolBackprop($dy,$input,$output,convInfo)},{$dy:$dy,$input:$input});return res}function avgPoolBackprop(dy,input,filterSize,strides,pad){var $dy=tensor_util_env_1.convertToTensor(dy,"dy","avgPoolBackprop");var $input=tensor_util_env_1.convertToTensor(input,"input","avgPoolBackprop");util.assert($input.rank===$dy.rank,"Rank of input ("+$input.rank+") does not match rank of dy ("+$dy.rank+")");var input4D=$input;var dy4D=$dy;var reshapedTo4D=false;if($input.rank===3){reshapedTo4D=true;input4D=$input.as4D(1,$input.shape[0],$input.shape[1],$input.shape[2]);dy4D=$dy.as4D(1,$dy.shape[0],$dy.shape[1],$dy.shape[2])}util.assert(dy4D.rank===4,"Error in avgPoolBackprop: dy must be rank 4 but got rank "+(dy4D.rank+"."));util.assert(input4D.rank===4,"Error in avgPoolBackprop: input must be rank 4 but got rank "+(input4D.rank+"."));var convInfo=conv_util.computePool2DInfo(input4D.shape,filterSize,strides,pad);var res=environment_1.ENV.engine.runKernel(function(backend){return backend.avgPoolBackprop(dy4D,input4D,convInfo)},{dy4D:dy4D,input4D:input4D});if(reshapedTo4D){return res.as3D(res.shape[1],res.shape[2],res.shape[3])}return res}exports.maxPool=operation_1.op({maxPool_:maxPool_});exports.avgPool=operation_1.op({avgPool_:avgPool_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./conv_util":136,"./operation":147}],150:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var seedrandom=require("seedrandom");var MPRandGauss=function(){function MPRandGauss(mean,stdDeviation,dtype,truncated,seed){this.mean=mean;this.stdDev=stdDeviation;this.dtype=dtype;this.nextVal=NaN;this.truncated=truncated;if(this.truncated){this.upper=this.mean+this.stdDev*2;this.lower=this.mean-this.stdDev*2}var seedValue=seed?seed:Math.random();this.random=seedrandom.alea(seedValue.toString())}MPRandGauss.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var value=this.nextVal;this.nextVal=NaN;return value}var resultX,resultY;var isValid=false;while(!isValid){var v1=void 0,v2=void 0,s=void 0;do{v1=2*this.random()-1;v2=2*this.random()-1;s=v1*v1+v2*v2}while(s>=1||s===0);var mul=Math.sqrt(-2*Math.log(s)/s);resultX=this.mean+this.stdDev*v1*mul;resultY=this.mean+this.stdDev*v2*mul;if(!this.truncated||this.isValidTruncated(resultX)){isValid=true}}if(!this.truncated||this.isValidTruncated(resultY)){this.nextVal=this.convertValue(resultY)}return this.convertValue(resultX)};MPRandGauss.prototype.convertValue=function(value){if(this.dtype==null||this.dtype==="float32"){return value}return Math.round(value)};MPRandGauss.prototype.isValidTruncated=function(value){return value<=this.upper&&value>=this.lower};return MPRandGauss}();exports.MPRandGauss=MPRandGauss},{seedrandom:256}],151:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util_1=require("../util");exports.PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(inSize){if(inSize<=exports.PARALLELIZE_THRESHOLD){return inSize}return util_1.nearestDivisor(inSize,Math.floor(Math.sqrt(inSize)))}exports.computeOptimalWindowSize=computeOptimalWindowSize},{"../util":185}],152:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var axis_util=require("./axis_util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function logSumExp_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","logSumExp");var axes=axis_util.parseAxisParam(axis,$x.shape);var xMax=$x.max(axes,true);var a=$x.sub(xMax);var b=a.exp();var c=b.sum(axes);var d=c.log();var res=xMax.reshape(d.shape).add(d);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,axes);return res.reshape(newShape)}return res}function sum_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","sum");if($x.dtype==="bool"){$x=$x.toInt()}var axes=axis_util.parseAxisParam(axis,$x.shape);var customOp=globals_1.customGrad(function(x){var permutation=axis_util.getAxesPermutation(axes,x.rank);var reductionAxes=axes;var permutedX=x;if(permutation!=null){permutedX=x.transpose(permutation);reductionAxes=axis_util.getInnerMostAxes(reductionAxes.length,x.rank)}var value=environment_1.ENV.engine.runKernel(function(backend){return backend.sum(permutedX,reductionAxes)},{permutedX:permutedX});if(keepDims){var newShape=axis_util.expandShapeToKeepDim(value.shape,axes);value=value.reshape(newShape)}var gradFunc=function(dy){var expandedDyShape=x.shape.slice();axes.forEach(function(axis){expandedDyShape[axis]=1});var expandedDy=dy.reshape(expandedDyShape);var derX=expandedDy.mul(tensor_ops_1.ones(x.shape,"float32"));return derX};return{value:value,gradFunc:gradFunc}});return customOp($x)}function mean_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","mean");var axes=axis_util.parseAxisParam(axis,$x.shape);var shapes=axis_util.computeOutAndReduceShapes($x.shape,axes);var reduceShape=shapes[1];var reduceSize=util.sizeFromShape(reduceShape);var customOp=globals_1.customGrad(function(x){var reduceSizeScalar=tensor_ops_1.scalar(reduceSize);var xReduce=reduceSizeScalar.dtype===x.dtype?x:x.cast(reduceSizeScalar.dtype);var res=xReduce.div(reduceSizeScalar);var value=res.sum(axis,keepDims);var gradFunc=function(dy){var expandedDyShape=x.shape.slice();axes.forEach(function(axis){expandedDyShape[axis]=1});var expandedDy=dy.reshape(expandedDyShape);var derX=expandedDy.mul(tensor_ops_1.ones(x.shape,"float32")).div(reduceSizeScalar);return derX};return{value:value,gradFunc:gradFunc}});return customOp($x)}function gradForMinAndMax(dy,saved,xOrig,origAxes,permutedAxes){var y=saved[0];if(y.rank<xOrig.rank){y=y.reshape(axis_util.expandShapeToKeepDim(y.shape,origAxes))}if(dy.rank<xOrig.rank){dy=dy.reshape(axis_util.expandShapeToKeepDim(dy.shape,origAxes))}return{$x:function(){var dx=dy.mul(xOrig.equal(y).cast(dy.dtype));return permutedAxes==null?dx:dx.transpose(permutedAxes)}}}function min_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","min");var xOrig=$x;var origAxes=axis_util.parseAxisParam(axis,$x.shape);var axes=origAxes;var permutedAxes=axis_util.getAxesPermutation(axes,$x.rank);if(permutedAxes!=null){$x=$x.transpose(permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,$x.rank)}var grad=function(dy,saved){return gradForMinAndMax(dy,saved,xOrig,origAxes,permutedAxes)};var res=environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.min($x,axes))},{$x:$x},grad);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,origAxes);res=res.reshape(newShape)}return res}function max_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","max");var xOrig=$x;var origAxes=axis_util.parseAxisParam(axis,$x.shape);var axes=origAxes;var permutedAxes=axis_util.getAxesPermutation(axes,$x.rank);if(permutedAxes!=null){$x=$x.transpose(permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,$x.rank)}var grad=function(dy,saved){return gradForMinAndMax(dy,saved,xOrig,origAxes,permutedAxes)};var res=environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.max($x,axes))},{$x:$x},grad);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,origAxes);res=res.reshape(newShape)}return res}function argMin_(x,axis){if(axis===void 0){axis=0}var $x=tensor_util_env_1.convertToTensor(x,"x","argMin");if(axis==null){axis=0}var axes=axis_util.parseAxisParam(axis,$x.shape);var permutedAxes=axis_util.getAxesPermutation(axes,$x.rank);if(permutedAxes!=null){$x=$x.transpose(permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,$x.rank)}var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike($x)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.argMin($x,axes[0])},{$x:$x},grad)}function argMax_(x,axis){if(axis===void 0){axis=0}var $x=tensor_util_env_1.convertToTensor(x,"x","argMax");if(axis==null){axis=0}var axes=axis_util.parseAxisParam(axis,$x.shape);var permutedAxes=axis_util.getAxesPermutation(axes,$x.rank);if(permutedAxes!=null){$x=$x.transpose(permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,$x.rank)}var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike($x)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.argMax($x,axes[0])},{$x:$x},grad)}function all_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","all","bool");util.assert($x.dtype==="bool","Error Tensor must be of type bool. Got: "+$x.dtype);var origAxes=axis_util.parseAxisParam(axis,$x.shape);var axes=origAxes;var permutedAxes=axis_util.getAxesPermutation(axes,$x.rank);if(permutedAxes!=null){$x=$x.transpose(permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,$x.rank)}var res=environment_1.ENV.engine.runKernel(function(backend){return backend.all($x,axes)},{$x:$x});if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,origAxes);return res.reshape(newShape)}return res}function any_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}var $x=tensor_util_env_1.convertToTensor(x,"x","any","bool");util.assert($x.dtype==="bool","Error Tensor must be of type bool. Got: "+$x.dtype);var origAxes=axis_util.parseAxisParam(axis,$x.shape);var axes=origAxes;var permutedAxes=axis_util.getAxesPermutation(axes,$x.rank);if(permutedAxes!=null){$x=$x.transpose(permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,$x.rank)}var res=environment_1.ENV.engine.runKernel(function(backend){return backend.any($x,axes)},{$x:$x});if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,origAxes);return res.reshape(newShape)}return res}function moments_(x,axis,keepDims){if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}x=tensor_util_env_1.convertToTensor(x,"x","moments");var axes=axis_util.parseAxisParam(axis,x.shape);var mean=x.mean(axes,keepDims);var keepDimsShape=mean.shape;if(!keepDims){keepDimsShape=axis_util.expandShapeToKeepDim(mean.shape,axes)}var devSquared=x.toFloat().sub(mean.reshape(keepDimsShape)).square();var variance=devSquared.mean(axes,keepDims);return{mean:mean,variance:variance}}exports.all=operation_1.op({all_:all_});exports.any=operation_1.op({any_:any_});exports.argMax=operation_1.op({argMax_:argMax_});exports.argMin=operation_1.op({argMin_:argMin_});exports.logSumExp=operation_1.op({logSumExp_:logSumExp_});exports.max=operation_1.op({max_:max_});exports.mean=operation_1.op({mean_:mean_});exports.min=operation_1.op({min_:min_});exports.moments=operation_1.op({moments_:moments_});exports.sum=operation_1.op({sum_:sum_})},{"../environment":51,"../globals":53,"../tensor_util_env":181,"../util":185,"./axis_util":127,"./operation":147,"./tensor_ops":162}],153:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var binary_ops_1=require("./binary_ops");var logical_ops_1=require("./logical_ops");var operation_1=require("./operation");var selu_util_1=require("./selu_util");var tensor_ops_1=require("./tensor_ops");function relu_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","relu");if($x.dtype==="bool"){return $x.toInt()}var grad=function(dy){var stepRes=$x.step();return{$x:function(){return dy.mulStrict(stepRes.toFloat())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.relu($x)},{$x:$x},grad)}function elu_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","elu");var grad=function(dy,saved){var y=saved[0];return{$x:function(){return environment_1.ENV.engine.runKernel(function(backend){return backend.eluDer(dy,y)},{dy:dy,y:y})}}};return environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.elu($x))},{$x:$x},grad)}function selu_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","selu");var grad=function(dy){return{$x:function(){var mask=$x.greater(tensor_ops_1.scalar(0));var scaleAlpha=tensor_ops_1.scalar(selu_util_1.SELU_SCALEALPHA);var scale=tensor_ops_1.scalar(selu_util_1.SELU_SCALE);var greaterThanZeroDer=dy.mul(scale);var lessEqualZeroDer=dy.mul(scaleAlpha).mul($x.toFloat().exp());return logical_ops_1.where(mask,greaterThanZeroDer,lessEqualZeroDer)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.selu($x)},{$x:$x},grad)}function leakyRelu_(x,alpha){if(alpha===void 0){alpha=.2}var $x=tensor_util_env_1.convertToTensor(x,"x","leakyRelu");return binary_ops_1.maximum(tensor_ops_1.scalar(alpha).mul($x),$x)}function prelu_(x,alpha){var $x=tensor_util_env_1.convertToTensor(x,"x","prelu");var $alpha=tensor_util_env_1.convertToTensor(alpha,"alpha","prelu");var zero=tensor_ops_1.scalar(0);return binary_ops_1.maximum(zero,$x).add($alpha.mul(binary_ops_1.minimum(zero,$x)))}exports.elu=operation_1.op({elu_:elu_});exports.leakyRelu=operation_1.op({leakyRelu_:leakyRelu_});exports.prelu=operation_1.op({prelu_:prelu_});exports.relu=operation_1.op({relu_:relu_});exports.selu=operation_1.op({selu_:selu_})},{"../environment":51,"../tensor_util_env":181,"./binary_ops":129,"./logical_ops":140,"./operation":147,"./selu_util":157,"./tensor_ops":162}],154:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var axis_util_1=require("./axis_util");var operation_1=require("./operation");function reverse1d_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","reverse");util.assert($x.rank===1,"Error in reverse1D: x must be rank 1 but got\n             rank "+$x.rank+".");return exports.reverse($x,0)}function reverse2d_(x,axis){var $x=tensor_util_env_1.convertToTensor(x,"x","reverse");util.assert($x.rank===2,"Error in reverse2D: x must be rank 2 but got\n             rank "+$x.rank+".");return exports.reverse($x,axis)}function reverse3d_(x,axis){var $x=tensor_util_env_1.convertToTensor(x,"x","reverse");util.assert($x.rank===3,"Error in reverse3D: x must be rank 3 but got\n             rank "+$x.rank+".");return exports.reverse($x,axis)}function reverse4d_(x,axis){var $x=tensor_util_env_1.convertToTensor(x,"x","reverse");util.assert($x.rank===4,"Error in reverse4D: x must be rank 4 but got\n             rank "+$x.rank+".");return exports.reverse($x,axis)}function reverse_(x,axis){var $x=tensor_util_env_1.convertToTensor(x,"x","reverse");if($x.rank===0){return $x.clone()}var axes=axis_util_1.parseAxisParam(axis,$x.shape);var grad=function(dy){return{$x:function(){return dy.reverse(axes)}}};var res=environment_1.ENV.engine.runKernel(function(backend){return backend.reverse($x,axes)},{$x:$x},grad);return res.reshapeAs($x)}exports.reverse=operation_1.op({reverse_:reverse_});exports.reverse1d=operation_1.op({reverse1d_:reverse1d_});exports.reverse2d=operation_1.op({reverse2d_:reverse2d_});exports.reverse3d=operation_1.op({reverse3d_:reverse3d_});exports.reverse4d=operation_1.op({reverse4d_:reverse4d_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./axis_util":127,"./operation":147}],155:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util_1=require("../util");var array_ops_1=require("./array_ops");var axis_util_1=require("./axis_util");var binary_ops_1=require("./binary_ops");var compare_1=require("./compare");var logical_ops_1=require("./logical_ops");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function unsortedSegmentSum_(x,segmentIds,numSegments){var $x=tensor_util_env_1.convertToTensor(x,"x","unsortedSegmentSum");var $segmentIds=tensor_util_env_1.convertToTensor(segmentIds,"segmentIds","unsortedSegmentSum","int32");util_1.assert($segmentIds.dtype==="int32","segmentIds must be of dtype `int32`");util_1.assert(util_1.isInt(numSegments),"numSegments must be of dtype int");var gradFunc=function(dy){var derX=function(){return gatherDropNegatives(dy,$segmentIds)};return{$x:derX}};return environment_1.ENV.engine.runKernel(function(backend){return backend.unsortedSegmentSum($x,$segmentIds,numSegments)},{$x:$x},gradFunc)}function gather_(x,indices,axis){if(axis===void 0){axis=0}var $x=tensor_util_env_1.convertToTensor(x,"x","gather");var $indices=tensor_util_env_1.convertToTensor(indices,"indices","gather","int32");util_1.assert($indices.dtype==="int32","Indices must be of dtype `int32`");axis=axis_util_1.parseAxisParam(axis,$x.shape)[0];var grad=function(dy){var derX=function(){if(axis===0){return exports.unsortedSegmentSum(dy,$indices,$x.shape[axis])}var paramsShape=$x.shape;var indicesSize=$indices.size;var outerShape=paramsShape.slice(0,axis);var outerDims=outerShape.length;var innerShape=paramsShape.slice(axis,paramsShape.length).slice(1);var innerDims=innerShape.length;var outerAxesIndices=arrayRange(0,outerDims);var innerAxesIndices=arrayRange(outerDims+1,outerDims+1+innerDims);var valuesShape=arrayConcat([outerShape,[indicesSize],innerShape]);var values=dy.reshape(valuesShape);var reshapedIndices=$indices.reshape([indicesSize]);var transposeDims=arrayConcat([[outerDims],outerAxesIndices,innerAxesIndices]);var valuesTranspose=values.transpose(transposeDims);var paramsGrad=exports.unsortedSegmentSum(valuesTranspose,reshapedIndices,$x.shape[axis]);var invertTransposeDims=axis_util_1.getUndoAxesPermutation(transposeDims);paramsGrad=paramsGrad.transpose(invertTransposeDims);return paramsGrad};return{$x:derX}};return environment_1.ENV.engine.runKernel(function(backend){return backend.gather($x,$indices,axis)},{$x:$x},grad)}function arrayRange(start,stop){var result=[];for(var i=start;i<stop;++i){result.push(i)}return result}function arrayConcat(arrays){var result=[];for(var i=0;i<arrays.length;++i){for(var j=0;j<arrays[i].length;++j){result.push(arrays[i][j])}}return result}function gatherDropNegatives(x,indices){var zeroClippedIndices=binary_ops_1.maximum(indices,tensor_ops_1.zerosLike(indices));var gathered=exports.gather(x,zeroClippedIndices);var isPositive=compare_1.greaterEqual(indices,tensor_ops_1.scalar(0,"int32"));var numIters=gathered.rank-isPositive.rank;for(var i=0;i<numIters;++i){isPositive=array_ops_1.expandDims(isPositive,i+1)}isPositive=logical_ops_1.logicalAnd(isPositive,tensor_ops_1.ones(gathered.shape,"bool"));var zeroSlice=tensor_ops_1.zerosLike(gathered);return logical_ops_1.where(isPositive,gathered,zeroSlice)}exports.gather=operation_1.op({gather_:gather_});exports.unsortedSegmentSum=operation_1.op({unsortedSegmentSum_:unsortedSegmentSum_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./array_ops":125,"./axis_util":127,"./binary_ops":129,"./compare":131,"./logical_ops":140,"./operation":147,"./tensor_ops":162}],156:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util_1=require("../util");var reduce_util_1=require("./reduce_util");function segOpComputeOptimalWindowSize(inSize,numSegments){var done=false;var res;if(inSize<=reduce_util_1.PARALLELIZE_THRESHOLD){res=inSize;done=true}else{res=util_1.nearestDivisor(inSize,Math.floor(Math.sqrt(inSize)))}while(!done){if(res>numSegments||res===inSize){done=true;break}else{res=util_1.nearestDivisor(inSize,res+1)}}return res}exports.segOpComputeOptimalWindowSize=segOpComputeOptimalWindowSize;function computeOutShape(aShape,axis,numSegments){var outShape=[];var rank=aShape.length;for(var dim=0;dim<rank;dim++){if(dim!==axis){outShape.push(aShape[dim])}else{outShape.push(numSegments)}}return outShape}exports.computeOutShape=computeOutShape},{"../util":185,"./reduce_util":151}],157:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SELU_SCALEALPHA=1.7580993408473768;exports.SELU_SCALE=1.0507009873554805},{}],158:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var operation_1=require("./operation");var slice_util=require("./slice_util");function slice1d_(x,begin,size){var $x=tensor_util_env_1.convertToTensor(x,"x","slice1d");util.assert($x.rank===1,"slice1d expects a rank-1 tensor, but got a rank-"+$x.rank+" tensor");return exports.slice($x,[begin],[size])}function slice2d_(x,begin,size){var $x=tensor_util_env_1.convertToTensor(x,"x","slice2d");util.assert($x.rank===2,"slice1d expects a rank-2 tensor, but got a rank-"+$x.rank+" tensor");return exports.slice($x,begin,size)}function slice3d_(x,begin,size){var $x=tensor_util_env_1.convertToTensor(x,"x","slice3d");util.assert($x.rank===3,"slice1d expects a rank-3 tensor, but got a rank-"+$x.rank+" tensor");return exports.slice($x,begin,size)}function slice4d_(x,begin,size){var $x=tensor_util_env_1.convertToTensor(x,"x","slice4d");util.assert($x.rank===4,"slice1d expects a rank-4 tensor, but got a rank-"+$x.rank+" tensor");return exports.slice($x,begin,size)}function slice_(x,begin,size){var $x=tensor_util_env_1.convertToTensor(x,"x","slice");if($x.rank===0){throw new Error("Slicing scalar is not possible")}var begin_;if(typeof begin==="number"){begin_=[begin].concat(new Array($x.rank-1).fill(0))}else if(begin.length<$x.rank){begin_=begin.concat(new Array($x.rank-begin.length).fill(0))}else{begin_=begin.slice()}var size_;if(size==null){size_=new Array($x.rank).fill(-1)}else if(typeof size==="number"){size_=[size].concat(new Array($x.rank-1).fill(-1))}else if(size.length<$x.rank){size_=size.concat(new Array($x.rank-size.length).fill(-1))}else{size_=size}size_=size_.map(function(d,i){if(d>=0){return d}else{util.assert(d===-1,"Bad value in size");return $x.shape[i]-begin_[i]}});slice_util.assertParamsValid($x,begin_,size_);var inputShape=$x.shape;var grad=function(dy){var paddings=[];for(var i=0;i<dy.rank;i++){paddings.push([begin_[i],inputShape[i]-begin_[i]-size_[i]])}return{$x:function(){return dy.pad(paddings)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.slice($x,begin_,size_)},{$x:$x},grad)}exports.slice=operation_1.op({slice_:slice_});exports.slice1d=operation_1.op({slice1d_:slice1d_});exports.slice2d=operation_1.op({slice2d_:slice2d_});exports.slice3d=operation_1.op({slice3d_:slice3d_});exports.slice4d=operation_1.op({slice4d_:slice4d_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./operation":147,"./slice_util":159}],159:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function assertParamsValid(input,begin,size){util.assert(input.rank===begin.length,"Error in slice"+input.rank+"D: Length of begin "+begin+" must "+("match the rank of the array ("+input.rank+")."));util.assert(input.rank===size.length,"Error in slice"+input.rank+"D: Length of size "+size+" must "+("match the rank of the array ("+input.rank+")."));for(var i=0;i<input.rank;++i){util.assert(begin[i]+size[i]<=input.shape[i],"Error in slice"+input.rank+"D: begin["+i+"] + size["+i+"] "+("("+(begin[i]+size[i])+") would overflow input.shape["+i+"] ("+input.shape[i]+")"))}}exports.assertParamsValid=assertParamsValid;function getStridedSlicedInfo(shape,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){if(beginMask===void 0){beginMask=0}if(endMask===void 0){endMask=0}if(ellipsisMask===void 0){ellipsisMask=0}if(newAxisMask===void 0){newAxisMask=0}if(shrinkAxisMask===void 0){shrinkAxisMask=0}if(ellipsisMask!==0){throw new Error("ellipsis mask is not yet supported")}if(newAxisMask!==0){throw new Error("new axis mask is not yet supported")}var startIndex=[];var endIndex=[];var shrinkAxis=[];for(var i=0;i<shape.length;i++){startIndex[i]=startForAxis(beginMask,begin,strides,shape,i);endIndex[i]=stopForAxis(endMask,end,strides,shape,i);if(shrinkAxisMask&1<<i){endIndex[i]=startIndex[i]+1;shrinkAxis.push(i)}}var size=new Array(shape.length).fill(0);size=size.map(function(d,i){var count=0;for(var start=startIndex[i];!(strides[i]>0?start>=endIndex[i]:start<=endIndex[i]);start+=strides[i]){count+=1}return count});return[startIndex,size,shrinkAxis]}exports.getStridedSlicedInfo=getStridedSlicedInfo;function startForAxis(beginMask,startIndices,strides,inputShape,axis){var start=startIndices[axis];if(beginMask&1<<axis){if(strides[axis]>0){start=Number.MIN_SAFE_INTEGER}else{start=Number.MAX_SAFE_INTEGER}}var axisSize=inputShape[axis];if(start<0){start+=axisSize}start=util.clamp(0,start,axisSize-1);return start}exports.startForAxis=startForAxis;function stopForAxis(endMask,stopIndices,strides,inputShape,axis){var stop=stopIndices[axis];if(endMask&1<<axis){if(strides[axis]>0){stop=Number.MAX_SAFE_INTEGER}else{stop=Number.MIN_SAFE_INTEGER}}var axisSize=inputShape[axis];if(stop<0){stop+=axisSize}if(strides[axis]>0){stop=util.clamp(0,stop,axisSize)}else{stop=util.clamp(-1,stop,axisSize-1)}return stop}exports.stopForAxis=stopForAxis},{"../util":185}],160:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var gradients_1=require("../gradients");var tensor_util_env_1=require("../tensor_util_env");var operation_1=require("./operation");function softmax_(logits,dim){if(dim===void 0){dim=-1}var $logits=tensor_util_env_1.convertToTensor(logits,"logits","softmax");if(dim===-1){dim=$logits.rank-1}if(dim!==$logits.rank-1){throw Error("Softmax along a non-last dimension is not yet supported. "+("Logits was rank "+$logits.rank+" and dim was "+dim))}var customOp=gradients_1.customGrad(function(logits){var keepDims=true;var lse=logits.logSumExp([dim],keepDims);var logResult=logits.toFloat().sub(lse);var y=logResult.exp();var gradFunc=function(dy){var dyTimesY=dy.mul(y);var keepDims=true;return dyTimesY.sub(dyTimesY.sum([dim],keepDims).mul(y))};return{value:y,gradFunc:gradFunc}});return customOp($logits)}exports.softmax=operation_1.op({softmax_:softmax_})},{"../gradients":54,"../tensor_util_env":181,"./operation":147}],161:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var operation_1=require("./operation");function stridedSlice_(x,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){if(beginMask===void 0){beginMask=0}if(endMask===void 0){endMask=0}if(ellipsisMask===void 0){ellipsisMask=0}if(newAxisMask===void 0){newAxisMask=0}if(shrinkAxisMask===void 0){shrinkAxisMask=0}if(ellipsisMask!==0){throw new Error("ellipsis mask is not yet supported")}if(newAxisMask!==0){throw new Error("new axis mask is not yet supported")}var $x=tensor_util_env_1.convertToTensor(x,"x","stridedSlice");return environment_1.ENV.engine.runKernel(function(backend){return backend.stridedSlice($x,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask)},{$x:$x})}exports.stridedSlice=operation_1.op({stridedSlice_:stridedSlice_})},{"../environment":51,"../tensor_util_env":181,"./operation":147}],162:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_1=require("../tensor");var tensor_util_env_1=require("../tensor_util_env");var util_1=require("../util");var complex_ops_1=require("./complex_ops");var operation_1=require("./operation");function tensor(values,shape,dtype){if(dtype===void 0){dtype="float32"}if(dtype==="complex64"){throw new Error("Cannot construct a complex64 tensor directly. "+"Please use tf.complex(real, imag).")}if(!util_1.isTypedArray(values)&&!Array.isArray(values)&&typeof values!=="number"&&typeof values!=="boolean"){throw new Error("values passed to tensor(values) must be an "+"array of numbers or booleans, or a TypedArray")}var inferredShape=util_1.inferShape(values);if(shape!=null&&inferredShape.length!==1){util_1.assertShapesMatch(shape,inferredShape,"Error creating a new Tensor. "+("Inferred shape ("+inferredShape+") does not match the ")+("provided shape ("+shape+"). "))}if(!util_1.isTypedArray(values)&&!Array.isArray(values)){values=[values]}shape=shape||inferredShape;return tensor_1.Tensor.make(shape,{values:util_1.toTypedArray(values,dtype,environment_1.ENV.get("DEBUG"))},dtype)}exports.tensor=tensor;function scalar(value,dtype){if(dtype===void 0){dtype="float32"}if((util_1.isTypedArray(value)||Array.isArray(value))&&dtype!=="complex64"){throw new Error("Error creating a new Scalar: value must be a primitive "+"(number|boolean)")}return tensor(value,[],dtype)}exports.scalar=scalar;function tensor1d(values,dtype){if(dtype===void 0){dtype="float32"}util_1.assertNonNull(values);var inferredShape=util_1.inferShape(values);if(inferredShape.length!==1){throw new Error("tensor1d() requires values to be a flat/TypedArray")}return tensor(values,inferredShape,dtype)}exports.tensor1d=tensor1d;function tensor2d(values,shape,dtype){if(dtype===void 0){dtype="float32"}util_1.assertNonNull(values);if(shape!=null&&shape.length!==2){throw new Error("tensor2d() requires shape to have two numbers")}var inferredShape=util_1.inferShape(values);if(inferredShape.length!==2&&inferredShape.length!==1){throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")}if(inferredShape.length===1&&shape==null){throw new Error("tensor2d() requires shape to be provided when `values` "+"are a flat/TypedArray")}shape=shape||inferredShape;return tensor(values,shape,dtype)}exports.tensor2d=tensor2d;function tensor3d(values,shape,dtype){if(dtype===void 0){dtype="float32"}util_1.assertNonNull(values);if(shape!=null&&shape.length!==3){throw new Error("tensor3d() requires shape to have three numbers")}var inferredShape=util_1.inferShape(values);if(inferredShape.length!==3&&inferredShape.length!==1){throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray")}if(inferredShape.length===1&&shape==null){throw new Error("tensor3d() requires shape to be provided when `values` "+"are a flat array")}shape=shape||inferredShape;return tensor(values,shape,dtype)}exports.tensor3d=tensor3d;function tensor4d(values,shape,dtype){if(dtype===void 0){dtype="float32"}util_1.assertNonNull(values);if(shape!=null&&shape.length!==4){throw new Error("tensor4d() requires shape to have four numbers")}var inferredShape=util_1.inferShape(values);if(inferredShape.length!==4&&inferredShape.length!==1){throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray")}if(inferredShape.length===1&&shape==null){throw new Error("tensor4d() requires shape to be provided when `values` "+"are a flat array")}shape=shape||inferredShape;return tensor(values,shape,dtype)}exports.tensor4d=tensor4d;function tensor5d(values,shape,dtype){if(dtype===void 0){dtype="float32"}util_1.assertNonNull(values);if(shape!=null&&shape.length!==5){throw new Error("tensor5d() requires shape to have five numbers")}var inferredShape=util_1.inferShape(values);if(inferredShape.length!==5&&inferredShape.length!==1){throw new Error("tensor5d() requires values to be "+"number[][][][][] or flat/TypedArray")}if(inferredShape.length===1&&shape==null){throw new Error("tensor5d() requires shape to be provided when `values` "+"are a flat array")}shape=shape||inferredShape;return tensor(values,shape,dtype)}exports.tensor5d=tensor5d;function tensor6d(values,shape,dtype){if(dtype===void 0){dtype="float32"}util_1.assertNonNull(values);if(shape!=null&&shape.length!==6){throw new Error("tensor6d() requires shape to have six numbers")}var inferredShape=util_1.inferShape(values);if(inferredShape.length!==6&&inferredShape.length!==1){throw new Error("tensor6d() requires values to be number[][][][] or flat/TypedArray")}if(inferredShape.length===1&&shape==null){throw new Error("tensor6d() requires shape to be provided when `values` "+"are a flat array")}shape=shape||inferredShape;return tensor(values,shape,dtype)}exports.tensor6d=tensor6d;function ones(shape,dtype){if(dtype===void 0){dtype="float32"}if(dtype==="complex64"){var real=ones(shape,"float32");var imag=ones(shape,"float32");return complex_ops_1.complex(real,imag)}var values=util_1.makeOnesTypedArray(util_1.sizeFromShape(shape),dtype);return tensor_1.Tensor.make(shape,{values:values},dtype)}exports.ones=ones;function zeros(shape,dtype){if(dtype===void 0){dtype="float32"}if(dtype==="complex64"){var real=zeros(shape,"float32");var imag=zeros(shape,"float32");return complex_ops_1.complex(real,imag)}var values=util_1.makeZerosTypedArray(util_1.sizeFromShape(shape),dtype);return tensor_1.Tensor.make(shape,{values:values},dtype)}exports.zeros=zeros;function fill(shape,value,dtype){if(dtype===void 0){dtype="float32"}var values=util_1.getTypedArrayFromDType(dtype,util_1.sizeFromShape(shape));values.fill(value);return tensor_1.Tensor.make(shape,{values:values},dtype)}exports.fill=fill;function onesLike_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","onesLike");return ones($x.shape,$x.dtype)}function zerosLike_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","zerosLike");return zeros($x.shape,$x.dtype)}function linspace(start,stop,num){if(num===0){throw new Error("Cannot request zero samples")}var step=(stop-start)/(num-1);var values=util_1.makeZerosTypedArray(num,"float32");values[0]=start;for(var i=1;i<values.length;i++){values[i]=values[i-1]+step}return tensor1d(values,"float32")}exports.linspace=linspace;function range(start,stop,step,dtype){if(step===void 0){step=1}if(dtype===void 0){dtype="float32"}if(step===0){throw new Error("Cannot have a step of zero")}var sameStartStop=start===stop;var increasingRangeNegativeStep=start<stop&&step<0;var decreasingRangePositiveStep=stop<start&&step>1;if(sameStartStop||increasingRangeNegativeStep||decreasingRangePositiveStep){return zeros([0],dtype)}var numElements=Math.abs(Math.ceil((stop-start)/step));var values=util_1.makeZerosTypedArray(numElements,dtype);if(stop<start&&step===1){step=-1}values[0]=start;for(var i=1;i<values.length;i++){values[i]=values[i-1]+step}return tensor1d(values,dtype)}exports.range=range;exports.onesLike=operation_1.op({onesLike_:onesLike_});exports.zerosLike=operation_1.op({zerosLike_:zerosLike_})},{"../environment":51,"../tensor":178,"../tensor_util_env":181,"../util":185,"./complex_ops":132,"./operation":147}],163:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var operation_1=require("./operation");function topk_(x,k,sorted){if(k===void 0){k=1}if(sorted===void 0){sorted=true}var $x=tensor_util_env_1.convertToTensor(x,"x","topk");if($x.rank===0){throw new Error("topk() expects the input to be of rank 1 or higher")}var lastDim=$x.shape[$x.shape.length-1];if(k>lastDim){throw new Error("'k' passed to topk() must be <= the last dimension ("+lastDim+") "+("but got "+k))}var _a=environment_1.ENV.engine.runKernel(function(b){return b.topk($x,k,sorted)},{$x:$x}),values=_a[0],indices=_a[1];return{values:values,indices:indices}}exports.topk=operation_1.op({topk_:topk_})},{"../environment":51,"../tensor_util_env":181,"./operation":147}],164:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var axis_util=require("./axis_util");var operation_1=require("./operation");function transpose_(x,perm){var $x=tensor_util_env_1.convertToTensor(x,"x","transpose");if(perm==null){perm=$x.shape.map(function(s,i){return i}).reverse()}util.assert($x.rank===perm.length,"Error in transpose: rank of input "+$x.rank+" "+("must match length of perm "+perm+"."));perm.forEach(function(axis){util.assert(axis>=0&&axis<$x.rank,"All entries in 'perm' must be between 0 and "+($x.rank-1)+(" but got "+perm))});if($x.rank<=1){return $x.clone()}var der=function(dy){var undoPerm=axis_util.getUndoAxesPermutation(perm);return{$x:function(){return dy.transpose(undoPerm)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.transpose($x,perm)},{$x:$x},der)}exports.transpose=operation_1.op({transpose_:transpose_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./axis_util":127,"./operation":147}],165:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var tensor_util_env_1=require("../tensor_util_env");var util=require("../util");var operation_1=require("./operation");var tensor_ops_1=require("./tensor_ops");function neg_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","neg");var grad=function(dy){return{$x:function(){return dy.neg()}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.neg($x)},{$x:$x},grad)}function ceil_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","ceil");var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.ceil($x)},{$x:$x},grad)}function floor_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","floor");var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.floor($x)},{$x:$x},grad)}function sign_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","sign");var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.sign($x)},{$x:$x},grad)}function round_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","round");var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.round($x)},{$x:$x},grad)}function exp_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","exp");var bck=function(dy,saved){var y=saved[0];return{$x:function(){return dy.mulStrict(y)}}};return environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.exp($x))},{$x:$x},bck)}function expm1_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","expm1");var grad=function(dy){return{$x:function(){return dy.mulStrict($x.exp())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.expm1($x)},{$x:$x},grad)}function log_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","log");var grad=function(dy){return{$x:function(){return dy.divStrict($x.toFloat())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.log($x)},{$x:$x},grad)}function log1p_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","log1p");var grad=function(dy){return{$x:function(){return dy.divStrict($x.add(tensor_ops_1.scalar(1)))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.log1p($x)},{$x:$x},grad)}function sqrt_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","sqrt");var grad=function(dy){return{$x:function(){return dy.divStrict($x.toFloat().sqrt().mul(tensor_ops_1.scalar(2)))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.sqrt($x)},{$x:$x},grad)}function rsqrt_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","rsqrt");var grad=function(dy){return{$x:function(){return dy.divStrict($x.pow(tensor_ops_1.scalar(1.5)).mul(tensor_ops_1.scalar(2))).neg()}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.rsqrt($x)},{$x:$x},grad)}function square_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","square");var grad=function(dy){return{$x:function(){return dy.mulStrict($x.toFloat().mul(tensor_ops_1.scalar(2)))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.square($x)},{$x:$x},grad)}function reciprocal_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","reciprocal");var grad=function(dy){return{$x:function(){return dy.divStrict($x.square().neg())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.reciprocal($x)},{$x:$x},grad)}function abs_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","abs");var grad=function(dy){return{$x:function(){return dy.mulStrict($x.toFloat().step(-1))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.abs($x)},{$x:$x},grad)}function clipByValue_(x,clipValueMin,clipValueMax){var $x=tensor_util_env_1.convertToTensor(x,"x","clipByValue");util.assert(clipValueMin<=clipValueMax,"Error in clip: min ("+clipValueMin+") must be "+("less than or equal to max ("+clipValueMax+")."));var grad=function(dy){return{$x:function(){return dy.where($x.greaterEqual(tensor_ops_1.scalar(clipValueMin)).logicalAnd($x.lessEqual(tensor_ops_1.scalar(clipValueMax))),tensor_ops_1.zerosLike(dy))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.clip($x,clipValueMin,clipValueMax)},{$x:$x},grad)}function sigmoid_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","sigmoid");var grad=function(dy,saved){var y=saved[0];return{$x:function(){return dy.mulStrict(y.mul(tensor_ops_1.scalar(1).sub(y)))}}};return environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.sigmoid($x))},{$x:$x},grad)}function logSigmoid_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","logSigmoid");var grad=function(dy){return{$x:function(){return dy.mulStrict($x.neg().sigmoid())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.softplus($x.neg()).neg()},{$x:$x},grad)}function softplus_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","softplus");var grad=function(dy){return{$x:function(){return dy.mulStrict($x.sigmoid())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.softplus($x)},{$x:$x},grad)}function sin_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","sin");var grad=function(dy){return{$x:function(){return $x.toFloat().cos().mulStrict(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.sin($x)},{$x:$x},grad)}function cos_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","cos");var grad=function(dy){return{$x:function(){return $x.toFloat().sin().neg().mulStrict(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.cos($x)},{$x:$x},grad)}function tan_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","tan");var grad=function(dy){return{$x:function(){return dy.divStrict($x.cos().square())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.tan($x)},{$x:$x},grad)}function asin_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","asin");var grad=function(dy){return{$x:function(){return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()).sqrt())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.asin($x)},{$x:$x},grad)}function acos_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","acos");var grad=function(dy){return{$x:function(){return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()).sqrt()).neg()}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.acos($x)},{$x:$x},grad)}function atan_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","atan");var grad=function(dy){return{$x:function(){return dy.divStrict(tensor_ops_1.scalar(1).add($x.toFloat().square()))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.atan($x)},{$x:$x},grad)}function sinh_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","sinh");var grad=function(dy){return{$x:function(){return $x.toFloat().cosh().mulStrict(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.sinh($x)},{$x:$x},grad)}function cosh_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","cosh");var grad=function(dy){return{$x:function(){return $x.toFloat().sinh().mulStrict(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.cosh($x)},{$x:$x},grad)}function tanh_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","tanh");var grad=function(dy,saved){var y=saved[0];return{$x:function(){return tensor_ops_1.scalar(1).sub(y.square()).mulStrict(dy)}}};return environment_1.ENV.engine.runKernel(function(backend,save){return save(backend.tanh($x))},{$x:$x},grad)}function asinh_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","asinh");var grad=function(dy){return{$x:function(){return dy.divStrict(tensor_ops_1.scalar(1).add($x.toFloat().square()).sqrt())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.asinh($x)},{$x:$x},grad)}function acosh_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","acosh");var grad=function(dy){return{$x:function(){return dy.divStrict($x.toFloat().square().sub(tensor_ops_1.scalar(1)).sqrt())}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.acosh($x)},{$x:$x},grad)}function atanh_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","atanh");var grad=function(dy){return{$x:function(){return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.atanh($x)},{$x:$x},grad)}function erf_(x){var $x=tensor_util_env_1.convertToTensor(x,"x","erf");util.assert($x.dtype==="int32"||$x.dtype==="float32","Input dtype must be `int32` or `float32`.");if($x.dtype==="int32"){$x=$x.toFloat()}var grad=function(dy){return{$x:function(){return dy.mulStrict(tensor_ops_1.scalar(2/Math.sqrt(Math.PI)).mul($x.square().neg().exp()))}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.erf($x)},{$x:$x},grad)}function step_(x,alpha){if(alpha===void 0){alpha=0}var $x=tensor_util_env_1.convertToTensor(x,"x","step");var grad=function(dy){return{$x:function(){return tensor_ops_1.zerosLike(dy)}}};return environment_1.ENV.engine.runKernel(function(backend){return backend.step($x,alpha)},{$x:$x},grad)}exports.abs=operation_1.op({abs_:abs_});exports.acos=operation_1.op({acos_:acos_});exports.acosh=operation_1.op({acosh_:acosh_});exports.asin=operation_1.op({asin_:asin_});exports.asinh=operation_1.op({asinh_:asinh_});exports.atan=operation_1.op({atan_:atan_});exports.atanh=operation_1.op({atanh_:atanh_});exports.ceil=operation_1.op({ceil_:ceil_});exports.clipByValue=operation_1.op({clipByValue_:clipByValue_});exports.cos=operation_1.op({cos_:cos_});exports.cosh=operation_1.op({cosh_:cosh_});exports.erf=operation_1.op({erf_:erf_});exports.exp=operation_1.op({exp_:exp_});exports.expm1=operation_1.op({expm1_:expm1_});exports.floor=operation_1.op({floor_:floor_});exports.log=operation_1.op({log_:log_});exports.log1p=operation_1.op({log1p_:log1p_});exports.logSigmoid=operation_1.op({logSigmoid_:logSigmoid_});exports.neg=operation_1.op({neg_:neg_});exports.reciprocal=operation_1.op({reciprocal_:reciprocal_});exports.round=operation_1.op({round_:round_});exports.rsqrt=operation_1.op({rsqrt_:rsqrt_});exports.sigmoid=operation_1.op({sigmoid_:sigmoid_});exports.sign=operation_1.op({sign_:sign_});exports.sin=operation_1.op({sin_:sin_});exports.sinh=operation_1.op({sinh_:sinh_});exports.softplus=operation_1.op({softplus_:softplus_});exports.sqrt=operation_1.op({sqrt_:sqrt_});exports.square=operation_1.op({square_:square_});exports.step=operation_1.op({step_:step_});exports.tan=operation_1.op({tan_:tan_});exports.tanh=operation_1.op({tanh_:tanh_})},{"../environment":51,"../tensor_util_env":181,"../util":185,"./operation":147,"./tensor_ops":162}],166:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var optimizer_1=require("./optimizer");var AdadeltaOptimizer=function(_super){__extends(AdadeltaOptimizer,_super);function AdadeltaOptimizer(learningRate,rho,epsilon){if(epsilon===void 0){epsilon=null}var _this=_super.call(this)||this;_this.learningRate=learningRate;_this.rho=rho;_this.epsilon=epsilon;_this.accumulatedGrads={};_this.accumulatedUpdates={};_this.c=globals_1.keep(ops_1.scalar(-learningRate));_this.rhoScalar=globals_1.keep(ops_1.scalar(rho));_this.oneMinusRho=globals_1.keep(ops_1.scalar(1-rho));if(epsilon===null){epsilon=environment_1.ENV.get("EPSILON")}_this.epsilonScalar=globals_1.keep(ops_1.scalar(epsilon));return _this}AdadeltaOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;var _loop_1=function(variableName){var value=environment_1.ENV.engine.registeredVariables[variableName];if(this_1.accumulatedGrads[variableName]==null){var trainable_1=false;globals_1.tidy(function(){_this.accumulatedGrads[variableName]=ops_1.zerosLike(value).variable(trainable_1)})}if(this_1.accumulatedUpdates[variableName]==null){var trainable_2=false;globals_1.tidy(function(){_this.accumulatedUpdates[variableName]=ops_1.zerosLike(value).variable(trainable_2)})}var gradient=variableGradients[variableName];var accumulatedGrad=this_1.accumulatedGrads[variableName];var accumulatedUpdate=this_1.accumulatedUpdates[variableName];globals_1.tidy(function(){var newAccumulatedGrad=_this.rhoScalar.mul(accumulatedGrad).add(_this.oneMinusRho.mul(gradient.square()));var updates=accumulatedUpdate.add(_this.epsilonScalar).sqrt().div(accumulatedGrad.add(_this.epsilonScalar).sqrt()).mul(gradient);var newAccumulatedUpdate=_this.rhoScalar.mul(accumulatedUpdate).add(_this.oneMinusRho.mul(updates.square()));_this.accumulatedGrads[variableName].assign(newAccumulatedGrad);_this.accumulatedUpdates[variableName].assign(newAccumulatedUpdate);var newValue=_this.c.mul(updates).add(value);value.assign(newValue)})};var this_1=this;for(var variableName in variableGradients){_loop_1(variableName)}};AdadeltaOptimizer.prototype.dispose=function(){var _this=this;this.c.dispose();this.epsilonScalar.dispose();this.rhoScalar.dispose();this.oneMinusRho.dispose();if(this.accumulatedUpdates!=null){Object.keys(this.accumulatedUpdates).forEach(function(name){return _this.accumulatedUpdates[name].dispose()});Object.keys(this.accumulatedGrads).forEach(function(name){return _this.accumulatedGrads[name].dispose()})}};AdadeltaOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}};AdadeltaOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.rho,config.epsilon)};AdadeltaOptimizer.className="AdadeltaOptimizer";return AdadeltaOptimizer}(optimizer_1.Optimizer);exports.AdadeltaOptimizer=AdadeltaOptimizer;serialization_1.registerClass(AdadeltaOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./optimizer":171}],167:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var optimizer_1=require("./optimizer");var AdagradOptimizer=function(_super){__extends(AdagradOptimizer,_super);function AdagradOptimizer(learningRate,initialAccumulatorValue){if(initialAccumulatorValue===void 0){initialAccumulatorValue=.1}var _this=_super.call(this)||this;_this.learningRate=learningRate;_this.initialAccumulatorValue=initialAccumulatorValue;_this.accumulatedGrads={};_this.c=globals_1.keep(ops_1.scalar(-learningRate));_this.epsilon=globals_1.keep(ops_1.scalar(environment_1.ENV.get("EPSILON")));return _this}AdagradOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;var _loop_1=function(variableName){var value=environment_1.ENV.engine.registeredVariables[variableName];if(this_1.accumulatedGrads[variableName]==null){var trainable_1=false;globals_1.tidy(function(){_this.accumulatedGrads[variableName]=ops_1.fill(value.shape,_this.initialAccumulatorValue).variable(trainable_1)})}var gradient=variableGradients[variableName];var accumulatedGrad=this_1.accumulatedGrads[variableName];globals_1.tidy(function(){var newAccumulatedGrad=accumulatedGrad.add(gradient.square());_this.accumulatedGrads[variableName].assign(newAccumulatedGrad);var newValue=_this.c.mul(gradient.div(newAccumulatedGrad.add(_this.epsilon).sqrt())).add(value);value.assign(newValue)})};var this_1=this;for(var variableName in variableGradients){_loop_1(variableName)}};AdagradOptimizer.prototype.dispose=function(){var _this=this;this.epsilon.dispose();this.c.dispose();if(this.accumulatedGrads!=null){Object.keys(this.accumulatedGrads).forEach(function(name){return _this.accumulatedGrads[name].dispose()})}};AdagradOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}};AdagradOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.initialAccumulatorValue)};AdagradOptimizer.className="AdagradOptimizer";return AdagradOptimizer}(optimizer_1.Optimizer);exports.AdagradOptimizer=AdagradOptimizer;serialization_1.registerClass(AdagradOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./optimizer":171}],168:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var optimizer_1=require("./optimizer");var AdamOptimizer=function(_super){__extends(AdamOptimizer,_super);function AdamOptimizer(learningRate,beta1,beta2,epsilon){if(epsilon===void 0){epsilon=null}var _this=_super.call(this)||this;_this.learningRate=learningRate;_this.beta1=beta1;_this.beta2=beta2;_this.epsilon=epsilon;_this.accumulatedFirstMoment={};_this.accumulatedSecondMoment={};_this.c=globals_1.keep(ops_1.scalar(-learningRate));_this.beta1Scalar=globals_1.keep(ops_1.scalar(beta1));_this.beta2Scalar=globals_1.keep(ops_1.scalar(beta2));globals_1.tidy(function(){_this.accBeta1=ops_1.scalar(beta1).variable();_this.accBeta2=ops_1.scalar(beta2).variable()});_this.oneMinusBeta1=globals_1.keep(ops_1.scalar(1-beta1));_this.oneMinusBeta2=globals_1.keep(ops_1.scalar(1-beta2));_this.one=globals_1.keep(ops_1.scalar(1));if(epsilon===null){epsilon=environment_1.ENV.get("EPSILON")}_this.epsScalar=globals_1.keep(ops_1.scalar(epsilon));return _this}AdamOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;globals_1.tidy(function(){var oneMinusAccBeta1=_this.one.sub(_this.accBeta1);var oneMinusAccBeta2=_this.one.sub(_this.accBeta2);for(var variableName in variableGradients){var value=environment_1.ENV.engine.registeredVariables[variableName];if(_this.accumulatedFirstMoment[variableName]==null){var trainable=false;_this.accumulatedFirstMoment[variableName]=ops_1.zerosLike(value).variable(trainable)}if(_this.accumulatedSecondMoment[variableName]==null){var trainable=false;_this.accumulatedSecondMoment[variableName]=ops_1.zerosLike(value).variable(trainable)}var gradient=variableGradients[variableName];var firstMoment=_this.accumulatedFirstMoment[variableName];var secondMoment=_this.accumulatedSecondMoment[variableName];var newFirstMoment=_this.beta1Scalar.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));var newSecondMoment=_this.beta2Scalar.mul(secondMoment).add(_this.oneMinusBeta2.mul(gradient.square()));var biasCorrectedFirstMoment=newFirstMoment.div(oneMinusAccBeta1);var biasCorrectedSecondMoment=newSecondMoment.div(oneMinusAccBeta2);_this.accumulatedFirstMoment[variableName].assign(newFirstMoment);_this.accumulatedSecondMoment[variableName].assign(newSecondMoment);var newValue=_this.c.mul(biasCorrectedFirstMoment.div(_this.epsScalar.add(biasCorrectedSecondMoment.sqrt()))).add(value);value.assign(newValue)}_this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));_this.accBeta2.assign(_this.accBeta2.mul(_this.beta2Scalar))})};AdamOptimizer.prototype.dispose=function(){var _this=this;this.c.dispose();this.epsScalar.dispose();this.beta1Scalar.dispose();this.beta2Scalar.dispose();this.accBeta1.dispose();this.accBeta2.dispose();this.oneMinusBeta1.dispose();this.oneMinusBeta2.dispose();this.one.dispose();if(this.accumulatedFirstMoment!=null){Object.keys(this.accumulatedFirstMoment).forEach(function(name){return _this.accumulatedFirstMoment[name].dispose()})}if(this.accumulatedSecondMoment!=null){Object.keys(this.accumulatedSecondMoment).forEach(function(name){return _this.accumulatedSecondMoment[name].dispose()})}};AdamOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}};AdamOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.beta1,config.beta2,config.epsilon)};AdamOptimizer.className="AdamOptimizer";return AdamOptimizer}(optimizer_1.Optimizer);exports.AdamOptimizer=AdamOptimizer;serialization_1.registerClass(AdamOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./optimizer":171}],169:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var optimizer_1=require("./optimizer");var AdamaxOptimizer=function(_super){__extends(AdamaxOptimizer,_super);function AdamaxOptimizer(learningRate,beta1,beta2,epsilon,decay){if(epsilon===void 0){epsilon=null}if(decay===void 0){decay=0}var _this=_super.call(this)||this;_this.learningRate=learningRate;_this.beta1=beta1;_this.beta2=beta2;_this.epsilon=epsilon;_this.decay=decay;_this.accumulatedFirstMoment={};_this.accumulatedWeightedInfNorm={};_this.c=globals_1.keep(ops_1.scalar(-learningRate));_this.beta1Scalar=globals_1.keep(ops_1.scalar(beta1));_this.beta2Scalar=globals_1.keep(ops_1.scalar(beta2));_this.decayScalar=globals_1.keep(ops_1.scalar(decay));globals_1.tidy(function(){_this.iteration=ops_1.scalar(0).variable();_this.accBeta1=ops_1.scalar(beta1).variable()});_this.oneMinusBeta1=globals_1.keep(ops_1.scalar(1-beta1));_this.one=globals_1.keep(ops_1.scalar(1));if(epsilon===null){epsilon=environment_1.ENV.get("EPSILON")}_this.epsScalar=globals_1.keep(ops_1.scalar(epsilon));return _this}AdamaxOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;globals_1.tidy(function(){var oneMinusAccBeta1=_this.one.sub(_this.accBeta1);var lr=_this.c.div(_this.one.add(_this.decayScalar.mul(_this.iteration)));for(var variableName in variableGradients){var value=environment_1.ENV.engine.registeredVariables[variableName];if(_this.accumulatedFirstMoment[variableName]==null){var trainable=false;_this.accumulatedFirstMoment[variableName]=ops_1.zerosLike(value).variable(trainable)}if(_this.accumulatedWeightedInfNorm[variableName]==null){var trainable=false;_this.accumulatedWeightedInfNorm[variableName]=ops_1.zerosLike(value).variable(trainable)}var gradient=variableGradients[variableName];var firstMoment=_this.accumulatedFirstMoment[variableName];var weightedInfNorm=_this.accumulatedWeightedInfNorm[variableName];var newFirstMoment=_this.beta1Scalar.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));var ut0=_this.beta2Scalar.mul(weightedInfNorm);var ut1=gradient.abs();var newWeightedInfNorm=ut0.maximum(ut1);_this.accumulatedFirstMoment[variableName].assign(newFirstMoment);_this.accumulatedWeightedInfNorm[variableName].assign(newWeightedInfNorm);var newValue=lr.div(oneMinusAccBeta1).mul(newFirstMoment.div(_this.epsScalar.add(newWeightedInfNorm))).add(value);value.assign(newValue)}_this.iteration.assign(_this.iteration.add(_this.one));_this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar))})};AdamaxOptimizer.prototype.dispose=function(){var _this=this;this.c.dispose();this.epsScalar.dispose();this.accBeta1.dispose();this.beta1Scalar.dispose();this.beta2Scalar.dispose();this.oneMinusBeta1.dispose();this.decayScalar.dispose();this.iteration.dispose();this.one.dispose();if(this.accumulatedFirstMoment!=null){Object.keys(this.accumulatedFirstMoment).forEach(function(name){return _this.accumulatedFirstMoment[name].dispose()})}if(this.accumulatedWeightedInfNorm!=null){Object.keys(this.accumulatedWeightedInfNorm).forEach(function(name){return _this.accumulatedWeightedInfNorm[name].dispose()})}};AdamaxOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}};AdamaxOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.beta1,config.beta2,config.epsilon,config.decay)};AdamaxOptimizer.className="AdamaxOptimizer";return AdamaxOptimizer}(optimizer_1.Optimizer);exports.AdamaxOptimizer=AdamaxOptimizer;serialization_1.registerClass(AdamaxOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./optimizer":171}],170:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var sgd_optimizer_1=require("./sgd_optimizer");var MomentumOptimizer=function(_super){__extends(MomentumOptimizer,_super);function MomentumOptimizer(learningRate,momentum,useNesterov){if(useNesterov===void 0){useNesterov=false}var _this=_super.call(this,learningRate)||this;_this.learningRate=learningRate;_this.momentum=momentum;_this.useNesterov=useNesterov;_this.m=ops_1.scalar(_this.momentum);_this.accumulations={};return _this}MomentumOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;var _loop_1=function(variableName){var value=environment_1.ENV.engine.registeredVariables[variableName];if(this_1.accumulations[variableName]==null){var trainable_1=false;globals_1.tidy(function(){_this.accumulations[variableName]=ops_1.zerosLike(value).variable(trainable_1)})}var accumulation=this_1.accumulations[variableName];var gradient=variableGradients[variableName];globals_1.tidy(function(){var newValue;var newAccumulation=_this.m.mul(accumulation).add(gradient);if(_this.useNesterov){newValue=_this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value)}else{newValue=_this.c.mul(newAccumulation).add(value)}_this.accumulations[variableName].assign(newAccumulation);value.assign(newValue)})};var this_1=this;for(var variableName in variableGradients){_loop_1(variableName)}};MomentumOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.m.dispose();if(this.accumulations!=null){for(var variableName in this.accumulations){this.accumulations[variableName].dispose()}}};MomentumOptimizer.prototype.setMomentum=function(momentum){this.momentum=momentum};MomentumOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}};MomentumOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.momentum,config.useNesterov)};MomentumOptimizer.className="MomentumOptimizer";return MomentumOptimizer}(sgd_optimizer_1.SGDOptimizer);exports.MomentumOptimizer=MomentumOptimizer;serialization_1.registerClass(MomentumOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./sgd_optimizer":174}],171:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var globals_1=require("../globals");var serialization_1=require("../serialization");var Optimizer=function(_super){__extends(Optimizer,_super);function Optimizer(){return _super!==null&&_super.apply(this,arguments)||this}Optimizer.prototype.minimize=function(f,returnCost,varList){if(returnCost===void 0){returnCost=false}var _a=this.computeGradients(f,varList),value=_a.value,grads=_a.grads;this.applyGradients(grads);var varNames=Object.keys(grads);varNames.forEach(function(varName){return grads[varName].dispose()});if(returnCost){return value}else{value.dispose();return null}};Optimizer.prototype.computeGradients=function(f,varList){return globals_1.variableGrads(f,varList)};return Optimizer}(serialization_1.Serializable);exports.Optimizer=Optimizer},{"../globals":53,"../serialization":176}],172:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var adadelta_optimizer_1=require("./adadelta_optimizer");var adagrad_optimizer_1=require("./adagrad_optimizer");var adam_optimizer_1=require("./adam_optimizer");var adamax_optimizer_1=require("./adamax_optimizer");var momentum_optimizer_1=require("./momentum_optimizer");var rmsprop_optimizer_1=require("./rmsprop_optimizer");var sgd_optimizer_1=require("./sgd_optimizer");var OptimizerConstructors=function(){function OptimizerConstructors(){}OptimizerConstructors.sgd=function(learningRate){return new sgd_optimizer_1.SGDOptimizer(learningRate)};OptimizerConstructors.momentum=function(learningRate,momentum,useNesterov){if(useNesterov===void 0){useNesterov=false}return new momentum_optimizer_1.MomentumOptimizer(learningRate,momentum,useNesterov)};OptimizerConstructors.rmsprop=function(learningRate,decay,momentum,epsilon,centered){if(decay===void 0){decay=.9}if(momentum===void 0){momentum=0}if(epsilon===void 0){epsilon=null}if(centered===void 0){centered=false}return new rmsprop_optimizer_1.RMSPropOptimizer(learningRate,decay,momentum,epsilon,centered)};OptimizerConstructors.adam=function(learningRate,beta1,beta2,epsilon){if(learningRate===void 0){learningRate=.001}if(beta1===void 0){beta1=.9}if(beta2===void 0){beta2=.999}if(epsilon===void 0){epsilon=null}return new adam_optimizer_1.AdamOptimizer(learningRate,beta1,beta2,epsilon)};OptimizerConstructors.adadelta=function(learningRate,rho,epsilon){if(learningRate===void 0){learningRate=.001}if(rho===void 0){rho=.95}if(epsilon===void 0){epsilon=null}return new adadelta_optimizer_1.AdadeltaOptimizer(learningRate,rho,epsilon)};OptimizerConstructors.adamax=function(learningRate,beta1,beta2,epsilon,decay){if(learningRate===void 0){learningRate=.002}if(beta1===void 0){beta1=.9}if(beta2===void 0){beta2=.999}if(epsilon===void 0){epsilon=null}if(decay===void 0){decay=0}return new adamax_optimizer_1.AdamaxOptimizer(learningRate,beta1,beta2,epsilon,decay)};OptimizerConstructors.adagrad=function(learningRate,initialAccumulatorValue){if(initialAccumulatorValue===void 0){initialAccumulatorValue=.1}return new adagrad_optimizer_1.AdagradOptimizer(learningRate,initialAccumulatorValue)};return OptimizerConstructors}();exports.OptimizerConstructors=OptimizerConstructors},{"./adadelta_optimizer":166,"./adagrad_optimizer":167,"./adam_optimizer":168,"./adamax_optimizer":169,"./momentum_optimizer":170,"./rmsprop_optimizer":173,"./sgd_optimizer":174}],173:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var optimizer_1=require("./optimizer");var RMSPropOptimizer=function(_super){__extends(RMSPropOptimizer,_super);function RMSPropOptimizer(learningRate,decay,momentum,epsilon,centered){if(decay===void 0){decay=.9}if(momentum===void 0){momentum=0}if(epsilon===void 0){epsilon=null}if(centered===void 0){centered=false}var _this=_super.call(this)||this;_this.learningRate=learningRate;_this.decay=decay;_this.momentum=momentum;_this.epsilon=epsilon;_this.accumulatedMeanSquares={};_this.accumulatedMeanGrads={};_this.accumulatedMoments={};_this.c=globals_1.keep(ops_1.scalar(learningRate));_this.decayScalar=globals_1.keep(ops_1.scalar(decay));_this.momentumScalar=globals_1.keep(ops_1.scalar(momentum));_this.oneMinusDecay=globals_1.keep(ops_1.scalar(1-decay));_this.centered=centered;if(epsilon===null){epsilon=environment_1.ENV.get("EPSILON")}_this.epsilonScalar=globals_1.keep(ops_1.scalar(epsilon));return _this}RMSPropOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;var _loop_1=function(variableName){var value=environment_1.ENV.engine.registeredVariables[variableName];if(this_1.accumulatedMeanSquares[variableName]==null){var trainable_1=false;globals_1.tidy(function(){_this.accumulatedMeanSquares[variableName]=ops_1.zerosLike(value).variable(trainable_1)})}if(this_1.accumulatedMeanGrads[variableName]==null&&this_1.centered){var trainable_2=false;globals_1.tidy(function(){_this.accumulatedMeanGrads[variableName]=ops_1.zerosLike(value).variable(trainable_2)})}if(this_1.accumulatedMoments[variableName]==null){var trainable_3=false;globals_1.tidy(function(){_this.accumulatedMoments[variableName]=ops_1.zerosLike(value).variable(trainable_3)})}var accumulatedMeanSquare=this_1.accumulatedMeanSquares[variableName];var accumulatedMeanGrad=this_1.accumulatedMeanGrads[variableName];var accumulatedMoments=this_1.accumulatedMoments[variableName];var gradient=variableGradients[variableName];globals_1.tidy(function(){var newAccumulatedMeanSquare=_this.decayScalar.mul(accumulatedMeanSquare).add(_this.oneMinusDecay.mul(gradient.square()));if(_this.centered){var newAccumulatedMeanGrad=_this.decayScalar.mul(accumulatedMeanGrad).add(_this.oneMinusDecay.mul(gradient));var newAccumulatedMoments=_this.momentumScalar.mul(accumulatedMoments).add(_this.c.mul(gradient).div(newAccumulatedMeanSquare.sub(newAccumulatedMeanGrad.square().add(_this.epsilonScalar)).sqrt()));_this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare);_this.accumulatedMeanGrads[variableName].assign(newAccumulatedMeanGrad);_this.accumulatedMoments[variableName].assign(newAccumulatedMoments);var newValue=value.sub(newAccumulatedMoments);value.assign(newValue)}else{var newAccumulatedMeanSquare_1=_this.decayScalar.mul(accumulatedMeanSquare).add(_this.oneMinusDecay.mul(gradient.square()));var newAccumulatedMoments=_this.momentumScalar.mul(accumulatedMoments).add(_this.c.mul(gradient).div(newAccumulatedMeanSquare_1.add(_this.epsilonScalar).sqrt()));_this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare_1);_this.accumulatedMoments[variableName].assign(newAccumulatedMoments);var newValue=value.sub(newAccumulatedMoments);value.assign(newValue)}})};var this_1=this;for(var variableName in variableGradients){_loop_1(variableName)}};RMSPropOptimizer.prototype.dispose=function(){var _this=this;this.c.dispose();this.epsilonScalar.dispose();this.decayScalar.dispose();this.momentumScalar.dispose();this.oneMinusDecay.dispose();if(this.accumulatedMeanSquares!=null){Object.keys(this.accumulatedMeanSquares).forEach(function(name){return _this.accumulatedMeanSquares[name].dispose()})}if(this.accumulatedMeanGrads!=null&&this.centered){Object.keys(this.accumulatedMeanGrads).forEach(function(name){return _this.accumulatedMeanGrads[name].dispose()})}if(this.accumulatedMoments!=null){Object.keys(this.accumulatedMoments).forEach(function(name){return _this.accumulatedMoments[name].dispose()})}};RMSPropOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}};RMSPropOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.decay,config.momentum,config.epsilon,config.centered)};RMSPropOptimizer.className="RMSPropOptimizer";return RMSPropOptimizer}(optimizer_1.Optimizer);exports.RMSPropOptimizer=RMSPropOptimizer;serialization_1.registerClass(RMSPropOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./optimizer":171}],174:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var globals_1=require("../globals");var ops_1=require("../ops/ops");var serialization_1=require("../serialization");var optimizer_1=require("./optimizer");var SGDOptimizer=function(_super){__extends(SGDOptimizer,_super);function SGDOptimizer(learningRate){var _this=_super.call(this)||this;_this.learningRate=learningRate;_this.setLearningRate(learningRate);return _this}SGDOptimizer.prototype.applyGradients=function(variableGradients){var _this=this;var varNames=Object.keys(variableGradients);varNames.forEach(function(varName){var gradient=variableGradients[varName];var value=environment_1.ENV.engine.registeredVariables[varName];globals_1.tidy(function(){var newValue=_this.c.mul(gradient).add(value);value.assign(newValue)})})};SGDOptimizer.prototype.setLearningRate=function(learningRate){this.learningRate=learningRate;if(this.c!=null){this.c.dispose()}this.c=globals_1.keep(ops_1.scalar(-learningRate))};SGDOptimizer.prototype.dispose=function(){this.c.dispose()};SGDOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate}};SGDOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate)};SGDOptimizer.className="SGDOptimizer";return SGDOptimizer}(optimizer_1.Optimizer);exports.SGDOptimizer=SGDOptimizer;serialization_1.registerClass(SGDOptimizer)},{"../environment":51,"../globals":53,"../ops/ops":148,"../serialization":176,"./optimizer":171}],175:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("./util");var Profiler=function(){function Profiler(backendTimer,logger){this.backendTimer=backendTimer;this.logger=logger;if(logger==null){this.logger=new Logger}}Profiler.prototype.profileKernel=function(name,f){var _this=this;var result;var holdResultWrapperFn=function(){result=f()};var timer=this.backendTimer.time(holdResultWrapperFn);var results=Array.isArray(result)?result:[result];results.forEach(function(r){var vals=r.dataSync();util.checkComputationForNaN(vals,r.dtype,name);timer.then(function(timing){_this.logger.logKernelProfile(name,r,vals,timing.kernelMs)})});return result};return Profiler}();exports.Profiler=Profiler;var Logger=function(){function Logger(){}Logger.prototype.logKernelProfile=function(name,result,vals,timeMs){var time=util.rightPad(timeMs+"ms",9);var paddedName=util.rightPad(name,25);var rank=result.rank;var size=result.size;var shape=util.rightPad(result.shape.toString(),14);console.log("%c"+paddedName+"\t%c"+time+"\t%c"+rank+"D "+shape+"\t%c"+size,"font-weight:bold","color:red","color:blue","color: orange")};return Logger}();exports.Logger=Logger},{"./util":185}],176:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util_1=require("./util");var Serializable=function(){function Serializable(){}Serializable.prototype.getClassName=function(){return this.constructor.className};Serializable.fromConfig=function(cls,config){return new cls(config)};return Serializable}();exports.Serializable=Serializable;var SerializationMap=function(){function SerializationMap(){this.classNameMap={}}SerializationMap.getMap=function(){if(SerializationMap.instance==null){SerializationMap.instance=new SerializationMap}return SerializationMap.instance};SerializationMap.register=function(cls){SerializationMap.getMap().classNameMap[cls.className]=[cls,cls.fromConfig]};return SerializationMap}();exports.SerializationMap=SerializationMap;function registerClass(cls){util_1.assert(cls.className!=null,"Class being registered does not have the static className property "+"defined.");util_1.assert(typeof cls.className==="string","className is required to be a string, but got type "+typeof cls.className);util_1.assert(cls.className.length>0,"Class being registered has an empty-string as its className, which "+"is disallowed.");SerializationMap.register(cls)}exports.registerClass=registerClass},{"./util":185}],177:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tensor_1=require("./tensor");var util=require("./util");function getFilteredNodesXToY(tape,xs,y){var tensorsFromX={};var nodesFromX={};for(var i=0;i<xs.length;i++){tensorsFromX[xs[i].id]=true}for(var i=0;i<tape.length;i++){var node=tape[i];var nodeInputs=node.inputs;for(var inputName in nodeInputs){var input=nodeInputs[inputName];var anyInputFromX=false;for(var j=0;j<xs.length;j++){if(tensorsFromX[input.id]){node.outputs.forEach(function(output){return tensorsFromX[output.id]=true});anyInputFromX=true;nodesFromX[node.id]=true;break}}if(anyInputFromX){break}}}var tensorsLeadToY={};tensorsLeadToY[y.id]=true;var nodesToY={};for(var i=tape.length-1;i>=0;i--){var node=tape[i];var nodeInputs=node.inputs;for(var j=0;j<node.outputs.length;j++){if(tensorsLeadToY[node.outputs[j].id]){for(var inputName in nodeInputs){tensorsLeadToY[nodeInputs[inputName].id]=true;nodesToY[node.id]=true}break}}}var filteredTape=[];for(var i=0;i<tape.length;i++){var node=tape[i];if(nodesFromX[node.id]&&nodesToY[node.id]){var prunedInputs={};for(var inputName in node.inputs){var nodeInput=node.inputs[inputName];if(tensorsFromX[nodeInput.id]){prunedInputs[inputName]=nodeInput}}var prunedNode=Object.assign({},node);prunedNode.inputs=prunedInputs;prunedNode.outputs=node.outputs;filteredTape.push(prunedNode)}}return filteredTape}exports.getFilteredNodesXToY=getFilteredNodesXToY;function backpropagateGradients(tensorAccumulatedGradientMap,filteredTape){var _loop_1=function(i){var node=filteredTape[i];var dys=[];node.outputs.forEach(function(o){var gradTensor=tensorAccumulatedGradientMap[o.id];if(gradTensor!=null){dys.push(gradTensor)}else{var dy=tensor_1.Tensor.make(o.shape,{values:util.makeZerosTypedArray(o.size,o.dtype)},o.dtype);dys.push(dy)}});if(node.gradient==null){throw new Error("Cannot compute gradient: gradient function not found "+("for "+node.name+"."))}var inputGradients=node.gradient(node.outputs.length===1?dys[0]:dys);for(var inputName in node.inputs){if(!(inputName in inputGradients)){throw new Error("Cannot backprop through input "+inputName+". "+("Available gradients found: "+Object.keys(inputGradients)+"."))}var dx=inputGradients[inputName]();var x=node.inputs[inputName];if(!util.arraysEqual(dx.shape,x.shape)){throw new Error("Error in gradient for op "+node.name+". The gradient of input "+("'"+inputName+"' has shape '"+dx.shape+"', which does not match ")+("the shape of the input '"+x.shape+"'"))}if(tensorAccumulatedGradientMap[x.id]==null){tensorAccumulatedGradientMap[x.id]=dx}else{var curGradient=tensorAccumulatedGradientMap[x.id];tensorAccumulatedGradientMap[x.id]=curGradient.add(dx);curGradient.dispose()}}};for(var i=filteredTape.length-1;i>=0;i--){_loop_1(i)}}exports.backpropagateGradients=backpropagateGradients},{"./tensor":178,"./util":185}],178:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}};Object.defineProperty(exports,"__esModule",{value:true});var tensor_format_1=require("./tensor_format");var util=require("./util");var util_1=require("./util");var TensorBuffer=function(){function TensorBuffer(shape,dtype,values){this.dtype=dtype;this.shape=shape.slice();this.size=util.sizeFromShape(shape);if(values!=null){var n=values.length;util.assert(n===this.size,"Length of values '"+n+"' does not match the size "+("inferred by the shape '"+this.size+"'."))}if(dtype==="complex64"){throw new Error("complex64 dtype TensorBuffers are not supported. Please create "+"a TensorBuffer for the real and imaginary parts separately and "+"call tf.complex(real, imag).")}this.values=values||util.getTypedArrayFromDType(dtype,util.sizeFromShape(this.shape));this.strides=util_1.computeStrides(shape)}TensorBuffer.prototype.set=function(value){var locs=[];for(var _i=1;_i<arguments.length;_i++){locs[_i-1]=arguments[_i]}if(locs.length===0){locs=[0]}util.assert(locs.length===this.rank,"The number of provided coordinates ("+locs.length+") must "+("match the rank ("+this.rank+")"));var index=this.locToIndex(locs);this.values[index]=value};TensorBuffer.prototype.get=function(){var locs=[];for(var _i=0;_i<arguments.length;_i++){locs[_i]=arguments[_i]}if(locs.length===0){locs=[0]}var index=locs[locs.length-1];for(var i=0;i<locs.length-1;++i){index+=this.strides[i]*locs[i]}return this.values[index]};TensorBuffer.prototype.locToIndex=function(locs){if(this.rank===0){return 0}else if(this.rank===1){return locs[0]}var index=locs[locs.length-1];for(var i=0;i<locs.length-1;++i){index+=this.strides[i]*locs[i]}return index};TensorBuffer.prototype.indexToLoc=function(index){if(this.rank===0){return[]}else if(this.rank===1){return[index]}var locs=new Array(this.shape.length);for(var i=0;i<locs.length-1;++i){locs[i]=Math.floor(index/this.strides[i]);index-=locs[i]*this.strides[i]}locs[locs.length-1]=index;return locs};Object.defineProperty(TensorBuffer.prototype,"rank",{get:function(){return this.shape.length},enumerable:true,configurable:true});TensorBuffer.prototype.toTensor=function(){return Tensor.make(this.shape,{values:this.values},this.dtype)};return TensorBuffer}();exports.TensorBuffer=TensorBuffer;var trackerFn=null;var opHandler=null;function setTensorTracker(fn){trackerFn=fn}exports.setTensorTracker=setTensorTracker;function setOpHandler(handler){opHandler=handler}exports.setOpHandler=setOpHandler;var Tensor=function(){function Tensor(shape,dtype,values,dataId){this.isDisposedInternal=false;this.shape=shape.slice();this.dtype=dtype||"float32";this.size=util.sizeFromShape(shape);if(values!=null){util.assert(this.size===values.length,"Based on the provided shape, ["+shape+"], and dtype "+(this.dtype+", the tensor should have ")+(this.size+" values but has "+values.length))}this.strides=util_1.computeStrides(shape);this.dataId=dataId!=null?dataId:{};this.id=Tensor.nextId++;this.rankType=this.rank<5?this.rank.toString():"higher";trackerFn().registerTensor(this);if(values!=null){trackerFn().write(this.dataId,values)}}Tensor.make=function(shape,data,dtype){return new Tensor(shape,dtype,data.values,data.dataId)};Tensor.prototype.flatten=function(){this.throwIfDisposed();return this.as1D()};Tensor.prototype.asScalar=function(){this.throwIfDisposed();util.assert(this.size===1,"The array must have only 1 element.");return this.reshape([])};Tensor.prototype.as1D=function(){this.throwIfDisposed();return this.reshape([this.size])};Tensor.prototype.as2D=function(rows,columns){this.throwIfDisposed();return this.reshape([rows,columns])};Tensor.prototype.as3D=function(rows,columns,depth){this.throwIfDisposed();return this.reshape([rows,columns,depth])};Tensor.prototype.as4D=function(rows,columns,depth,depth2){this.throwIfDisposed();return this.reshape([rows,columns,depth,depth2])};Tensor.prototype.asType=function(dtype){this.throwIfDisposed();return opHandler.cast(this,dtype)};Object.defineProperty(Tensor.prototype,"rank",{get:function(){return this.shape.length},enumerable:true,configurable:true});Tensor.prototype.get=function(){var locs=[];for(var _i=0;_i<arguments.length;_i++){locs[_i]=arguments[_i]}util.assert(locs.length===this.rank,"Number of coordinates in get() must match the rank of the tensor");util.assert(this.dtype!=="complex64","Tensor.get() is not supported for complex64 tensors yet.");this.throwIfDisposed();if(locs.length===0){locs=[0]}var index=locs[locs.length-1];for(var i=0;i<locs.length-1;++i){index+=this.strides[i]*locs[i]}return this.dataSync()[index]};Tensor.prototype.buffer=function(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())};Tensor.prototype.data=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){this.throwIfDisposed();return[2,trackerFn().read(this.dataId)]})})};Tensor.prototype.dataSync=function(){this.throwIfDisposed();return trackerFn().readSync(this.dataId)};Tensor.prototype.dispose=function(){if(this.isDisposed){return}trackerFn().disposeTensor(this);this.isDisposedInternal=true};Object.defineProperty(Tensor.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:true,configurable:true});Tensor.prototype.throwIfDisposed=function(){if(this.isDisposed){throw new Error("Tensor is disposed.")}};Tensor.prototype.toFloat=function(){return this.asType("float32")};Tensor.prototype.toInt=function(){return this.asType("int32")};Tensor.prototype.toBool=function(){return this.asType("bool")};Tensor.prototype.print=function(verbose){if(verbose===void 0){verbose=false}return opHandler.print(this,verbose)};Tensor.prototype.reshape=function(newShape){this.throwIfDisposed();return opHandler.reshape(this,newShape)};Tensor.prototype.reshapeAs=function(x){this.throwIfDisposed();return this.reshape(x.shape)};Tensor.prototype.expandDims=function(axis){if(axis===void 0){axis=0}return opHandler.expandDims(this,axis)};Tensor.prototype.cumsum=function(axis,exclusive,reverse){if(axis===void 0){axis=0}if(exclusive===void 0){exclusive=false}if(reverse===void 0){reverse=false}return opHandler.cumsum(this,axis,exclusive,reverse)};Tensor.prototype.squeeze=function(axis){this.throwIfDisposed();return opHandler.squeeze(this,axis)};Tensor.prototype.clone=function(){this.throwIfDisposed();return opHandler.clone(this)};Tensor.prototype.toString=function(verbose){if(verbose===void 0){verbose=false}var vals=this.dataSync();return tensor_format_1.tensorToString(vals,this.shape,this.dtype,verbose)};Tensor.prototype.tile=function(reps){this.throwIfDisposed();return opHandler.tile(this,reps)};Tensor.prototype.gather=function(indices,axis){if(axis===void 0){axis=0}this.throwIfDisposed();return opHandler.gather(this,indices,axis)};Tensor.prototype.matMul=function(b,transposeA,transposeB){if(transposeA===void 0){transposeA=false}if(transposeB===void 0){transposeB=false}this.throwIfDisposed();return opHandler.matMul(this,b,transposeA,transposeB)};Tensor.prototype.dot=function(b){this.throwIfDisposed();return opHandler.dot(this,b)};Tensor.prototype.norm=function(ord,axis,keepDims){if(ord===void 0){ord="euclidean"}if(axis===void 0){axis=null}if(keepDims===void 0){keepDims=false}this.throwIfDisposed();return opHandler.norm(this,ord,axis,keepDims)};Tensor.prototype.slice=function(begin,size){this.throwIfDisposed();return opHandler.slice(this,begin,size)};Tensor.prototype.reverse=function(axis){this.throwIfDisposed();return opHandler.reverse(this,axis)};Tensor.prototype.concat=function(x,axis){if(axis===void 0){axis=0}this.throwIfDisposed();return opHandler.concat([this,x],axis)};Tensor.prototype.split=function(numOrSizeSplits,axis){if(axis===void 0){axis=0}this.throwIfDisposed();return opHandler.split(this,numOrSizeSplits,axis)};Tensor.prototype.stack=function(x,axi