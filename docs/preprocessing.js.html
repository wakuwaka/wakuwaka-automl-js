<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: preprocessing.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: preprocessing.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const tf = require('@tensorflow/tfjs');
const utils = require('./utils')

/**
 * Converts a set of inputs, represented as
 * matrix X with columns corresponding to the
 * different features, into a numeric matrix X'.
 * Can handle missing values and categorical 
 * columns. The type of column is detected 
 * automatically.
 */
class TableFeaturesTransformer{
    constructor(params){
        this.params = utils.set_defaults(params)
        this.state = null
    }

    /**
     * Determine if the column is numeric, categorical, or other.
     * @param {Array} C 1d array of values, represents single column.
     * @returns {String} Type of the output. Could be either 'category'
     * or 'number'.
     */
    column_type(C){
        var feature = {'type': 'skip'}
        var n_rows = C.length

        // check if values are numerical or categorical
        var is_num = true

        for(var j=0; j&lt;n_rows; j++){
            var x = C[j]
            
            // missing value, skip it
            if(x == ''){  
                continue
            }

            // check if the value can be converted to float
            if(isNaN(Number(x))){
                is_num = false  // if not - it is not a numeric value
                break
            }
        }

        if(is_num){

            // calculate the mean of values in column
            var sum = 0.0
            var N = 0

            for(var j=0; j&lt;n_rows; j++){
                var x = C[j]
                if(x == ''){  
                    continue
                }
                sum += Number(x)
                N += 1
            }

            var mean = sum / N

            // used for imputation
            feature['type'] = 'number'
            feature['mean'] = mean
        }else{

            var cats = {} // all possible categories
            var cats_l = []
            var cat_index = 0

            for(var j=0; j&lt;n_rows; j++){
                var x = C[j]

                if(x in cats){
                    continue
                }

                cats[x] = true
                cats_l.push(x)
            }

            // ensure that categories are in sorted order
            cats_l.sort()

            for(var j=0; j&lt;cats_l.length; j++){
                cats[cats_l[j]] = j
            }

            feature['categories'] = cats
            feature['n_classes'] = cats_l.length
            feature['type'] = 'category'
        }

        return feature
    }

    /**
     * Select a single column of matrix X.
     * @param {Array} X nested array, represents matrix of raw inputs.
     * @param {Integer} i Index of the column to select
     */
    get_column(X, i){
        var C = []
        for(var j=0; j&lt;X.length; j++){
            C.push(X[j][i])
        }
        return C
    }

    /**
     * Determines the type of columns, and calculates all the necessary
     * parameters for imputation of missing values and conversion of 
     * categorical values, if any.
     * @param {Array} X Matrix of raw inputs, where columns correspond
     * to different features.
     * @param {Array} y A vector of outputs. A type of problem could be
     * determined from the type of the output.
     * @param {Array} feature_names An array that contains names of the
     * features as strings.
     */
    fit(X, y, feature_names=null){
        var features = {}

        this.state = {
            'features': features
        }
        
        var n_cols = X[0].length

        for(var i=0; i&lt;n_cols; i++){
            var C = this.get_column(X, i)
            features[i] = this.column_type(C)
        }

        this.state['output'] = this.column_type(y)

        if(feature_names !== null){
            var feature_params = []
            for(var j=0; j&lt;X[0].length; j++){
                var f = features[j]
                if(f['type'] == 'number'){
                    feature_params.push({
                        name: feature_names[j],
                        type: 'number'
                    })
                }else{
                    var cats = f['categories']
                    var ivcats = {}
                    var N_cats = 0
                    // make format: {1: 'feat_a', 2: 'feat_b', ...}
                    for(var c in cats){
                        ivcats[cats[c]] = c
                        N_cats++
                    }
                    
                    for(var i=0; i&lt;N_cats; i++){
                        feature_params.push({
                            name: feature_names[j] + "==" + ivcats[i],
                            type: 'boolean'
                        })
                    }
                }
     